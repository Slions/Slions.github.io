<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://slions.github.io/atom.xml" rel="self"/>
  
  <link href="https://slions.github.io/"/>
  <updated>2021-12-02T15:27:43.131Z</updated>
  <id>https://slions.github.io/</id>
  
  <author>
    <name>Jingyu Shi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>（十一）Jinja2模板</title>
    <link href="https://slions.github.io/2021/12/02/%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89Jinja2%E6%A8%A1%E6%9D%BF/"/>
    <id>https://slions.github.io/2021/12/02/%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89Jinja2%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-12-02T10:43:04.000Z</published>
    <updated>2021-12-02T15:27:43.131Z</updated>
    
    <content type="html"><![CDATA[<p>日常ansible playbook编写过程中，会涉及到很多变量的解析与替换，解析并替换模板表达式的过程称为渲染。</p><p>ansibles使用<code>Jinja2</code>来完成渲染工作，它是Python的一种模板引擎。</p><p>Jinja2模板引擎提供了三种特殊符号来包围模板表达式：</p><ol><li>&#123;&#123;xxx&#125;&#125;：双大括号包围变量或表达式(Ansible中的变量就是它包围的)</li><li>&#123;#xxx#&#125;：Jinja2的注释符号</li><li>&#123;%xxx%&#125;：Jinja2的一些特殊关键字标签，比如if语句、for循环语句等等</li></ol><h1 id="Jinja2条件判断"><a href="#Jinja2条件判断" class="headerlink" title="Jinja2条件判断"></a>Jinja2条件判断</h1><p>Jinja2中可以使用if语句进行条件判断。</p><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if CONDITION1 %&#125;</span><br><span class="line">  string_or_expression1</span><br><span class="line">&#123;% elif CONDITION2 %&#125;</span><br><span class="line">  string_or_expression2</span><br><span class="line">&#123;% elif CONDITION3 %&#125;</span><br><span class="line">  string_or_expression3</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">  string_or_expression4</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>其中elif和else分支都是可省略的。CONDITION部分是条件表达式</p><p>例如：</p><p>当前结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# tree</span><br><span class="line">.</span><br><span class="line">├── test.yml</span><br><span class="line">├── ansible.cfg</span><br><span class="line">├── ansible.log</span><br><span class="line">├── facts</span><br><span class="line">│   ├── 192.168.100.10</span><br><span class="line">│   └── 192.168.100.11</span><br><span class="line">├── inventory</span><br><span class="line">│   └── hosts</span><br><span class="line">└── roles</span><br><span class="line">    └── first</span><br><span class="line">        ├── tasks</span><br><span class="line">        │   └── main.yml</span><br><span class="line">        └── templates</span><br><span class="line">            └── my.j2</span><br></pre></td></tr></table></figure><p>其中模板文件my.j2内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if whatday == &quot;0&quot; %&#125;</span><br><span class="line">周日</span><br><span class="line">&#123;% elif whatday == &quot;1&quot; %&#125;</span><br><span class="line">周一</span><br><span class="line">&#123;% elif whatday == &quot;2&quot; %&#125;</span><br><span class="line">周二</span><br><span class="line">&#123;% elif whatday == &quot;3&quot; %&#125;</span><br><span class="line">周三</span><br><span class="line">&#123;% elif whatday == &quot;4&quot; %&#125;</span><br><span class="line">周四</span><br><span class="line">&#123;% elif whatday == &quot;5&quot; %&#125;</span><br><span class="line">周五</span><br><span class="line">&#123;% elif whatday == &quot;6&quot; %&#125;</span><br><span class="line">周六</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">输入错误</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>上面判断变量whatday的值，然后输出对应的星期几。因为whatday变量的值是字符串，所以让它和字符串形式的数值进行等值比较。当然，也可以使用筛选器将字符串转换为数值后进行数值比较：whatday|int == 0。</p><p>roles/first/tasks中的main.yml内容为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">template:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">my.j2</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">/tmp/dayfile</span></span><br></pre></td></tr></table></figure><p>任务入口文件test.yml内容为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars_prompt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whatday</span></span><br><span class="line">      <span class="attr">default:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">prompt:</span> <span class="string">&quot;输入今天星期几（0:星期日，1:星期一，...，6:星期六）&quot;</span></span><br><span class="line">      <span class="attr">privat:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">first</span></span><br></pre></td></tr></table></figure><p>执行后可以在/tmp/dayfile中查看到替换后的对应字符。</p><p>如果if语句的分支比较简单(没有elif逻辑)，那么可以使用行内if表达式。</p><p>其语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string_or_expr1 if CONDITION else string_or_expr2</span><br></pre></td></tr></table></figure><p>因为行内if是表达式而不是语句块，所以不使用 &#123;%%&#125; 符号，而使用&#123;&#123;&#125;&#125; 。</p><p>例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;&#x27;周末&#x27; if whatday|int &gt; 5 else &#x27;工作日&#x27;&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h1 id="for循环迭代"><a href="#for循环迭代" class="headerlink" title="for循环迭代"></a>for循环迭代</h1><h2 id="for迭代列表"><a href="#for迭代列表" class="headerlink" title="for迭代列表"></a>for迭代列表</h2><p>for循环的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for i in LIST %&#125;</span><br><span class="line">    string_or_expression</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>还支持直接条件判断筛选要参与迭代的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for i in LIST if CONDITION %&#125;</span><br><span class="line">    string_or_expression</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>此外，Jinja2的for语句还允许使用else分支，如果for所迭代的列表LIST是空列表(或没有元素可迭代)，则会执行else分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for i in LIST %&#125;</span><br><span class="line">    string_or_expression</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    string_or_expression</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>例如，在模板文件a.txt.j2中有如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for file in files %&#125;</span><br><span class="line">&lt;&#123;&#123;file&#125;&#125;&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">no file in files</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>playbook文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: localhost</span><br><span class="line">  gather_facts: no</span><br><span class="line">  tasks: </span><br><span class="line">    - template:</span><br><span class="line">        src: a.txt.j2</span><br><span class="line">        dest: /tmp/a.txt</span><br><span class="line">      vars: </span><br><span class="line">        files:</span><br><span class="line">          - /tmp/a1</span><br><span class="line">          - /tmp/a2</span><br><span class="line">          - /tmp/a3</span><br></pre></td></tr></table></figure><p>执行playbook之后，将生成包含如下内容的/tmp/a.txt文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;/tmp/a1&gt;</span><br><span class="line">&lt;/tmp/a2&gt;</span><br><span class="line">&lt;/tmp/a3&gt;</span><br></pre></td></tr></table></figure><p>如果将playbook中的files变量设置为空列表，则会执行else分支，所以生成的/tmp/a.txt的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no file in files</span><br></pre></td></tr></table></figure><p>如果files变量未定义或变量类型不是list，则默认会报错。针对未定义变量，可采用如下策略提供默认空列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for file in (files|default([])) %&#125;</span><br><span class="line">&lt;&#123;&#123;file&#125;&#125;&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">no file in files</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>如果不想迭代文件列表中的/tmp/a3，则可以加上条件判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for file in (files|default([])) if file != &quot;/tmp/a3&quot; %&#125;</span><br><span class="line">&lt;&#123;&#123;file&#125;&#125;&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">no file in files</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>Jinja2的for循环没有提供break和continue的功能，所以只能通过&#123;% for…if…%&#125;来间接实现类似功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日常ansible playbook编写过程中，会涉及到很多变量的解析与替换，解析并替换模板表达式的过程称为渲染。&lt;/p&gt;
&lt;p&gt;ansibles使用&lt;code&gt;Jinja2&lt;/code&gt;来完成渲染工作，它是Python的一种模板引擎。&lt;/p&gt;
&lt;p&gt;Jinja2模板引擎提</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（十）ansible异常处理</title>
    <link href="https://slions.github.io/2021/12/02/%EF%BC%88%E5%8D%81%EF%BC%89ansible%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://slions.github.io/2021/12/02/%EF%BC%88%E5%8D%81%EF%BC%89ansible%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2021-12-02T04:50:53.000Z</published>
    <updated>2021-12-02T07:23:35.285Z</updated>
    
    <content type="html"><![CDATA[<p>在日常使用ansible的过程中会发现，执行shell或command模块时，Ansible只认为0退出状态码是正确的，其它所有退出状态码都是失败的，但我们自己知道非0退出状态码并非一定代表着失败。</p><p>比如下例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">        ls /home/aa</span></span><br><span class="line"><span class="string"></span>      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">res.stdout</span></span><br></pre></td></tr></table></figure><p>执行结果会直接报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TASK [shell] *****************************************************************************************************</span><br><span class="line">fatal: [localhost]: FAILED! =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;ls /home/aa\n&quot;, &quot;delta&quot;: &quot;0:00:00.034093&quot;, &quot;end&quot;: &quot;2021-12-02 14:16:45.029276&quot;, &quot;msg&quot;: &quot;non-zero return code&quot;, &quot;rc&quot;: 2, &quot;start&quot;: &quot;2021-12-02 14:16:44.995183&quot;, &quot;stderr&quot;: &quot;ls: 无法访问/home/aa: 没有那个文件或目录&quot;, &quot;stderr_lines&quot;: [&quot;ls: 无法访问/home/aa: 没有那个文件或目录&quot;], &quot;stdout&quot;: &quot;&quot;, &quot;stdout_lines&quot;: []&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">localhost                  : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p>默认情况下，Ansible端无法连接某个节点时、某节点执行某个任务失败时，Ansible都会将这个节点从活动节点列表中(即<code>play_hosts</code>变量中)移除，以避免该节点继续执行之后的任务。用户可以去修改Ansible对这种异常现象的默认处理方式，比如遇到错误也不让该节点退出舞台，而是继续执行后续任务，又或者某节点执行任务失败并让整个play都失败。</p><h1 id="fail模块"><a href="#fail模块" class="headerlink" title="fail模块"></a>fail模块</h1><p>使用<code>fail</code>模块，可以人为制造一个失败的任务。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">fail:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;已手动设置失败&quot;</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">inventory_hostname</span> <span class="string">==</span> <span class="string">&#x27;192.168.100.10&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;成功了&quot;</span></span><br></pre></td></tr></table></figure><p>上面的fail会任务失败，并使得此节点不会执行后续任务，但其它节点会继续执行任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PLAY [test] ******************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [fail] ******************************************************************************************************</span><br><span class="line">fatal: [192.168.100.10]: FAILED! =&gt; &#123;&quot;changed&quot;: false, &quot;msg&quot;: &quot;已手动设置失败&quot;&#125;</span><br><span class="line">skipping: [192.168.100.11]</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [192.168.100.11] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;成功了&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">192.168.100.10             : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.168.100.11             : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><h1 id="assert模块"><a href="#assert模块" class="headerlink" title="assert模块"></a>assert模块</h1><p><code>assert</code>与其他编程语言中的功能一致，断言功能，对于当满足某某条件时就失败的逻辑，可直接使用<code>assert</code>模块实现。</p><p>例如上面的例子可改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">assert:</span></span><br><span class="line">        <span class="attr">that:</span></span><br><span class="line">          <span class="bullet">-</span>  <span class="string">inventory_hostname</span> <span class="type">!=</span> <span class="string">&#x27;192.168.100.10&#x27;</span></span><br><span class="line">        <span class="attr">fail_msg:</span> <span class="string">&quot;失败了&quot;</span></span><br><span class="line">        <span class="attr">success_msg:</span> <span class="string">&quot;成功了&quot;</span></span><br></pre></td></tr></table></figure><p>其中<code>that</code>参数接收一个列表，用于定义一个或多个条件，如果条件全为true，则任务成功，只要有一个条件为false，则任务失败。<code>fail_msg</code>(或其别名参数<code>msg</code>)定义任务失败时的信息，<code>success_msg</code>定义任务成功时的信息。</p><h1 id="ignore-errors"><a href="#ignore-errors" class="headerlink" title="ignore_errors"></a>ignore_errors</h1><p>当某个任务执行失败(或被Ansible认为失败，比如通过返回值判断)时，如果不想让这个失败的任务导致节点退出，可以使用<code>ignore_errors</code>指令来忽略失败。</p><p>例如开头的那个例子，加上<code>ignore_errors</code>指令：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">        ls /home/aa</span></span><br><span class="line"><span class="string"></span>      <span class="attr">ignore_errors:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">res.stdout</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [shell] *****************************************************************************************************</span><br><span class="line">fatal: [localhost]: FAILED! =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;ls /home/aa\n&quot;, &quot;delta&quot;: &quot;0:00:00.034821&quot;, &quot;end&quot;: &quot;2021-12-02 14:41:13.638790&quot;, &quot;msg&quot;: &quot;non-zero return code&quot;, &quot;rc&quot;: 2, &quot;start&quot;: &quot;2021-12-02 14:41:13.603969&quot;, &quot;stderr&quot;: &quot;ls: 无法访问/home/aa: 没有那个文件或目录&quot;, &quot;stderr_lines&quot;: [&quot;ls: 无法访问/home/aa: 没有那个文件或目录&quot;], &quot;stdout&quot;: &quot;&quot;, &quot;stdout_lines&quot;: []&#125;</span><br><span class="line">...ignoring</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;res.stdout&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=1</span><br></pre></td></tr></table></figure><p>可以看到，加上<code>ignore_errors</code>后成功执行了debug任务，最后的任务汇总处的ignored=1证明忽略了一个错误。但是从结果中可以看到，虽然确实忽略了错误，但红红报错信息仍然提醒在终端上，让不了解此机制的人感觉很慌。这时可以使用<code>failed_when</code>解决。</p><h1 id="failed-when"><a href="#failed-when" class="headerlink" title="failed_when"></a>failed_when</h1><p><code>failed_when</code>指令可以让用户自己定义任务何时失败：当条件表达式为true时任务强制失败，当条件表达式为false时，任务强制不失败。</p><p>接着改下上面的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">        ls /home/aa</span></span><br><span class="line"><span class="string"></span>      <span class="attr">failed_when:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">res.stdout</span></span><br></pre></td></tr></table></figure><p>此时查看输出，已经没有相关报错了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [shell] *****************************************************************************************************</span><br><span class="line">changed: [localhost]</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;res.stdout&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p><code>failed_when</code>经常会和shell或command模块以及register指令一起使用，用来手动定义失败的退出状态码。比如，退出状态码为<code>0 1 2</code>都认为任务成功执行，其它状态码都认为认为执行失败。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">        ls /home/aa</span></span><br><span class="line"><span class="string"></span>      <span class="attr">failed_when:</span> <span class="string">res.rc</span> <span class="string">not</span> <span class="string">in</span> <span class="string">(0,1,2)</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">res.stdout</span></span><br></pre></td></tr></table></figure><p><code>failed_when</code>和<code>when</code>一样都可以将多个条件表达式写成列表的形式来表示逻辑与。</p><h1 id="rescue和always"><a href="#rescue和always" class="headerlink" title="rescue和always"></a>rescue和always</h1><p>Ansible允许在任务失败的时候，去执行某些任务，还允许不管任务失败与否，都执行某些任务。</p><ol><li>rescue和always都是block级别的指令</li><li>rescue表示block中任意任务失败后，都执行rescue中定义的任务，但如果block中没有任务失败，则不执行rescue中的任务</li><li>always表示block中任务无论失败与否，都执行always中定义的任务</li></ol><p>例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">block:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">fail:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;hello</span> <span class="string">world&quot;</span></span><br><span class="line">      <span class="attr">rescue:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;rescue1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;rescue2&quot;</span></span><br><span class="line">      <span class="attr">always:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;always1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;always2&quot;</span></span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [fail] ******************************************************************************************************</span><br><span class="line">fatal: [localhost]: FAILED! =&gt; &#123;&quot;changed&quot;: false, &quot;msg&quot;: &quot;Failed as requested from task&quot;&#125;</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;rescue1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;rescue2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;always1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;always2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">localhost                  : ok=4    changed=0    unreachable=0    failed=0    skipped=0    rescued=1    ignored=0</span><br></pre></td></tr></table></figure><p>block中的fail任务会失败，于是跳转到rescue中开始执行任务，然后再跳转到always中执行任务。</p><p>如果注释掉block中的fail模块任务，则block中没有任务失败，于是rescue中的任务不会执行，但是在执行完block中所有任务后会跳转到always中继续执行任务。</p><h1 id="处理连接失败-unreachable-的异常"><a href="#处理连接失败-unreachable-的异常" class="headerlink" title="处理连接失败(unreachable)的异常"></a>处理连接失败(unreachable)的异常</h1><p>如果Ansible突然和某个节点无法连接上，会将此节点设置为UNREACHABLE状态，并从活动节点列表(<code>play_hosts</code>)中删除。</p><p>如果想要忽略连接失败的节点，可设置<code>ignore_unreachable: true</code>指令，该指令是Ansible 2.7添加的，可设置在play、Role、block、task级别上。</p><p>当Ansible遇到UNREACHABLE时，会进行连接重试。重试次数可在Ansible配置文件中配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# cat /etc/ansible/ansible.cfg |grep -w retries</span><br><span class="line"><span class="meta">#</span><span class="bash">retries = 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常使用ansible的过程中会发现，执行shell或command模块时，Ansible只认为0退出状态码是正确的，其它所有退出状态码都是失败的，但我们自己知道非0退出状态码并非一定代表着失败。&lt;/p&gt;
&lt;p&gt;比如下例：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（九）ansible流程控制</title>
    <link href="https://slions.github.io/2021/12/01/%EF%BC%88%E4%B9%9D%EF%BC%89ansible%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://slions.github.io/2021/12/01/%EF%BC%88%E4%B9%9D%EF%BC%89ansible%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2021-12-01T12:27:28.000Z</published>
    <updated>2021-12-02T07:44:56.420Z</updated>
    
    <content type="html"><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>ansible提供的条件判断只有when指令，因为可以写Jinja2条件判断表达式，所以判断方式比较灵活。</p><h2 id="同时满足多个条件"><a href="#同时满足多个条件" class="headerlink" title="同时满足多个条件"></a>同时满足多个条件</h2><p>常见的编程语言在多条件判断时要么使用逻辑与（<code>and</code>或<code>&amp;&amp;</code>）,要么使用逻辑或（<code>or</code>或<code>||</code>）。ansible同样支持这种写法。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">when:</span> <span class="string">age</span> <span class="string">&gt;</span> <span class="number">18</span> <span class="string">and</span> <span class="string">age</span> <span class="string">&lt;</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>也可以将这些条件以列表的方式提供。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">item</span></span><br><span class="line">      <span class="attr">when:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">item</span> <span class="string">&gt;</span> <span class="number">3</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">item</span> <span class="string">&lt;</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">loop:</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><h2 id="按条件导入文件"><a href="#按条件导入文件" class="headerlink" title="按条件导入文件"></a>按条件导入文件</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">include_tasks:</span> <span class="string">RedHat.yml</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_os_family</span> <span class="string">==</span> <span class="string">&quot;RedHat&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">include_tasks:</span> <span class="string">Centos.yml</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_os_family</span> <span class="string">==</span> <span class="string">&quot;Centos&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更加精炼的写法可以参考</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">include_tasks:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;ansible_os_family&#125;&#125;</span>.yml&quot;</span></span><br></pre></td></tr></table></figure><h2 id="when和循环"><a href="#when和循环" class="headerlink" title="when和循环"></a>when和循环</h2><p>当when指令和循环指令一起使用时，when的判断操作在每轮循环内执行。详细内容下文中描述。</p><h1 id="循环迭代"><a href="#循环迭代" class="headerlink" title="循环迭代"></a>循环迭代</h1><blockquote><p>ansible 2.5之前的循环迭代都使用<code>with_xxx</code>来完成，比如<code>with_items</code>,后面加入了<code>loop</code>指令，<code>loop</code>指令与<code>with_list</code>指令等价。</p><p><code>with_xxx</code>语法都使用对应的lookup插件来实现（比如<code>with_list</code>使用的是lookup的list插件），如果存在某lookup插件xxx，就可以使用<code>with_xxx</code>来迭代。</p></blockquote><h2 id="with-list"><a href="#with-list" class="headerlink" title="with_list"></a>with_list</h2><p>直接上例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">touch</span></span><br><span class="line">      <span class="attr">with_list:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">aaa</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">bbb</span></span><br></pre></td></tr></table></figure><p>与上面<code>with_list</code>等价的loop语法：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">touch</span></span><br><span class="line">  <span class="attr">loop:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">aaa</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bbb</span></span><br></pre></td></tr></table></figure><h2 id="with-items和with-flattened"><a href="#with-items和with-flattened" class="headerlink" title="with_items和with_flattened"></a>with_items和with_flattened</h2><p>with_list用于迭代简单列表，有时候列表中会嵌套列表。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">name:</span> [<span class="string">a</span>,[<span class="string">b1</span>,<span class="string">b2</span>],<span class="string">c</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_items:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;name&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>注意，<code>with_items</code>只压平嵌套列表的第一层，不会递归压平第二层、第三层…</p><p>与with_items等价的loop指令的写法为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nested_list | flatten(levels=1) &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>筛选器函数flatten()默认会递归压平所有嵌套列表，如果只是压平第一层，需指定参数levels=1。</p><p>此外，还存在lookup插件：items、flattened，前者只压第一层，后者递归压平所有嵌套层次。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">name:</span> [<span class="string">a</span>,[<span class="string">b1</span>,<span class="string">b2</span>],<span class="string">c</span>,[<span class="string">d1</span>,<span class="string">d2</span>,[<span class="string">e1</span>,<span class="string">e2</span>,<span class="string">e3</span>]]]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_flattened:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;name&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="with-dict"><a href="#with-dict" class="headerlink" title="with_dict"></a>with_dict</h2><p><code>with_dict</code>用于迭代一个字典结构，迭代时可以使用<code>item.key</code>表示每个字典元素的key，<code>item.value</code>表示每个字典元素的value。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">users:</span></span><br><span class="line">      <span class="attr">slions:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">slions</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">29</span></span><br><span class="line">      <span class="attr">zhangsan:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;who: <span class="template-variable">&#123;&#123;item.key&#125;&#125;</span></span></span><br><span class="line"><span class="string">              name: <span class="template-variable">&#123;&#123;item.value.name&#125;&#125;</span></span></span><br><span class="line"><span class="string">              age: <span class="template-variable">&#123;&#123;item.value.age&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_dict:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;users&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>与<code>with_dict</code>等价的loop指令有两种写法：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;lookup(&#x27;dict&#x27;, users)&#125;&#125;</span>&quot;</span></span><br><span class="line"><span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;users | dict2items&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>另外，在Ansible 2.8中可以自定义<code>dict2items</code>筛选器函数得到的key和value的名称。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">users:</span></span><br><span class="line">      <span class="attr">slions:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">slions</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">29</span></span><br><span class="line">      <span class="attr">zhangsan:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;who: <span class="template-variable">&#123;&#123;item.k&#125;&#125;</span></span></span><br><span class="line"><span class="string">              name: <span class="template-variable">&#123;&#123;item.v.name&#125;&#125;</span></span></span><br><span class="line"><span class="string">              age: <span class="template-variable">&#123;&#123;item.v.age&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;users|dict2items(key_name=&#x27;k&#x27;,value_name=&#x27;v&#x27;)&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="with-sequence"><a href="#with-sequence" class="headerlink" title="with_sequence"></a>with_sequence</h2><p>Ansible的lookup插件sequence也可以用来生成连续数(Jinja2的range也可以生成连续数)。其中：</p><ul><li>start参数指定序列的起始数，不指定该参数时默认从1开始</li><li>end参数指定序列的终止数</li><li>stride参数指定序列的步进值。不指定该参数时，步进为1</li><li>format参数指定序列的输出格式，遵循printf风格</li><li>count参数指定生成序列数的个数，不能和end参数共存</li></ul><p>此外，sequence插件的各个参数可以简写为如下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[start-]end[/stride][:format]</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;_<span class="template-variable">&#123;&#123;item&#125;&#125;</span>_&quot;</span></span><br><span class="line">      <span class="attr">with_sequence:</span> <span class="string">start=0</span> <span class="string">end=5</span> <span class="string">stride=2</span> <span class="string">format=a%02d</span></span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *********************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [debug] *************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; (item=a00) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;_a00_&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [localhost] =&gt; (item=a02) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;_a02_&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [localhost] =&gt; (item=a04) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;_a04_&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP ***************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p>也可简写为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">with_sequence:</span> <span class="number">0</span><span class="number">-5</span><span class="string">/2:a%02d</span></span><br></pre></td></tr></table></figure><p>因为生成的每个序列数都会经过字符串格式化，所以得到的每个序列元素都是字符串。如果想要转换成数值，需使用Jinja2的Filter。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;1 + item|int&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_sequence:</span> <span class="string">start=0</span> <span class="string">end=3</span></span><br></pre></td></tr></table></figure><p>与with_sequence等价的loop写法为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; &#x27;a%02d&#x27; | format(item) &#125;&#125;</span>&quot;</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; range(0, 5, 2)|list &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>Jinja2的range()也可以生成序列数。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(start,end,step)</span><br></pre></td></tr></table></figure><p>注意range()不包含结尾数end。</p><h2 id="with-fileglob"><a href="#with-fileglob" class="headerlink" title="with_fileglob"></a>with_fileglob</h2><p><code>with_fileglob</code>用于迭代通配到的每个文件名。</p><p>例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">copy:</span> </span><br><span class="line">        <span class="attr">src:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span> </span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/</span></span><br><span class="line">      <span class="attr">with_fileglob:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/m*.conf</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/*.cnf</span></span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *********************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [copy] **************************************************************************************************</span><br><span class="line">changed: [localhost] =&gt; (item=/etc/man_db.conf)</span><br><span class="line">changed: [localhost] =&gt; (item=/etc/mke2fs.conf)</span><br><span class="line">changed: [localhost] =&gt; (item=/etc/my.cnf)</span><br><span class="line"></span><br><span class="line">PLAY RECAP ***************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><h2 id="with-lines"><a href="#with-lines" class="headerlink" title="with_lines"></a>with_lines</h2><p><code>with_lines</code>用于迭代命令输出结果的每一行。</p><p>这功能也是非常实用的，如下示例：find找出一堆文件，然后进行操作(比如copy)。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">copy:</span> </span><br><span class="line">        <span class="attr">src:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span> </span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/home/myscript/</span></span><br><span class="line">      <span class="attr">with_lines:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">find</span> <span class="string">~</span> <span class="string">-maxdepth</span> <span class="number">1</span> <span class="string">-type</span> <span class="string">f</span> <span class="string">-name</span> <span class="string">&quot;*.sh&quot;</span></span><br></pre></td></tr></table></figure><h2 id="循环和when"><a href="#循环和when" class="headerlink" title="循环和when"></a>循环和when</h2><p>当<code>with_xxx</code>或<code>loop</code>指令和<code>when</code>指令一起使用时，<code>when</code>将在循环的内部进行条件判断。也就是说，when决定每轮迭代时是否执行一个任务，而不是决定整个循环是否进行。</p><h2 id="循环和register"><a href="#循环和register" class="headerlink" title="循环和register"></a>循环和register</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">item</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">res</span></span><br></pre></td></tr></table></figure><p>其中第二个debug任务的执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">  &quot;res&quot;: &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;msg&quot;: &quot;All items completed&quot;,</span><br><span class="line">    &quot;results&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: false,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;item&quot;: 11</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: false,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;item&quot;: 22</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个shell模块的示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> &#123;&#123;<span class="string">item</span>&#125;&#125;</span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">res</span></span><br></pre></td></tr></table></figure><p>其中第二个任务的执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">  &quot;res&quot;: &#123;</span><br><span class="line">    &quot;changed&quot;: true,</span><br><span class="line">    &quot;msg&quot;: &quot;All items completed&quot;,</span><br><span class="line">    &quot;results&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: true,</span><br><span class="line">        &quot;cmd&quot;: &quot;echo 11&quot;,</span><br><span class="line">        &quot;delta&quot;: &quot;0:00:00.001643&quot;,</span><br><span class="line">        &quot;end&quot;: &quot;2021-12-02 11:40:05.012729&quot;,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;invocation&quot;: &#123;</span><br><span class="line">          &quot;module_args&quot;: &#123;</span><br><span class="line">            ......</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;item&quot;: 11,</span><br><span class="line">        &quot;rc&quot;: 0,</span><br><span class="line">        &quot;start&quot;: &quot;2021-12-02 11:40:05.011086&quot;,</span><br><span class="line">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class="line">        &quot;stderr_lines&quot;: [],</span><br><span class="line">        &quot;stdout&quot;: &quot;11&quot;,</span><br><span class="line">        &quot;stdout_lines&quot;: [</span><br><span class="line">          &quot;11&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        ......</span><br><span class="line">        &quot;stdout&quot;: &quot;22&quot;,</span><br><span class="line">        &quot;stdout_lines&quot;: [</span><br><span class="line">          &quot;22&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见，当register和循环指令结合时，会将每轮迭代的模块执行结果以一个字典的方式追加在一个名为results的列表中。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;res&quot;: &#123;</span><br><span class="line">  &quot;changed&quot;: true,</span><br><span class="line">  &quot;msg&quot;: &quot;All items completed&quot;,</span><br><span class="line">  &quot;results&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...第一轮迭代模块返回值...</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      ...第二轮迭代模块返回值...</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，可使用<code>res.results</code>来访问每轮的迭代结果。例如，再次迭代遍历这些结果：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> &#123;&#123;<span class="string">item</span>&#125;&#125;</span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">item.stdout</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;res.results&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p>循环控制功能需要在使用循环的时候使用<code>loop_control</code>指令，该指令有一些参数，每种参数都是一个控制开关。</p><h3 id="label参数"><a href="#label参数" class="headerlink" title="label参数"></a>label参数</h3><p>循环迭代时，每轮迭代过程中都会将当前的item输出(要么输出到屏幕，要么输出到日志)。如果所迭代的每项的内容(即每个item)很短，这倒无所谓，但如果item的内容很长，则可读性比较差。</p><p>示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> &#123;&#123;<span class="string">item</span>&#125;&#125;</span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">item.stdout</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;res.results&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; (item=&#123;u&#x27;stderr_lines&#x27;: [], u&#x27;ansible_loop_var&#x27;: u&#x27;item&#x27;, u&#x27;end&#x27;: u&#x27;2021-12-02 11:57:33.161219&#x27;, u&#x27;stderr&#x27;: u&#x27;&#x27;, u&#x27;stdout&#x27;: u&#x27;11&#x27;, u&#x27;changed&#x27;: True, u&#x27;failed&#x27;: False, u&#x27;delta&#x27;: u&#x27;0:00:00.040706&#x27;, u&#x27;cmd&#x27;: u&#x27;echo 11&#x27;, u&#x27;item&#x27;: 11, u&#x27;rc&#x27;: 0, u&#x27;invocation&#x27;: &#123;u&#x27;module_args&#x27;: &#123;u&#x27;warn&#x27;: False, u&#x27;executable&#x27;: None, u&#x27;_uses_shell&#x27;: True, u&#x27;strip_empty_ends&#x27;: True, u&#x27;_raw_params&#x27;: u&#x27;echo 11&#x27;, u&#x27;removes&#x27;: None, u&#x27;argv&#x27;: None, u&#x27;creates&#x27;: None, u&#x27;chdir&#x27;: None, u&#x27;stdin_add_newline&#x27;: True, u&#x27;stdin&#x27;: None&#125;&#125;, u&#x27;stdout_lines&#x27;: [u&#x27;11&#x27;], u&#x27;start&#x27;: u&#x27;2021-12-02 11:57:33.120513&#x27;&#125;) =&gt; &#123;</span><br><span class="line">    &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">    &quot;item&quot;: &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: true,</span><br><span class="line">        &quot;cmd&quot;: &quot;echo 11&quot;,</span><br><span class="line">        &quot;delta&quot;: &quot;0:00:00.040706&quot;,</span><br><span class="line">        &quot;end&quot;: &quot;2021-12-02 11:57:33.161219&quot;,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;invocation&quot;: &#123;</span><br><span class="line">            &quot;module_args&quot;: &#123;</span><br><span class="line">                &quot;_raw_params&quot;: &quot;echo 11&quot;,</span><br><span class="line">                &quot;_uses_shell&quot;: true,</span><br><span class="line">                &quot;argv&quot;: null,</span><br><span class="line">                &quot;chdir&quot;: null,</span><br><span class="line">                &quot;creates&quot;: null,</span><br><span class="line">                &quot;executable&quot;: null,</span><br><span class="line">                &quot;removes&quot;: null,</span><br><span class="line">                &quot;stdin&quot;: null,</span><br><span class="line">                &quot;stdin_add_newline&quot;: true,</span><br><span class="line">                &quot;strip_empty_ends&quot;: true,</span><br><span class="line">                &quot;warn&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;item&quot;: 11,</span><br><span class="line">        &quot;rc&quot;: 0,</span><br><span class="line">        &quot;start&quot;: &quot;2021-12-02 11:57:33.120513&quot;,</span><br><span class="line">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class="line">        &quot;stderr_lines&quot;: [],</span><br><span class="line">        &quot;stdout&quot;: &quot;11&quot;,</span><br><span class="line">        &quot;stdout_lines&quot;: [</span><br><span class="line">            &quot;11&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;item.stdout&quot;: &quot;11&quot;</span><br></pre></td></tr></table></figure><p>使用label参数可以自定义迭代时显示的内容来替代默认显示的item。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> &#123;&#123;<span class="string">item</span>&#125;&#125;</span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">item.stdout</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;res.results&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop_control:</span></span><br><span class="line">        <span class="attr">label:</span> <span class="string">&quot;this is test play&quot;</span></span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; (item=this is test play) =&gt; &#123;</span><br><span class="line">    &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">    &quot;item&quot;: &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: true,</span><br><span class="line">        &quot;cmd&quot;: &quot;echo 11&quot;,</span><br><span class="line">        &quot;delta&quot;: &quot;0:00:00.034184&quot;,</span><br><span class="line">        &quot;end&quot;: &quot;2021-12-02 12:21:47.385021&quot;,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;invocation&quot;: &#123;</span><br><span class="line">            &quot;module_args&quot;: &#123;</span><br><span class="line">                &quot;_raw_params&quot;: &quot;echo 11&quot;,</span><br><span class="line">                &quot;_uses_shell&quot;: true,</span><br><span class="line">                &quot;argv&quot;: null,</span><br><span class="line">                &quot;chdir&quot;: null,</span><br><span class="line">                &quot;creates&quot;: null,</span><br><span class="line">                &quot;executable&quot;: null,</span><br><span class="line">                &quot;removes&quot;: null,</span><br><span class="line">                &quot;stdin&quot;: null,</span><br><span class="line">                &quot;stdin_add_newline&quot;: true,</span><br><span class="line">                &quot;strip_empty_ends&quot;: true,</span><br><span class="line">                &quot;warn&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;item&quot;: 11,</span><br><span class="line">        &quot;rc&quot;: 0,</span><br><span class="line">        &quot;start&quot;: &quot;2021-12-02 12:21:47.350837&quot;,</span><br><span class="line">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class="line">        &quot;stderr_lines&quot;: [],</span><br><span class="line">        &quot;stdout&quot;: &quot;11&quot;,</span><br><span class="line">        &quot;stdout_lines&quot;: [</span><br><span class="line">            &quot;11&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;item.stdout&quot;: &quot;11&quot;</span><br></pre></td></tr></table></figure><h3 id="pause参数"><a href="#pause参数" class="headerlink" title="pause参数"></a>pause参数</h3><p><code>loop_control</code>的<code>pause</code>参数可以控制每轮迭代之间的时间间隔。</p><p>以下示例表示第一轮迭代后，等待一秒，再进入第二轮迭代。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">item</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;mylist&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop_control:</span></span><br><span class="line">        <span class="attr">pause:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="index-var参数"><a href="#index-var参数" class="headerlink" title="index_var参数"></a>index_var参数</h3><p><code>index_var</code>参数可以指定一个变量，这个变量可以记录每轮循环迭代过程中的索引位，也即表示当前是第几轮迭代。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;index: <span class="template-variable">&#123;&#123;idx&#125;&#125;</span>, value: <span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;mylist&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop_control:</span></span><br><span class="line">        <span class="attr">index_var:</span> <span class="string">idx</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ok: [localhost] =&gt; (item=11) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;index: 0, value: 11&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [localhost] =&gt; (item=22) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;index: 1, value: 22&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>index_var</code>，可以进行一些条件判断。比如只在第一轮循环时执行某任务：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;index: <span class="template-variable">&#123;&#123;idx&#125;&#125;</span>, value: <span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">idx</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;mylist&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop_control:</span></span><br><span class="line">        <span class="attr">index_var:</span> <span class="string">idx</span></span><br></pre></td></tr></table></figure><h1 id="其他流程控制"><a href="#其他流程控制" class="headerlink" title="其他流程控制"></a>其他流程控制</h1><h2 id="pause模块"><a href="#pause模块" class="headerlink" title="pause模块"></a>pause模块</h2><p>Ansible中，可以使用<code>pause</code>模块或<code>wait_for</code>模块来实现睡眠等待的功能，先简单演示pause模块的用法。</p><p>pause可以等待几分钟、几秒钟、等待交互式输入确定。</p><p>例如，先睡眠10秒，再执行debug任务：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">        <span class="attr">seconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>睡眠1分钟：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">pause:</span> </span><br><span class="line">    <span class="attr">minutes:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>交互式输入Enter键确认：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">      <span class="attr">msg:</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>带提醒的交互式输入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">    <span class="attr">prompt:</span> <span class="string">&quot;输入你的用户名!&quot;</span></span><br></pre></td></tr></table></figure><p>隐藏用户的输入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">    <span class="attr">prompt:</span> <span class="string">&quot;输入你的用户名&quot;</span></span><br><span class="line">    <span class="attr">echo:</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure><p>将用户交互式输入内容注册成变量：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">        <span class="attr">prompt:</span> <span class="string">&quot;输入用户密码&quot;</span></span><br><span class="line">        <span class="attr">echo:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">passwd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;passwd.user_input&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="wait-for模块"><a href="#wait-for模块" class="headerlink" title="wait_for模块"></a>wait_for模块</h2><p><code>wait_for</code>模块可以等待多种事件的发生，常用的功能有：</p><ol><li>等待端口打开和端口关闭</li><li>等待没有活动连接(在等待移除某个负载均衡节点时可能会有用)\</li><li>等待文件被创建或移除</li><li>等待或睡眠指定秒数</li><li>等待系统重启(即等待SSH连接重新建立)</li><li>等待文件中出现某个字符串</li><li>等待进程退出</li></ol><p>常见用法：</p><p>睡眠几秒后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠五秒，然后任务继续</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>等待文件存在后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/a.log</span></span><br><span class="line">    <span class="attr">deley:</span> <span class="number">3</span>     <span class="comment"># 3秒后才开始进入第一轮事件等待检查(默认值为0)</span></span><br><span class="line">    <span class="attr">sleep:</span> <span class="number">1</span>     <span class="comment"># 每隔1秒进行一次事件等待检查(默认值为1)</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">20</span>  <span class="comment"># 最多等待20秒(默认值为300)，如果20秒内未等待到事件发生，则wait_for任务失败并报错</span></span><br></pre></td></tr></table></figure><p>等待文件不存在后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/a.log</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">absent</span></span><br></pre></td></tr></table></figure><p>等待进程不存在后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pids:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;sleep&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">sleep_pids</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/proc/<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">absent</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;sleep_pids.pids&#125;&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure><p>pids模块可以根据进程名获取进程PID列表(可能是空列表、单元素列表、多元素列表)。</p><blockquote><p>注意该模块要求先安装python的psutil模块，所以如果要使用pids，可执行：</p><p>$ yum install python3-devel<br>$ pip3 install psutil</p></blockquote><p>等待文件中出现某字符串后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/a.log</span></span><br><span class="line">    <span class="attr">search_regex:</span> <span class="string">completed|finished</span></span><br></pre></td></tr></table></figure><p>等待某端口打开，然后任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; item &#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">    <span class="attr">delay:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">loop:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">10251</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">10252</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2379</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6443</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。&lt;/p&gt;
&lt;h1 id=&quot;条件判断&quot;&gt;&lt;a href=&quot;#条件判断&quot; class=&quot;headerlink&quot; title=&quot;条件判断&quot;&gt;&lt;/a&gt;条件判断&lt;/h1&gt;&lt;p&gt;ansible提</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（八）ansible变量</title>
    <link href="https://slions.github.io/2021/12/01/%EF%BC%88%E5%85%AB%EF%BC%89ansible%E5%8F%98%E9%87%8F/"/>
    <id>https://slions.github.io/2021/12/01/%EF%BC%88%E5%85%AB%EF%BC%89ansible%E5%8F%98%E9%87%8F/</id>
    <published>2021-12-01T10:29:33.000Z</published>
    <updated>2021-12-01T10:39:50.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表、字典变量"><a href="#列表、字典变量" class="headerlink" title="列表、字典变量"></a>列表、字典变量</h1><p>列表和字典是ansible中常见的变量类型。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">human:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">slions</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">29</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp/a.txt</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp/b.txt</span></span><br></pre></td></tr></table></figure><p>对于这类变量的访问，ansible中提供了两种方式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;name: <span class="template-variable">&#123;&#123;human.name&#125;&#125;</span>, age: <span class="template-variable">&#123;&#123;file[0]&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h1 id="extra-vars定义额外变量"><a href="#extra-vars定义额外变量" class="headerlink" title="extra-vars定义额外变量"></a>extra-vars定义额外变量</h1><p>ansible-playbook命令的<code>-e</code>选项或<code>--extra-vars</code>选项可定义变量或引入变量文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义单个变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ansible-playbook -e <span class="string">&#x27;var1=&quot;value1&quot;&#x27;</span> xxx.yml</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义多个变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ansible-playbook -e <span class="string">&#x27;var1=&quot;value1&quot; var2=&quot;value2&quot;&#x27;</span> xxx.yml</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 引入单个变量文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ansible-playbook -e <span class="string">&#x27;@varfile1.yml&#x27;</span> xxx.yml</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 引入多个变量文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ansible-playbook -e <span class="string">&#x27;@varfile1.yml&#x27;</span> -e <span class="string">&#x27;@varfile2.yml&#x27;</span> xxx.yml</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为是通过选项的方式来定义变量的，所以它所定义的变量是全局的，对所有play都有效。</p><h1 id="inventory变量"><a href="#inventory变量" class="headerlink" title="inventory变量"></a>inventory变量</h1><p>在解析inventory时，会收集inventory相关的变量。</p><p>inventory变量主要分为两种：</p><ol><li>连接目标节点时的行为控制变量，即决定如何连接目标节点</li><li>主机变量</li></ol><p>行为控制变量(如ansible_port、ansible_host等)用于指定Ansible端连接目标节点时的连接参数，可设置的参数项比较多，可参见<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#connecting-to-hosts-behavioral-inventory-parameters">官方手册</a></p><p>inventory的主机变量有多种定义途径，例如直接在inventory文件中为某个主机定义变量，也可以在主机组中定义变量，主机组变量会在解析inventory的时候整理到主机变量中去。此外还可以将变量定义在host_vars/和group_vars/目录内，可参考<a href="/2021/08/24/%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%BB%E6%9C%BA%E6%B8%85%E5%8D%95inventory/" title="前文">前文</a>。</p><h1 id="role变量"><a href="#role变量" class="headerlink" title="role变量"></a>role变量</h1><p>Role中主要有两个地方定义变量：</p><ol><li><code>roles/ROLE_NAME/defaults/main.yml</code></li><li><code>roles/ROLE_NAME/vars/main.yml</code></li></ol><blockquote><p>Role defaults变量的优先级非常低，几乎可以被其它任何同名变量覆盖。</p></blockquote><p>Role变量都是play级别的变量。换句话说，如果play中执行了Role之后还有tasks指令的任务，则tasks的任务中可以引用Role中的变量。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">roles:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">test_role</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">var_from_role</span></span><br></pre></td></tr></table></figure><h1 id="play变量"><a href="#play变量" class="headerlink" title="play变量"></a>play变量</h1><p>play级别可以通过<code>vars</code>、<code>vars_files</code>、<code>vars_prompt</code>指令来定义变量。因为它们属于play级别，所以只在当前play有效。另一方面，每个play都有选中的目标节点，所有选中的目标节点都能访问这些play变量。</p><h2 id="vars"><a href="#vars" class="headerlink" title="vars"></a>vars</h2><p><code>vars</code>比较简单不多说了。</p><h2 id="vars-files"><a href="#vars-files" class="headerlink" title="vars_files"></a>vars_files</h2><p><code>vars_files</code>是一个play级别的指令，可用于在解析playbook的阶段引入一个或多个保存了变量的外部文件。</p><p>例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">play1</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars_files:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">varfile1.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">varfile2.yml</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;var in varfile1: <span class="template-variable">&#123;&#123;var1&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;var in varfile2: <span class="template-variable">&#123;&#123;var2&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>playbook文件通过<code>vars_files</code>引入了两个变量文件，变量文件的写法要求遵守YAML或JSON格式。下面是这两个文件的内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面是varfile1.yml文件的内容</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">var1:</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="attr">var11:</span> <span class="string">&quot;value11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是varfile2.yml文件的内容</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">var2:</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="attr">var22:</span> <span class="string">&quot;value22&quot;</span></span><br></pre></td></tr></table></figure><p>需要说明的是，vars_files指令是play级别的指令，且是在解析playbook的时候加载并解析的，所以所引入变量的变量是play范围内可用的，其它play不可使用这些变量。</p><h2 id="vars-prompt"><a href="#vars-prompt" class="headerlink" title="vars_prompt"></a>vars_prompt</h2><p><code>vars_prompt</code>指令用于交互式提示用户输入数据，并将输入内容赋值给指定的变量。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars_prompt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">username</span></span><br><span class="line">      <span class="attr">prompt:</span> <span class="string">&quot;请输入你的用户名&quot;</span></span><br><span class="line">      <span class="attr">private:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">default:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">passwd</span></span><br><span class="line">      <span class="attr">prompt:</span> <span class="string">&quot;请输入你的登录密码&quot;</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">验证用户输入</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;用户名: <span class="template-variable">&#123;&#123;username&#125;&#125;</span>,密码: <span class="template-variable">&#123;&#123;passwd&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>上面定义了两个变量<code>username</code>和<code>passwd</code>，都会提示用户输入对应的值。<code>private: no</code>表示不要隐藏用户输入的字符(默认会隐藏)，<code>default</code>表示指定变量的默认值。</p><h1 id="task变量"><a href="#task变量" class="headerlink" title="task变量"></a>task变量</h1><p>task变量有多种定义方式：</p><ol><li>register指令</li><li>set_fact指令</li><li>vars指令</li><li>include_vars指令</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="comment"># var.yml变量文件中定义了变量a</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">include_vars:</span> </span><br><span class="line">        <span class="attr">file:</span> <span class="string">var.yml</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> <span class="string">junmajinlong</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">set_fact:</span> <span class="string">name=&quot;&#123;&#123;res.stdout&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;a: <span class="template-variable">&#123;&#123;a&#125;&#125;</span>, name: <span class="template-variable">&#123;&#123;name&#125;&#125;</span>, age: <span class="template-variable">&#123;&#123;age&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">vars:</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">        <span class="attr">gender:</span> <span class="string">male</span></span><br></pre></td></tr></table></figure><p>其中<code>include_vars</code>指令除了指明文件位置，还可从目录中导入多个文件，默认会递归到子目录中。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Include</span> <span class="string">all</span> <span class="string">files</span> <span class="string">in</span> <span class="string">vars/all</span></span><br><span class="line">  <span class="attr">include_vars:</span></span><br><span class="line">    <span class="attr">dir:</span> <span class="string">vars/all</span></span><br></pre></td></tr></table></figure><h1 id="block变量"><a href="#block变量" class="headerlink" title="block变量"></a>block变量</h1><p>ansible中使用block指令来组织了两个有关联性的任务，将它们作为了一个整体。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sync</span> <span class="string">time</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">new</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">and</span> <span class="string">sync</span> <span class="string">time</span></span><br><span class="line">      <span class="attr">block:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">ntpdate</span></span><br><span class="line">          <span class="attr">yum:</span> </span><br><span class="line">            <span class="attr">name:</span> <span class="string">ntpdate</span></span><br><span class="line">            <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ntpdate</span> <span class="string">to</span> <span class="string">sync</span> <span class="string">time</span></span><br><span class="line">          <span class="attr">shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            ntpdate ntp1.aliyun.com</span></span><br><span class="line"><span class="string">            hwclock -w</span></span><br></pre></td></tr></table></figure><p>block作为一个特殊的层次级别，它也支持定义变量，只不过这个block层次的变量只对当前block内的所有任务有效。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">block:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">           <span class="attr">var:</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">vars:</span> </span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;slions&quot;</span></span><br></pre></td></tr></table></figure><h1 id="facts变量"><a href="#facts变量" class="headerlink" title="facts变量"></a>facts变量</h1><p>Facts信息也算是变量，可参考<a href="/2021/12/01/%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%B6%E9%9B%86%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AFfacts/" title="前文">前文</a></p><h1 id="预定义特殊变量"><a href="#预定义特殊变量" class="headerlink" title="预定义特殊变量"></a>预定义特殊变量</h1><p>ansible自身维护了一些可以暴露给用户的预定义变量，官方称为魔法变量，下面是常见预定义变量的含义，完整的预定义特殊变量说明参考<a href="https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html#special-variables">官方手册</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- ansible_forks</span><br><span class="line">表示最大的进程数。这也暗含了多少个节点作为一批。(如果忘记了一批是什么意思，可回介绍playbook的那一章末尾复习)</span><br><span class="line"></span><br><span class="line">- hostvars</span><br><span class="line">保存了inventory中所有主机和主机变量</span><br><span class="line"></span><br><span class="line">- inventory_hostname</span><br><span class="line">当前执行任务的节点在inventory中的主机名</span><br><span class="line"></span><br><span class="line">- inventory_hostname_short</span><br><span class="line">当前执行任务的节点在inventory中的短主机名</span><br><span class="line"></span><br><span class="line">- inventory_dir</span><br><span class="line">inventory文件所在的目录</span><br><span class="line"></span><br><span class="line">- inventory_file</span><br><span class="line">inventory文件名</span><br><span class="line"></span><br><span class="line">- group_names</span><br><span class="line">当前正在执行任务的节点所在主机组列表，注意是一个列表，因为一个节点可能存在于多个主机组</span><br><span class="line"></span><br><span class="line">- groups</span><br><span class="line">inventory中所有的主机组以及各组内的主机列表</span><br><span class="line"></span><br><span class="line">- ansible_play_batch</span><br><span class="line">当前play中可执行任务的主机列表。Ansible动态维护该变量，默认情况下执行任务失败或连接失败的节点会从此变量中移除</span><br><span class="line"></span><br><span class="line">- ansible_play_hosts</span><br><span class="line">等价于ansible_play_batch</span><br><span class="line"></span><br><span class="line">- play_hosts</span><br><span class="line">已废弃，等价于ansible_play_batch</span><br><span class="line"></span><br><span class="line">- playbook_dir</span><br><span class="line">playbook所在目录，该playbook是ansible-playbook命令所执行的playbook，而不是import_playbook导入的playbook</span><br><span class="line"></span><br><span class="line">- ansible_play_name</span><br><span class="line">当前正在执行的play的name。Ansible 2.8才添加的变量</span><br><span class="line"></span><br><span class="line">- ansible_play_hosts_all</span><br><span class="line">当前play所选中的所有节点，等价于ansible_play_batch + 失败的节点</span><br><span class="line"></span><br><span class="line">- ansible_play_role_names</span><br><span class="line">当前play中包含的Role列表。注意，因依赖关系而隐式导入的Role不在列表内</span><br><span class="line"></span><br><span class="line">- role_names</span><br><span class="line">已废弃，等价于ansible_play_role_names</span><br><span class="line"></span><br><span class="line">- ansible_role_names</span><br><span class="line">当前play中包含的Role列表，包括因依赖关系而隐式导入的Role</span><br><span class="line"></span><br><span class="line">- role_name</span><br><span class="line">当前正在执行的Role的名称</span><br><span class="line"></span><br><span class="line">- role_path</span><br><span class="line">当前正在执行的Role的路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;列表、字典变量&quot;&gt;&lt;a href=&quot;#列表、字典变量&quot; class=&quot;headerlink&quot; title=&quot;列表、字典变量&quot;&gt;&lt;/a&gt;列表、字典变量&lt;/h1&gt;&lt;p&gt;列表和字典是ansible中常见的变量类型。&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（七）收集节点信息facts</title>
    <link href="https://slions.github.io/2021/12/01/%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%B6%E9%9B%86%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AFfacts/"/>
    <id>https://slions.github.io/2021/12/01/%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%B6%E9%9B%86%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AFfacts/</id>
    <published>2021-12-01T08:00:50.000Z</published>
    <updated>2021-12-01T08:01:19.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收集节点信息"><a href="#收集节点信息" class="headerlink" title="收集节点信息"></a>收集节点信息</h1><p>ansible可以获取目标主机的节点信息，如ip地址，主机名、系统版本、内核版本等等，对于运维来说是一个很好的功能，但是正是它收集的信息很全面，运行也很慢，在日常工作中，没有特殊的需求会在playbook中将其关闭，或者开启facts缓存，在运行任务前手动执行一次。</p><p>ansible中提供了两个模块（<code>setup</code>与<code>gather_facts</code>）来实现收集主机facts，其中setup是最早的模块，gather_facts是基于setup二次开发的模块（2.8版本以上），gather_facts相比setup多了个并行收集facts的功能（自动识别）。</p><p>在playbook中可以通过<code>gather_facts: BOOL</code>,来控制是否收集节点facts,默认是true，在开始执行定义好的任务前会先执行gather_facts.</p><h1 id="访问节点信息"><a href="#访问节点信息" class="headerlink" title="访问节点信息"></a>访问节点信息</h1><p>收集到目标节点信息之后，各信息都保存在一个名为ansible_facts的变量中，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;ansible_facts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ansible_all_ipv4_addresses&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;192.168.100.10&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ansible_all_ipv6_addresses&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;fe80::8199:4454:db1e:911c&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ansible_apparmor&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;disabled&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ansible_architecture&quot;</span>: <span class="string">&quot;x86_64&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_bios_date&quot;</span>: <span class="string">&quot;07/22/2020&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_bios_version&quot;</span>: <span class="string">&quot;6.00&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_cmdline&quot;</span>: &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ansible_date_time&quot;</span>: &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ansible_default_ipv4&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;192.168.100.10&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;ens33&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;broadcast&quot;</span>: <span class="string">&quot;192.168.100.255&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;gateway&quot;</span>: <span class="string">&quot;192.168.100.2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;interface&quot;</span>: <span class="string">&quot;ens33&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;macaddress&quot;</span>: <span class="string">&quot;00:0c:29:ec:61:46&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mtu&quot;</span>: <span class="number">1500</span>,</span><br><span class="line">        <span class="attr">&quot;netmask&quot;</span>: <span class="string">&quot;255.255.255.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;network&quot;</span>: <span class="string">&quot;192.168.100.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ether&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution&quot;</span>: <span class="string">&quot;CentOS&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_file_parsed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_file_path&quot;</span>: <span class="string">&quot;/etc/redhat-release&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_file_variety&quot;</span>: <span class="string">&quot;RedHat&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_major_version&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_release&quot;</span>: <span class="string">&quot;Core&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_version&quot;</span>: <span class="string">&quot;7.6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_dns&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;nameservers&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;114.114.114.114&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>有了这些信息，就可以去访问这些信息。比较常用有获取目标主机名，系统版本号、ip地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">var:</span> <span class="string">ansible_hostname</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">var:</span> <span class="string">ansible_distribution_version</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">var:</span> <span class="string">ansible_all_ipv4_addresses</span></span><br></pre></td></tr></table></figure><p>获取到所需的信息可以添加一些判断的逻辑：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">template</span> <span class="string">and</span> <span class="string">copy</span> <span class="string">centos6</span> <span class="string">yum</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">centos6.repo.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/centos6.repo</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_distribution</span> <span class="string">==</span> <span class="string">&quot;CentOS&quot;</span> <span class="string">and</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">template</span> <span class="string">and</span> <span class="string">copy</span> <span class="string">centos7</span> <span class="string">yum</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">centos7.repo.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/centos7.repo</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_distribution</span> <span class="string">==</span> <span class="string">&quot;CentOS&quot;</span> <span class="string">and</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 更精简的写法：</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">template</span> <span class="string">and</span> <span class="string">copy</span> <span class="string">yum</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;&#x27;centos6.repo.j2&#x27; if (ansible_distribution_major_version == 6) else &#x27;centos7.repo.j2&#x27;&#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/centos.repo</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_distribution</span> <span class="string">==</span> <span class="string">&#x27;CentOS&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="local-fact"><a href="#local-fact" class="headerlink" title="local fact"></a>local fact</h1><p>Ansible除了远程收集目标节点的Facts信息，还允许用户在目标节点上自定义该节点的Facts信息，这种方式收集到的Facts称为local Facts。</p><p>要自定义local Facts，需要在目标节点的/etc/ansible/facts.d/目录下创建以<code>.fact</code>为后缀的文件，并在该文件中定义Facts变量信息。该文件要求是json、ini格式或能够输出json、ini数据格式的可执行文件，比如shell脚本。也可以更改默认的local fact目录，在play关键字中指定就好。</p><p>如下示例：</p><p>在第一台目标节点编写local fact如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 facts.d]# ls</span><br><span class="line">myfact.fact</span><br><span class="line">[root@slions_pc1 facts.d]# cat myfact.fact</span><br><span class="line">[model]</span><br><span class="line">pc=del_G3</span><br><span class="line">[root@slions_pc1 facts.d]# pwd</span><br></pre></td></tr></table></figure><p>在第二台目标节点编写local fact如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 facts.d]# ls</span><br><span class="line">myfact.fact</span><br><span class="line">[root@slions_pc2 facts.d]# pwd</span><br><span class="line">/home/ansible_poc/facts.d</span><br><span class="line">[root@slions_pc2 facts.d]# cat myfact.fact</span><br><span class="line">[model]</span><br><span class="line">pc=macbook x1</span><br></pre></td></tr></table></figure><p>playbook如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">fact_path:</span> <span class="string">/home/ansible_poc/facts.d/</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">      <span class="attr">var:</span> <span class="string">ansible_facts.ansible_local.myfact.model.pc</span></span><br><span class="line">      <span class="comment">#也可省略ansible_facts</span></span><br><span class="line">      <span class="comment">#var: ansible_local.myfact.model.pc</span></span><br></pre></td></tr></table></figure><p>运行后可以看到能正常访问到自定义的本地fact。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PLAY [test] **************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] ***************************************************************************************</span><br><span class="line">ok: [192.168.100.11]</span><br><span class="line">ok: [192.168.100.10]</span><br><span class="line"></span><br><span class="line">TASK [debug] *************************************************************************************************</span><br><span class="line">ok: [192.168.100.10] =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts.ansible_local.myfact.model.pc&quot;: &quot;del_G3&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.168.100.11] =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts.ansible_local.myfact.model.pc&quot;: &quot;macbook x1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP ***************************************************************************************************</span><br><span class="line">192.168.100.10             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.168.100.11             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p>使用Local Facts并不方便，这需要单独去目标节点创建/home/ansible_poc/facts.d/目录，还要将写好的.fact文件拷贝过去，然后在下一个play中使用(如果在当前play中使用，需要先手动调用setup模块收集信息再使用)。</p><p>换句话说，使用Local Facts的一般流程可能是这样的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">play1</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">block:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mkdir</span> <span class="string">/home/ansible_poc/facts.d</span></span><br><span class="line">          <span class="attr">file:</span> </span><br><span class="line">            <span class="attr">name:</span> <span class="string">/home/ansible_poc/facts.d</span></span><br><span class="line">            <span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copy</span> <span class="string">a.fact</span></span><br><span class="line">          <span class="attr">copy:</span> </span><br><span class="line">            <span class="attr">src:</span> <span class="string">myfact.fact</span></span><br><span class="line">            <span class="attr">dest:</span> <span class="string">/home/ansible_poc/facts.d</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">inventory_hostname</span> <span class="string">==</span> <span class="string">&quot;192.168.100.10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">play2</span> <span class="string">use</span> <span class="string">local</span> <span class="string">facts</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">ansible_local.myfact.model.pc</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">inventory_hostname</span> <span class="string">==</span> <span class="string">&quot;192.168.100.10&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然local Facts不太方便，但它支持可执行文件的方式。用户可以直接写一个可执行文件来动态生成Facts信息而不是预先以静态的方式写好的Facts变量。</p><p>例如，想要收集mysql galera集群中节点的状态，编写如下可执行Facts文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &#x27;[cluster_status]&#x27;</span><br><span class="line">mysql -e &quot;SHOW GLOBAL STATUS LIKE &#x27;wsrep_cluster_status&#x27;\G&quot; | awk &#x27;/Value/&#123;print &quot;status=&quot;$2&#125;&#x27;</span><br></pre></td></tr></table></figure><p>之后便可以在playbook中使用<code>ansible_local.FACT_FILENAME.cluster_status.status</code>来访问对应节点的状态。</p><h1 id="set-fact模块"><a href="#set-fact模块" class="headerlink" title="set_fact模块"></a>set_fact模块</h1><blockquote><p>Facts的各种信息实际上是以变量方式保存的。</p></blockquote><p>我们还可以在任务中通过<code>set_fact</code>模块直接定义Facts，其效果就是定义了一个变量，和<code>register</code>指令的功能类似，只不过<code>register</code>指令是将模块的执行返回值赋值给变量名，而<code>set_fact</code>是手动指定变量的值。</p><p>示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">define</span> <span class="string">some</span> <span class="string">var</span></span><br><span class="line">      <span class="attr">set_fact:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">slions</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">29</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">var</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;name: <span class="template-variable">&#123;&#123;name&#125;&#125;</span>, age: <span class="template-variable">&#123;&#123;age&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>set_fact经常用于临时设置变量，也非常方便，比如可以在将shell执行结果通过register注册变量之后，立即使用set_fact将命令的标准输出定义成变量。如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        echo 183@163.com</span></span><br><span class="line"><span class="string"></span>      <span class="attr">register:</span> <span class="string">echo_res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">set_fact:</span> <span class="string">echo_var=&#123;&#123;echo_res.stdout&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">var</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">echo_var</span></span><br></pre></td></tr></table></figure><h1 id="facts缓存"><a href="#facts缓存" class="headerlink" title="facts缓存"></a>facts缓存</h1><p>收集fact是耗时的，ansible支持fact缓存，通过设置Ansible配置文件，然后就可以在任何时间点通过一个独立的收集任务去收集，并将收集的Facts缓存下来，以后使用Facts变量时就不用再显式地低效收集。</p><p>配置Ansible开启Facts缓存的方式非常简单，修改Ansible配置文件(默认是<code>/etc/ansible/ansible.cfg</code>或其它位置)。目前Ansible支持以下几种缓存模式：</p><ul><li>redis：缓存在redis服务中，直到目前(Ansible 2.9)为止，Ansible还不支持指定连接redis的端口、密码等</li><li>memcached：缓存在memcache文件中</li><li>mongodb：缓存在mongodb文件中</li><li>jsonfile：缓存在本地的json文件中</li><li>yaml：缓存在本地的yaml文件中</li><li>pickle：缓存在本地的pickle序列化文件中</li></ul><p>配置方式，可参考如下配置项：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jsonfile缓存模式</span></span><br><span class="line"><span class="attr">gathering</span> = smart或explicit或implicit</span><br><span class="line"><span class="attr">fact_caching</span> = jsonfile</span><br><span class="line"><span class="attr">fact_caching_connection</span> = DIRNAME</span><br><span class="line"><span class="attr">fact_caching_timeout</span>=TIMEOUT</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis缓存模式</span></span><br><span class="line"><span class="attr">gathering</span> = smart或explicit或implicit</span><br><span class="line"><span class="attr">fact_caching</span> = redis</span><br><span class="line"><span class="attr">fact_caching_timeout</span>=TIMEOUT</span><br><span class="line"><span class="attr">fact_caching_connection</span> = localhost:<span class="number">6379</span>:<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mongodb缓存模式</span></span><br><span class="line"><span class="attr">fact_caching</span> = mongodb</span><br><span class="line"><span class="attr">fact_caching_timeout</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">fact_caching_connection</span> = mongodb://localhost:<span class="number">32770</span>/ansible_cache</span><br></pre></td></tr></table></figure><p>配置项解析：</p><p>gathering：控制Ansible是否自动收集Facts，它有三种值：</p><ul><li>implicit：这是默认值，表示执行play时会自动收集Facts，除非显式指定gather_facts: false禁止收集</li><li>explicit：不自动收集Facts，除非显式指定gather_facts: true开启收集</li><li>smart：自动收集Facts，但如果已存在(缓存)则不重复收集</li></ul><p>fact_caching_connection：指定本地目录用于存放Facts的缓存文件，如果目录不存在则Ansible会尝试创建<br>fact_caching_timeout：缓存的有效时长</p><p>当前工作中我们使用的jsonfile配置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gathering</span> = smart</span><br><span class="line"><span class="attr">fact_caching</span> = jsonfile</span><br><span class="line"><span class="attr">fact_caching_connection</span> = facts</span><br></pre></td></tr></table></figure><p>当第一次执行playbook后，会将收集到的内容缓存到当前目录下的facts目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# ll facts</span><br><span class="line">总用量 48</span><br><span class="line">-rw-r--r--. 1 root root 22845 12月  1 15:06 192.168.100.10</span><br><span class="line">-rw-r--r--. 1 root root 23039 12月  1 15:06 192.168.100.11</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后便可以直接去引用这些缓存下来的Facts信息，甚至访问不在该play中的节点的Facts信息。例如，playbook内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">var</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">hostvars[&#x27;192.168.100.11&#x27;].ansible_hostname</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;收集节点信息&quot;&gt;&lt;a href=&quot;#收集节点信息&quot; class=&quot;headerlink&quot; title=&quot;收集节点信息&quot;&gt;&lt;/a&gt;收集节点信息&lt;/h1&gt;&lt;p&gt;ansible可以获取目标主机的节点信息，如ip地址，主机名、系统版本、内核版本等等，对于运维来说是一个很好</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（六）限制执行任务主机</title>
    <link href="https://slions.github.io/2021/11/29/%EF%BC%88%E5%85%AD%EF%BC%89%E9%99%90%E5%88%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E4%B8%BB%E6%9C%BA/"/>
    <id>https://slions.github.io/2021/11/29/%EF%BC%88%E5%85%AD%EF%BC%89%E9%99%90%E5%88%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E4%B8%BB%E6%9C%BA/</id>
    <published>2021-11-29T08:11:32.000Z</published>
    <updated>2021-11-29T08:23:06.972Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，所有被ansible或ansible-playbook选中的主机都会执行任务，有时在开发和测试阶段只想选择其中某些节点来执行，需要改动inventory文件或playbook的host不是很优雅，ansible 提供了<code>--limit</code>选项来筛选目标主机。</p><blockquote><p>使用 –limit选项，ansible或ansible-playbook也会解析inventory中定义的所有主机，在执行任务时才会选择定义后的目标主机。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# cat two.yml</span><br><span class="line">- hosts: test</span><br><span class="line">  gather_facts: false</span><br><span class="line">  tasks:</span><br><span class="line">  - debug:</span><br><span class="line">      msg: &quot;echo &#123;&#123; var1 &#125;&#125;&quot;</span><br><span class="line">[root@slions_pc1 ansible_poc]# ansible-playbook one.yml</span><br><span class="line"></span><br><span class="line">PLAY [test] *****************************************************************************************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [first : 我的测试play] *****************************************************************************************************************************************************************</span><br><span class="line">ok: [192.168.100.10] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;echo myvar&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.168.100.11] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;echo myvar&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP ******************************************************************************************************************************************************************************</span><br><span class="line">192.168.100.10             : ok=1    changed=0    unreachable=0    failed=0</span><br><span class="line">192.168.100.11             : ok=1    changed=0    unreachable=0    failed=0</span><br><span class="line"></span><br><span class="line">[root@slions_pc1 ansible_poc]# ansible-playbook one.yml --limit 192.168.100.11</span><br><span class="line"></span><br><span class="line">PLAY [test] *****************************************************************************************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [first : 我的测试play] *****************************************************************************************************************************************************************</span><br><span class="line">ok: [192.168.100.11] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;echo myvar&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP ******************************************************************************************************************************************************************************</span><br><span class="line">192.168.100.11             : ok=1    changed=0    unreachable=0    failed=0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;默认情况下，所有被ansible或ansible-playbook选中的主机都会执行任务，有时在开发和测试阶段只想选择其中某些节点来执行，需要改动inventory文件或playbook的host不是很优雅，ansible 提供了&lt;code&gt;--limit&lt;/code&gt;选项</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>harbor对接F5的鉴权失败问题</title>
    <link href="https://slions.github.io/2021/11/23/harbor%E5%AF%B9%E6%8E%A5F5%E7%9A%84%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://slions.github.io/2021/11/23/harbor%E5%AF%B9%E6%8E%A5F5%E7%9A%84%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-23T02:13:53.000Z</published>
    <updated>2021-11-23T03:32:41.203Z</updated>
    
    <content type="html"><![CDATA[<p>之前harbor的高可用方案都是通过我们自建VIP与检测机制来做的，此次上线的双活架构下，VIP无法跨网段进行通信，甲方提供F5作为统一入口，由此进行了F5对接harbor的功能性测试。</p><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>使用docker login harbor时，有时成功，有时失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker login -u user -p passwd http://xxx.xxx.xxx.xxx:9980</span></span><br><span class="line">Error response from daemon: login attempt to http://xxx.xxx.xxx.xxx:9980/v2/ failed with status: 401 Unauthorized</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker login -u user -p passwd http://xxx.xxx.xxx.xxx:9980</span></span><br><span class="line">Error response from daemon: login attempt to http://xxx.xxx.xxx.xxx:9980/v2/ failed with status: 401 Unauthorized</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker login -u user -p passwd http://xxx.xxx.xxx.xxx:9980</span></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><p>修改docker配置文件中镜像仓库地址为单独的harbor节点再次测试，没有任何问题。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>接着将docker镜像仓库地址换回F5地址，打开两个终端分别监视两个Harbor节点上的registry的日志。</p><p>经过几次测试，发现一个现象：当docker login成功时，都是一个节点上的日志出现更新；而当docker login fail时，会看到两个节点上的registry日志都有变化，这就有些出乎意料了。</p><p><img src="https://slions.gitee.io/picbed/img/hf1.png"></p><p>查阅harbor官方对docker login的<a href="https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor#the-process-of-docker-login">流程解析</a></p><p><img src="https://slions.gitee.io/picbed/img/hf2.png"></p><ul><li>docker向registry发起请求，由于registry是基于token auth的，因此registry回复应答，告诉docker client去哪个URL去获取token；</li><li>docker client根据应答中的URL向token service(ui)发起请求，通过user和passwd获取token；如果user和passwd在db中通过了验证，那么token service将用自己的私钥<code>(harbor/common/config/ui/private_key.pem)</code>生成一个token，返回给docker client端；</li><li>docker client获得token后再向registry发起login请求，registry用自己的证书<code>(harbor/common/config/registry/root.crt)</code>对token进行校验。通过则返回成功，否则返回失败。</li></ul><p>从这个原理，可以知道问题就出在docker client多次向Harbor发起请求这个环节：对于每次请求，F5会将域名可能解析为不同IP，因此不同请求可能落到不同的镜像仓库节点上。这样当docker client拿着节点1上token service分配的token去到节点2的registry上鉴权时，就会出现鉴权失败的情况。</p><h1 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h1><p>token service的私钥<code>(harbor/common/config/ui/private_key.pem)</code>和registry的证书<code>(harbor/common/config/registry/root.crt)</code>都是在prepare时生成的，两个节点都独立prepare过，因此两个node上的private_key.pem和root.crt是不同的。所以造成了鉴权失败的问题。统一两个节点的私钥和证书可以解决。</p><p>将节点1上的private_key.pem和root.crt复制到节点2上，并重新创建node2上的harbor container。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前harbor的高可用方案都是通过我们自建VIP与检测机制来做的，此次上线的双活架构下，VIP无法跨网段进行通信，甲方提供F5作为统一入口，由此进行了F5对接harbor的功能性测试。&lt;/p&gt;
&lt;h1 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;he</summary>
      
    
    
    
    <category term="镜像仓库" scheme="https://slions.github.io/categories/%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    
    
    <category term="harbor" scheme="https://slions.github.io/tags/harbor/"/>
    
  </entry>
  
  <entry>
    <title>保留特殊字符</title>
    <link href="https://slions.github.io/2021/11/17/%E4%BF%9D%E7%95%99%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
    <id>https://slions.github.io/2021/11/17/%E4%BF%9D%E7%95%99%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</id>
    <published>2021-11-17T10:24:36.000Z</published>
    <updated>2021-12-01T12:26:51.840Z</updated>
    
    <content type="html"><![CDATA[<p>由于Ansible采用Jinja2模板引擎渲染字符串，在需要渲染的时候，如果发现字符串中包含了Jinja2的特殊字符，就会认为这是一个需要渲染的内容。</p><p>如下示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;测试特殊字符&quot;</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">pvar</span></span><br><span class="line">      <span class="attr">vars:</span></span><br><span class="line">        <span class="attr">pvar:</span> <span class="type">!myvar</span></span><br></pre></td></tr></table></figure><p>运行时会报语法错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# ansible-playbook test.yml</span><br><span class="line">ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:</span><br><span class="line">JSON: No JSON object could be decoded</span><br><span class="line"></span><br><span class="line">Syntax Error while loading YAML.</span><br><span class="line">  could not determine a constructor for the tag &#x27;!myvar&#x27;</span><br><span class="line"></span><br><span class="line">The error appears to be in &#x27;/home/ansible_poc/six.yml&#x27;: line 9, column 15, but may</span><br><span class="line">be elsewhere in the file depending on the exact syntax problem.</span><br><span class="line"></span><br><span class="line">The offending line appears to be:</span><br><span class="line"></span><br><span class="line">      vars:</span><br><span class="line">        pvar: !myvar</span><br><span class="line">              ^ here</span><br></pre></td></tr></table></figure><p>想要在定义变量时、指定name属性值时或其它会渲染的地方使用这些Jinja2的特殊符号，需要加上<code>!unsafe</code>标记。这个标记会禁止渲染，保留原始的特殊符号。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vars:</span></span><br><span class="line">  <span class="attr">pvar:</span> <span class="type">!unsafe</span> <span class="string">&quot;!myvar&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于Ansible采用Jinja2模板引擎渲染字符串，在需要渲染的时候，如果发现字符串中包含了Jinja2的特殊字符，就会认为这是一个需要渲染的内容。&lt;/p&gt;
&lt;p&gt;如下示例：&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>普通用户安装mysql</title>
    <link href="https://slions.github.io/2021/10/31/%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85mysql/"/>
    <id>https://slions.github.io/2021/10/31/%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85mysql/</id>
    <published>2021-10-31T05:53:58.000Z</published>
    <updated>2021-10-31T08:11:55.545Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql是最为常用的关系型数据库，关于安装网上大多都是通过root用户直接来安装的，真实场景中，多数情况是不会给root用户的，要不是直接向甲方申请mysql，要不是给普通用户自己安装。</p><p>下面演示如何通过普通用户完成mysql服务的搭建。</p><h1 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h1><table><thead><tr><th><strong>主机名</strong></th><th>ip地址</th><th><strong>系统版本</strong></th><th><strong>系统资源</strong></th></tr></thead><tbody><tr><td>slions_pc2</td><td>192.168.100.11</td><td>CentOS Linux release 7.6.1810</td><td>cpu:2  mem:4GB</td></tr></tbody></table><h1 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h1><p>后续通过slions用户来完成mysql环境搭建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]groupadd -g 7295 slions &amp;&amp; useradd -u 7295 -g 7295 -s /bin/bash slions &amp;&amp; echo &quot;slions:slions&quot; | chpasswd</span><br><span class="line">[root@slions_pc2 ~]# id slions</span><br><span class="line">uid=7295(slions) gid=7295(slions) 组=7295(slions)</span><br></pre></td></tr></table></figure><h1 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h1><p>访问<a href="https://dev.mysql.com/downloads/mysql/">mysql官网</a>，当前最新的版本为8.0.27，想要下载历史版本需点击标注处。</p><p><img src="https://slions.gitee.io/picbed/img/mysql1.png"></p><p>此次我们安装Mysql 5.7.36</p><p><img src="https://slions.gitee.io/picbed/img/mysql2.png"></p><p>选择tar.gz离线包</p><p><img src="https://slions.gitee.io/picbed/img/mysql3.png"></p><p>不登录，直接下载到本地</p><p><img src="https://slions.gitee.io/picbed/img/mysql4.png"></p><h1 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h1><p>使用slions用户登录服务器，将下载好的mysql离线包拷贝到服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ ls</span><br><span class="line">mysql-5.7.36-el7-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ tar -zxvf mysql-5.7.36-el7-x86_64.tar.gz</span><br><span class="line">[slions@slions_pc2 ~]$ mv mysql-5.7.36-el7-x86_64 mysql</span><br></pre></td></tr></table></figure><p>创建数据、日志与socket目录以及配置文件目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ mkdir -p data/mysql/&#123;data,logs,tmp&#125; &amp;&amp; mkdir conf</span><br><span class="line">[slions@slions_pc2 ~]$ ls -l</span><br><span class="line">总用量 715496</span><br><span class="line">drwxrwxr-x. 2 slions slions        6 10月 31 13:50 conf</span><br><span class="line">drwxrwxr-x. 3 slions slions        6 10月 31 11:08 data</span><br><span class="line">drwxrwxr-x. 9 slions slions       129 10月 31 11:05 mysql</span><br><span class="line">-rw-rw-r--. 1 slions slions 732667171 10月 31 11:02 mysql-5.7.36-el7-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>编写mysql配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ cat &gt;&gt; conf/my.cnf &lt;&lt; EOF</span><br><span class="line">[client]</span><br><span class="line">port = 33060</span><br><span class="line">socket = /home/slions/data/mysql/tmp/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line">user = slions</span><br><span class="line">basedir = /home/slions/mysql</span><br><span class="line">datadir = /home/slions/data/mysql/data</span><br><span class="line">port = 33060</span><br><span class="line">socket = /home/slions/data/mysql/tmp/mysql.sock</span><br><span class="line">pid-file = /home/slions/data/mysql/tmp/mysqld.pid</span><br><span class="line">tmpdir = /home/slions/data/mysql/tmp</span><br><span class="line">skip_name_resolve = 1</span><br><span class="line">symbolic-links=0</span><br><span class="line">max_connections = 2000</span><br><span class="line">group_concat_max_len = 1024000</span><br><span class="line">sql_mode = NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">log_timestamps=SYSTEM</span><br><span class="line">character-set-server = utf8</span><br><span class="line">interactive_timeout = 1800</span><br><span class="line">wait_timeout = 1800</span><br><span class="line">max_allowed_packet = 32M</span><br><span class="line">binlog_cache_size = 4M</span><br><span class="line">sort_buffer_size = 2M</span><br><span class="line">read_buffer_size = 4M</span><br><span class="line">join_buffer_size = 4M</span><br><span class="line">tmp_table_size = 96M</span><br><span class="line">max_heap_table_size = 96M</span><br><span class="line">max_length_for_sort_data = 8096</span><br><span class="line"><span class="meta">#</span><span class="bash">logs</span></span><br><span class="line">server-id = 1003306</span><br><span class="line">log-error = /home/slions/data/mysql/logs/error.log</span><br><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = /home/slions/data/mysql/logs/slow.log</span><br><span class="line">long_query_time = 3</span><br><span class="line">log-bin = /home/slions/data/mysql/logs/binlog</span><br><span class="line">binlog_format = row</span><br><span class="line">expire_logs_days = 15</span><br><span class="line">log_bin_trust_function_creators = 1</span><br><span class="line">relay-log = /home/slions/data/mysql/logs/relay-bin</span><br><span class="line">relay-log-recovery = 1</span><br><span class="line">relay_log_purge = 1</span><br><span class="line"><span class="meta">#</span><span class="bash">innodb</span></span><br><span class="line">innodb_file_per_table = 1</span><br><span class="line">innodb_log_buffer_size = 16M</span><br><span class="line">innodb_log_file_size = 256M</span><br><span class="line">innodb_log_files_in_group = 2</span><br><span class="line">innodb_io_capacity = 2000</span><br><span class="line">innodb_io_capacity_max = 4000</span><br><span class="line">innodb_flush_neighbors = 0</span><br><span class="line">innodb_flush_method = O_DIRECT</span><br><span class="line">innodb_autoinc_lock_mode = 2</span><br><span class="line">innodb_read_io_threads = 8</span><br><span class="line">innodb_write_io_threads = 8</span><br><span class="line">innodb_buffer_pool_size = 2G</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>初始化数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ ./mysql/bin/mysqld --defaults-file=/home/slions/conf/my.cnf --initialize --user=slions --basedir=/home/slions/mysql --datadir=/home/slions/data/mysql/data</span><br></pre></td></tr></table></figure><p>获取root密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ cat data/mysql/logs/error.log |grep password</span><br></pre></td></tr></table></figure><p>启动mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ ./mysql/bin/mysqld_safe --defaults-file=/home/slions/conf/my.cnf --user=slions &amp;</span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ echo &quot;PATH=$PATH:/home/slions/mysql/bin&quot; &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure><h1 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ mysql -uroot -P33060 -p -S /home/slions/data/mysql/tmp/mysql.sock</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改默认的root密码及远程登录权限</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;admin123&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;admin123&#x27;</span> WITH GRANT OPTION;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure><p>此时已经可以通过其他客户端访问该服务了。</p><h1 id="设置命令别名"><a href="#设置命令别名" class="headerlink" title="设置命令别名"></a>设置命令别名</h1><p>因为我们改了默认的mysql.sock路径，导致每次客户端连接时都要指明mysql.sock,不然会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ mysql</span><br><span class="line">ERROR 2002 (HY000): Can&#x27;t connect to local MySQL server through socket &#x27;/tmp/mysql.sock&#x27; (2)</span><br></pre></td></tr></table></figure><p>可以配置个命令别名，之后就可以正常使用了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ alias mysql=&#x27;mysql -S /home/slions/data/mysql/tmp/mysql.sock&#x27;</span><br><span class="line">[slions@slions_pc2 ~]$ mysql</span><br><span class="line">ERROR 1045 (28000): Access denied for user &#x27;slions&#x27;@&#x27;localhost&#x27; (using password: NO)</span><br></pre></td></tr></table></figure><h1 id="配置开机自启"><a href="#配置开机自启" class="headerlink" title="配置开机自启"></a>配置开机自启</h1><p>配置开机自启需要root权限。</p><h2 id="systemd-service方式"><a href="#systemd-service方式" class="headerlink" title="systemd service方式"></a>systemd service方式</h2><p>编写mysql服务启动文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# cat &gt;&gt; /usr/lib/systemd/system/slions-mysql.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Slions Mysql Server</span><br><span class="line">After=network.service</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">User=slions</span><br><span class="line">Group=slions</span><br><span class="line">Type=forking</span><br><span class="line">TimeoutSec=0</span><br><span class="line">ExecStart=/home/slions/mysql/bin/mysqld --defaults-file=/home/slions/conf/my.cnf --basedir=/home/slions/mysql --datadir=/home/slions/data/mysql/data --daemonize</span><br><span class="line">ExecStop=/bin/kill $MAINPID</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=10</span><br><span class="line">RestartPreventExitStatus=1</span><br><span class="line">PrivateTmp=false</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动服务并设置开机自启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# pkill -9 mysql</span><br><span class="line">[root@slions_pc2 ~]# systemctl enable slions-mysql.service</span><br><span class="line">[root@slions_pc2 ~]# systemctl start slions-mysql.service</span><br><span class="line">[root@slions_pc2 ~]# ps -elf|grep mysql</span><br><span class="line">5 S slions    11905      1  0  80   0 - 835134 poll_s 12:31 ?       00:00:08 /home/slions/mysql/bin/mysqld --defaults-file=/home/slions/conf/my.cnf --basedir=/home/slions/mysql --datadir=/home/slions/data/mysql/data --socket=/home/slions/data/mysql/tmp/mysql.sock --pid-file=/home/slions/data/mysql/tmp/mysqld.pid --daemonize</span><br><span class="line">4 S root      12398   9776  0  80   0 - 28182 pipe_w 14:56 pts/0    00:00:00 grep --color=auto mysql</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mysql是最为常用的关系型数据库，关于安装网上大多都是通过root用户直接来安装的，真实场景中，多数情况是不会给root用户的，要不是直接向甲方申请mysql，要不是给普通用户自己安装。&lt;/p&gt;
&lt;p&gt;下面演示如何通过普通用户完成mysql服务的搭建。&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="Mysql" scheme="https://slions.github.io/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://slions.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>k8s-controller-manager原理</title>
    <link href="https://slions.github.io/2021/10/03/k8s-controller-manager%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/10/03/k8s-controller-manager%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-03T14:39:16.000Z</published>
    <updated>2021-10-07T03:04:35.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="controller-manager作用"><a href="#controller-manager作用" class="headerlink" title="controller-manager作用"></a>controller-manager作用</h1><p>Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理。</p><p><img src="https://slions.gitee.io/picbed/img/con1.png"></p><p>逻辑上，每个控制器是一个单独的协程。用于监视 apiserver 暴露的集群状态，并且不断地尝试把当前状态向集群的目标状态迁移。为了避免频繁查询 apiserver，apiserver 提供了 watch 接口用于监视资源的增加删除和更新，client-go 对此作了抽象，封装一层 informer 来表示本地 apiserver 状态的 cache 。</p><h1 id="工作流程与运行机制"><a href="#工作流程与运行机制" class="headerlink" title="工作流程与运行机制"></a>工作流程与运行机制</h1><p>参考：</p><p><a href="http://dockone.io/article/9557">Kubernetes Controller Manager 工作原理</a></p><p><a href="https://blog.csdn.net/huwh_/article/details/75675761">控制器浅析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;controller-manager作用&quot;&gt;&lt;a href=&quot;#controller-manager作用&quot; class=&quot;headerlink&quot; title=&quot;controller-manager作用&quot;&gt;&lt;/a&gt;controller-manager作用&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>kube-proxy原理</title>
    <link href="https://slions.github.io/2021/10/03/kube-proxy%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/10/03/kube-proxy%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-03T03:40:00.000Z</published>
    <updated>2021-10-03T10:51:20.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kube-proxy的作用"><a href="#kube-proxy的作用" class="headerlink" title="kube-proxy的作用"></a>kube-proxy的作用</h1><p>kube-proxy是Kubernetes的核心组件，部署在每个Node节点上，它是实现Kubernetes Service的通信与负载均衡机制的重要组件; kube-proxy负责为Pod创建代理服务，从apiserver获取所有server信息，并根据server信息创建代理服务，实现server到Pod的请求路由和转发，从而实现K8s层级的虚拟转发网络。</p><blockquote><p>在k8s中，提供相同服务的一组pod可以抽象成一个service，通过service提供的统一入口对外提供服务，每个service都有一个虚拟IP地址（VIP）和端口号供客户端访问。kube-proxy存在于各个node节点上，主要用于Service功能的实现，具体来说，就是实现集群内的客户端pod访问service，或者是集群外的主机通过NodePort等方式访问service。在当前版本的k8s中，kube-proxy默认使用的是iptables模式，通过各个node节点上的iptables规则来实现service的负载均衡，但是随着service数量的增大，iptables模式由于线性查找匹配、全量更新等特点，其性能会显著下降。从k8s的1.8版本开始，kube-proxy引入了IPVS模式，IPVS模式与iptables同样基于Netfilter，但是采用的hash表，因此当service数量达到一定规模时，hash查表的速度优势就会显现出来，从而提高service的服务性能。</p></blockquote><p>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡，它运行在每个Node计算节点上，负责Pod网络代理, 它会定时从etcd服务获取到service信息来做相应的策略，维护网络规则和四层负载均衡工作。在K8s集群中微服务的负载均衡是由Kube-proxy实现的，它是K8s集群内部的负载均衡器，也是一个分布式代理服务器，在K8s的每个节点上都有一个，这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>service是一组pod的服务抽象，相当于一组pod的LB，负责将请求分发给对应的pod。service会为这个LB提供一个IP，一般称为cluster IP。kube-proxy的作用主要是负责service的实现，具体来说，就是实现了内部从pod到service和外部的从node port向service的访问。</li><li>kube-proxy其实就是管理service的访问入口，包括集群内Pod到Service的访问和集群外访问service。</li><li>kube-proxy管理sevice的Endpoints，该service对外暴露一个Virtual IP，也成为Cluster IP, 集群内通过访问这个Cluster IP:Port就能访问到集群内对应的serivce下的Pod。</li><li>service是通过Selector选择的一组Pods的服务抽象，其实就是一个微服务，提供了服务的LB和反向代理的能力，而kube-proxy的主要作用就是负责service的实现。</li><li>service另外一个重要作用是，一个服务后端的Pods可能会随着生存灭亡而发生IP的改变，service的出现，给服务提供了一个固定的IP，而无视后端Endpoint的变化。</li></ul><p>举个例子，比如现在有podA，podB，podC和serviceAB。serviceAB是podA，podB的服务抽象(service)。那么kube-proxy的作用就是可以将pod(不管是podA，podB或者podC)向serviceAB的请求，进行转发到service所代表的一个具体pod(podA或者podB)上。请求的分配方法一般分配是采用轮询方法进行分配。另外，kubernetes还提供了一种在node节点上暴露一个端口，从而提供从外部访问service的方式。比如这里使用这样的一个yml来创建service。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">service</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30964</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">mysql-service:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Service-Endpoints与Pod的关系"><a href="#Service-Endpoints与Pod的关系" class="headerlink" title="Service, Endpoints与Pod的关系"></a>Service, Endpoints与Pod的关系</h2><p><img src="https://slions.gitee.io/picbed/img/proxy1.png"></p><p>Kube-proxy进程获取每个Service的Endpoints,实现Service的负载均衡功能</p><h2 id="Service的负载均衡转发规则"><a href="#Service的负载均衡转发规则" class="headerlink" title="Service的负载均衡转发规则"></a>Service的负载均衡转发规则</h2><p><img src="https://slions.gitee.io/picbed/img/proxy2.png"></p><p>访问Service的请求，不论是Cluster IP+TargetPort的方式；还是用Node节点IP+NodePort的方式，都被Node节点的Iptables规则重定向到Kube-proxy监听Service服务代理端口。kube-proxy接收到Service的访问请求后，根据负载策略，转发到后端的Pod。</p><h1 id="kubernetes服务发现"><a href="#kubernetes服务发现" class="headerlink" title="kubernetes服务发现"></a>kubernetes服务发现</h1><p>Kubernetes提供了两种方式进行服务发现, 即<strong>环境变量</strong>和<strong>DNS</strong>, 简单说明如下:</p><ol><li>环境变量： 当创建一个Pod的时候，kubelet会在该Pod中注入集群内所有Service的相关环境变量。<strong>需要注意:</strong> 要想一个Pod中注入某个Service的环境变量，则必须Service要先比该Pod创建。这一点，几乎使得这种方式进行服务发现不可用。比如，一个ServiceName为redis-master的Service，对应的ClusterIP:Port为172.16.50.11:6379，则其对应的环境变量为:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REDIS_MASTER_SERVICE_HOST=172.16.50.11</span><br><span class="line">REDIS_MASTER_SERVICE_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT=tcp://172.16.50.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP=tcp://172.16.50.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PROTO=tcp</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_ADDR=172.16.50.11</span><br></pre></td></tr></table></figure><ol start="2"><li>DNS：这是k8s官方强烈推荐的方式!!! 可以通过cluster add-on方式轻松的创建KubeDNS来对集群内的Service进行服务发现。</li></ol><h1 id="kubernetes发布-暴露-服务"><a href="#kubernetes发布-暴露-服务" class="headerlink" title="kubernetes发布(暴露)服务"></a>kubernetes发布(暴露)服务</h1><p>kubernetes原生的，一个Service的ServiceType决定了其发布服务的方式。</p><ul><li>ClusterIP：这是k8s默认的ServiceType。通过集群内的ClusterIP在内部发布服务。</li><li>NodePort：这种方式是常用的，用来对集群外暴露Service，你可以通过访问集群内的每个NodeIP:NodePort的方式，访问到对应Service后端的Endpoint。</li><li>LoadBalancer: 这也是用来对集群外暴露服务的，不同的是这需要Cloud Provider的支持，比如AWS等。</li><li>ExternalName：这个也是在集群内发布服务用的，需要借助KubeDNS(version &gt;= 1.7)的支持，就是用KubeDNS将该service和ExternalName做一个Map，KubeDNS返回一个CNAME记录。</li></ul><h1 id="kube-proxy-工作原理"><a href="#kube-proxy-工作原理" class="headerlink" title="kube-proxy 工作原理"></a>kube-proxy 工作原理</h1><p>kube-proxy当前实现了三种代理模式：<strong>userspace,</strong> <strong>iptables, ipvs</strong>。其中userspace mode是v1.0及之前版本的默认模式，从v1.1版本中开始增加了iptables mode，在v1.2版本中正式替代userspace模式成为默认模式。也就是说kubernetes在v1.2版本之前是默认模式, v1.2版本之后默认模式是iptables。</p><h2 id="userspace-mode"><a href="#userspace-mode" class="headerlink" title="userspace mode"></a>userspace mode</h2><p>userspace是在用户空间，通过kube-proxy来实现service的代理服务, 其原理如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy3.png"></p><p>可见，userspace这种mode最大的问题是，service的请求会先从用户空间进入内核iptables，然后再回到用户空间，由kube-proxy完成后端Endpoints的选择和代理工作，这样流量从用户空间进出内核带来的性能损耗是不可接受的。这也是k8s v1.0及之前版本中对kube-proxy质疑最大的一点，因此社区就开始研究iptables mode.</p><p>userspace这种模式下，kube-proxy 持续监听 Service 以及 Endpoints 对象的变化；对每个 Service，它都为其在本地节点开放一个端口，作为其服务代理端口；发往该端口的请求会采用一定的策略转发给与该服务对应的后端 Pod 实体。kube-proxy 同时会在本地节点设置 iptables 规则，配置一个 Virtual IP，把发往 Virtual IP 的请求重定向到与该 Virtual IP 对应的服务代理端口上。其工作流程大体如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy4.png"></p><p><strong>由此分析:</strong> 该模式请求在到达 iptables 进行处理时就会进入内核，而 kube-proxy 监听则是在用户态, 请求就形成了从用户态到内核态再返回到用户态的传递过程, 一定程度降低了服务性能。</p><h2 id="iptables-mode"><a href="#iptables-mode" class="headerlink" title="iptables mode"></a>iptables mode</h2><p>该模式完全利用内核iptables来实现service的代理和LB, 这是K8s在v1.2及之后版本默认模式. 工作原理如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy5.png"></p><p>iptables mode因为使用iptable NAT来完成转发，也存在不可忽视的性能损耗。另外，如果集群中存在上万的Service/Endpoint，那么Node上的iptables rules将会非常庞大，性能还会再打折扣。</p><p>iptables 模式与 userspace 相同，kube-proxy 持续监听 Service 以及 Endpoints 对象的变化；但它并不在本地节点开启反向代理服务，而是把反向代理全部交给 iptables 来实现；即 iptables 直接将对 VIP 的请求转发给后端 Pod，通过 iptables 设置转发策略。其工作流程大体如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy6.png"></p><p><strong>由此分析:</strong> 该模式相比 userspace 模式，克服了请求在用户态-内核态反复传递的问题，性能上有所提升，但使用 iptables NAT 来完成转发，存在不可忽视的性能损耗，而且在大规模场景下，iptables 规则的条目会十分巨大，性能上还要再打折扣。</p><h2 id="ipvs-mode"><a href="#ipvs-mode" class="headerlink" title="ipvs mode"></a>ipvs mode</h2><p>在kubernetes 1.8以上的版本中，对于kube-proxy组件增加了除iptables模式和用户模式之外还支持ipvs模式。kube-proxy ipvs 是基于 NAT 实现的，通过ipvs的NAT模式，对访问k8s service的请求进行虚IP到POD IP的转发。当创建一个 service 后，kubernetes 会在每个节点上创建一个网卡，同时帮你将 Service IP(VIP) 绑定上，此时相当于每个 Node 都是一个 ds，而其他任何 Node 上的 Pod，甚至是宿主机服务(比如 kube-apiserver 的 6443)都可能成为 rs。</p><p><img src="https://slions.gitee.io/picbed/img/proxy7.png"></p><p>与iptables、userspace 模式一样，kube-proxy 依然监听Service以及Endpoints对象的变化, 不过它并不创建反向代理, 也不创建大量的 iptables 规则, 而是通过netlink 创建ipvs规则，并使用k8s Service与Endpoints信息，对所在节点的ipvs规则进行定期同步; netlink 与 iptables 底层都是基于 netfilter 钩子，但是 netlink 由于采用了 hash table 而且直接工作在内核态，在性能上比 iptables 更优。其工作流程大体如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy8.png"></p><p><strong>由此分析：</strong>ipvs 是目前 kube-proxy 所支持的最新代理模式，相比使用 iptables，使用 ipvs 具有更高的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kube-proxy的作用&quot;&gt;&lt;a href=&quot;#kube-proxy的作用&quot; class=&quot;headerlink&quot; title=&quot;kube-proxy的作用&quot;&gt;&lt;/a&gt;kube-proxy的作用&lt;/h1&gt;&lt;p&gt;kube-proxy是Kubernetes的核心组件</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>k8s-etcd理解</title>
    <link href="https://slions.github.io/2021/10/03/k8s-etcd%E7%90%86%E8%A7%A3/"/>
    <id>https://slions.github.io/2021/10/03/k8s-etcd%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-03T03:39:44.000Z</published>
    <updated>2021-10-07T03:04:22.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="etcd作用"><a href="#etcd作用" class="headerlink" title="etcd作用"></a>etcd作用</h1><p>是用来存储所有 Kubernetes 的集群状态的，它除了具备状态存储的功能，还有事件监听和订阅、Leader选举的功能。</p><h2 id="存储k8s集群状态"><a href="#存储k8s集群状态" class="headerlink" title="存储k8s集群状态"></a>存储k8s集群状态</h2><p>整个kubernetes系统需要用到etcd用来协同和存储配置的有：</p><ul><li>网络插件flannel、calico等网络插件也需要用到etcd存储网络的配置信息</li><li>kubernetes本身，包括各种对象的状态和元信息配置</li></ul><blockquote><p>很多网上资料讲flannel操作etcd使用的是v2的API，而kubernetes操作etcd使用的v3的API，所以在下面我们执行etcdctl的时候需要设置ETCDCTL_API环境变量，该变量默认值为2。实际环境中没有找到。</p></blockquote><p><img src="https://slions.gitee.io/picbed/img/etcd1.png"></p><p>直接删除etcd中的数据在k8s中也会直接删除，但是由于apiserver会有对etcd的缓存，有段时间会显示数据显示不一致。</p><h2 id="事件监听和订阅"><a href="#事件监听和订阅" class="headerlink" title="事件监听和订阅"></a>事件监听和订阅</h2><p>所谓事件监听和订阅，各个其他组件通信，都并不是互相调用 API 来完成的，而是把状态写入 ETCD（相当于写入一个消息），其他组件通过监听 ETCD 的状态的的变化（相当于订阅消息），然后做后续的处理，然后再一次把更新的数据写入 ETCD。</p><h2 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h2><p>在k8s的组件中，其中有kube-scheduler和kube-controller-manager两个组件是有leader选举的，这个选举机制是k8s对于这两个组件的高可用保障。需要–leader-elect=true启动参数。即正常情况下kube-scheduler或kube-manager-controller组件的多个副本只有一个是处于业务逻辑运行状态，其它副本则不断的尝试去获取锁，去竞争leader，直到自己成为leader。如果正在运行的leader因某种原因导致当前进程退出，或者锁丢失，则由其它副本去竞争新的leader，获取leader继而执行业务逻辑。</p><p><img src="https://slions.gitee.io/picbed/img/etcd2.png"></p><p>在K8s中， 通过创建资源对象（当前的实现中实现了 ConfigMap 和 Endpoint 两种类型的资源）来维护锁的状态。这两种资源对象存在etcd里，也可以说是用etcd来实现的。</p><p>分布式锁一般实现原理就是大家先去抢锁，抢到的成为 leader ，然后 leader 会定期更新锁的状态，声明自己的活动状态，不让其他人把锁抢走。K8s 的资源锁也类似，抢到锁的节点会将自己的标记。设为锁的持有者，其他人则需要通过对比锁的更新时间和持有者来判断自己是否能成为新的 leader ，而 leader 则可以通过更新RenewTime来确保持续保有该锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;etcd作用&quot;&gt;&lt;a href=&quot;#etcd作用&quot; class=&quot;headerlink&quot; title=&quot;etcd作用&quot;&gt;&lt;/a&gt;etcd作用&lt;/h1&gt;&lt;p&gt;是用来存储所有 Kubernetes 的集群状态的，它除了具备状态存储的功能，还有事件监听和订阅、Leade</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>k8s-scheduler原理</title>
    <link href="https://slions.github.io/2021/10/03/k8s-scheduler%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/10/03/k8s-scheduler%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-03T02:39:28.000Z</published>
    <updated>2021-10-07T03:05:02.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scheduler作用"><a href="#scheduler作用" class="headerlink" title="scheduler作用"></a>scheduler作用</h1><p>负责整个集群资源的调度功能，根据特定的调度算法和策略，将 Pod 调度到最优的工作节点上面去，从而更加合理、更加充分的利用集群的资源。</p><p><img src="https://slions.gitee.io/picbed/img/sche1.png"></p><h1 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h1><p>根据特定的调度算法和调度策略将 Pod 调度到合适的 Node 节点上去，是一个独立的二进制程序，启动之后会一直监听 API Server，获取到 PodSpec.NodeName 为空的 Pod，对每个 Pod 都会创建一个 binding。</p><p>Scheduler 提供的调度流程分为预选 (Predicates) 和优选 (Priorities) 两个步骤：</p><ul><li>预选，K8S会遍历当前集群中的所有 Node，筛选出其中符合要求的 Node 作为候选</li><li>优选，K8S将对候选的 Node 进行打分</li></ul><p><strong>预选</strong>阶段首先遍历全部节点，过滤掉不满足条件的节点，属于强制性规则，这一阶段输出的所有满足要求的 Node 将被记录并作为第二阶段的输入，如果所有的节点都不满足条件，那么 Pod 将会一直处于 Pending 状态，直到有节点满足条件，在这期间调度器会不断的重试。</p><p><strong>优选</strong>阶段即再次对节点进行筛选，如果有多个节点都满足条件的话，那么系统会按照节点的优先级(priorites)大小对节点进行排序，最后选择优先级最高的节点来部署 Pod 应用。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><strong>Queue</strong></h2><p>Kubernetes Scheduler 在多任务情况下，他是如何工作的？ Queue，队列方式工作的，也就是说，即便有多个调度任务同时在 etcd 中等待调度， Scheduler 每次只会调度一个任务（和 Master 的数量无关）。内部逻辑：</p><ol><li><p>Scheduler 内部维护一个调度的pods队列podQueue， 并监听APIServer。</p></li><li><p>当我们创建Pod时，首先通过 API Server 往 etcd 写入 pod 元数据。</p></li><li><p>调度器通过 Informer 监听 pods 状态，当有新增 pod 时，将 pod 加入到 PodQueue中。</p></li><li><p>调度器中的主进程，会不断的从podQueue取出的pod，并将pod进入调度分配节点环节</p></li><li><p>调度环节分为两个步奏， Filter过滤满足条件的节点 、 Prioritize根据pod配置，例如资源使用率，亲和性等指标，给这些节点打分，最终选出分数最高的节点。</p></li><li><p>分配节点成功， 调用apiServer的binding pod 接口， 将pod.Spec.NodeName设置为所分配的那个节点。</p></li><li><p>节点上的kubelet同样监听ApiServer，如果发现有新的pod被调度到所在节点，调用本地的dockerDaemon 运行容器。</p><p>假如调度器尝试调度 Pod 不成功，如果开启了优先级和抢占功能，会尝试做一次抢占，将节点中优先级较低的pod删掉，并将待调度的pod调度到节点上。 如果未开启，或者抢占失败，会记录日志，并将pod加入 PodQueue 队尾（这意味着，如果调度队列很长，你只有多等待了）。</p></li><li><p>经过预选筛选和优选打分之后，K8S选择分数最高的 Node 来运行 Pod，如果最终有多个 Node 的分数最高，那么 Scheduler 将从当中随机选择一个 Node 来运行 Pod。</p></li></ol><h2 id="预选策略"><a href="#预选策略" class="headerlink" title="预选策略"></a>预选策略</h2><p><img src="https://slions.gitee.io/picbed/img/sche2.png"></p><p>如果开启了 TaintNodesByCondition(从 1.12 开始为 beta级别，默认开启) 特性，则 CheckNodeCondition、CheckNodeMemoryPressure、CheckNodeDiskPressure、CheckNodePIDPressure 预选策略则会被禁用，PodToleratesNodeNoExecuteTaints、CheckNodeUnschedulable 则会启用。</p><h2 id="优选策略"><a href="#优选策略" class="headerlink" title="优选策略"></a>优选策略</h2><p><img src="https://slions.gitee.io/picbed/img/sche3.png"></p><p>如果开启了 ResourceLimitsPriorityFunction(默认不开启) 特性，则 ResourceLimitsPriority 会被启用。</p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>查看<a href="/2021/10/03/k8s-etcd%E7%90%86%E8%A7%A3/" title="etcd篇的leader选举">etcd篇的leader选举</a>，没有额外设置都是走的默认配置（endpoint）,可以在scheduler.conf中设置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;scheduler作用&quot;&gt;&lt;a href=&quot;#scheduler作用&quot; class=&quot;headerlink&quot; title=&quot;scheduler作用&quot;&gt;&lt;/a&gt;scheduler作用&lt;/h1&gt;&lt;p&gt;负责整个集群资源的调度功能，根据特定的调度算法和策略，将 Pod 调</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>k8s-apiserver原理</title>
    <link href="https://slions.github.io/2021/09/26/k8s-apiserver%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/09/26/k8s-apiserver%E5%8E%9F%E7%90%86/</id>
    <published>2021-09-26T03:38:54.000Z</published>
    <updated>2021-10-03T08:59:24.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apiserver作用"><a href="#apiserver作用" class="headerlink" title="apiserver作用"></a>apiserver作用</h1><p>其对外暴露了Kubernetes API。它是的 Kubernetes 核心控制层。它被设计为水平扩展，即通过部署更多实例来横向扩展。API Server 负责和 etcd 交互（其他组件不会直接操作 etcd，只有 API Server 这么做），是整个 kubernetes 集群的数据中心，所有的交互都是以 API Server 为核心的。API Server 提供了以下的功能：</p><ul><li>提供了Kubemetes 各类资源对象的增、删、改、查及watch等的http rest接口。是资源配额的入口。</li><li>提供了完备的集群安全控制：API Server 提供的验证和授权保证了整个集群的安全。</li><li>集群内部各个模块之间通信的枢纽：所有模块之间并不会互相调用，而是通过和 API Server 打交道来完成各自的工作。</li></ul><p>kubernetes API server通过一个名为kube-apiserver的进程提供服务（运行在master节点），默认情况下kube-apiserver进程通过本机的8080端口（对应参数–insecure-port）提供REST服务。默认安装后会启动HTTPS安全端口（–secure-port=6443）来启动安全机制，加强REST API的安全性。</p><blockquote><p>可以通过curl 127.0.0.1:8080/api/v1查看目前支持的资源对象种类。</p></blockquote><h2 id="apiserver之restful接口"><a href="#apiserver之restful接口" class="headerlink" title="apiserver之restful接口"></a>apiserver之restful接口</h2><p>在Kubernetes系统中，大多数情况下，API定义和实现都符合标准的HTTP REST格式， 比如通过标准的HTTP动词（POST、PUT、GET、DELETE）来完成对相关资源对象的查询、创建、修改、删除等操作。但同时Kubernetes 也为某些非标准的REST行为实现了附加的API接口，例如Watch某个资源的变化、进入容器执行某个操作等。另外，某些API接口可能违背严格的REST模式，因为接口不是返回单一的JSON对象，而是返回其他类型的数据，比如JSON对象流（Stream）或非结构化的文本日志数据等。</p><h3 id="使用REST接口"><a href="#使用REST接口" class="headerlink" title="使用REST接口"></a>使用REST接口</h3><ul><li><p>GET /&lt;资源名的复数格式&gt;：获得某一类型的资源列表，例如GET /pods 返回一个Pod资源列表。</p></li><li><p>POST /&lt;资源名的复数格式&gt;：创建一个资源，该资源来自用户提供的JSON对象。</p></li><li><p>GET /&lt;资源名复数格式&gt;/&lt;名字&gt;：通过给出的名称（Name）获得单个资源，例如GET /pods/first 返回一个名称为“first”的Pod。</p></li><li><p>DELETE /&lt;资源名复数格式&gt;/&lt;名字&gt;：通过给出的名字删除单个资源，删除选项（DeleteOptions）中可以指定的优雅删除（Grace Deletion）的时间（GracePeriodSeconds），该可选项表明了从服务端接收到删除请求到资源被删除的时间间隔（单位为秒）。不同的类别（Kind）可能为优雅删除时间（Grace Period）申明默认值。用户提交的优雅删除时间将覆盖该默认值，包括值为0的优雅删除时间。</p></li><li><p>PUT /&lt;资源名复数格式&gt;/&lt;名字&gt;：通过给出的资源名和客户端提供的JSON对象来更新或创建资源。</p></li><li><p>PATCH /&lt;资源名复数格式&gt;/&lt;名字&gt;：选择修改资源详细指定的域。</p><p>对于PATCH操作，目前Kubernetes API通过相应的HTTP首部“Content-Type”对其进行识别。</p></li><li><p>GET /watch/&lt;资源名复数格式&gt;：随时间变化，不断接收一连串的JSON对象，这些JSON对象记录了给定资源类别内所有资源对象的变化情况。</p></li><li><p>GET /watch/&lt;资源名复数格式&gt;/：随时间变化，不断接收一连串的JSON对象，这些JSON对象记录了某个给定资源对象的变化情况。</p></li></ul><h3 id="特殊的REST接口"><a href="#特殊的REST接口" class="headerlink" title="特殊的REST接口"></a>特殊的REST接口</h3><p>k8s Proxy API接口，这类接口的作用是代理REST请求，即kubernetes API Server把收到的REST请求转发到某个Node上的kubelet守护进程的REST端口上，由该kubelet进程负责响应。</p><p>最实用的一个特性是可以实现一个简单有效的安全机制，如果只想对外暴露部分REST服务，则可以在Master或者其他任何节点上通过运行kubectl proxy进程启动一个内部代理来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy --address=192.168.191.15 --accept-hosts=&#x27;^*$&#x27;</span><br></pre></td></tr></table></figure><p>以上的例子是我们安装好kube-dashboard后登录ui所用的启动代理命令，其中的–accept-hosts就是允许访问的机器。</p><h2 id="apiserver之安全机制"><a href="#apiserver之安全机制" class="headerlink" title="apiserver之安全机制"></a>apiserver之安全机制</h2><p>用户可通过客户端kubectl命令行工具或其它方式访问Kubernetes的API资源，每个访问API的请求，都要经过三个步骤校验：Authentication、Authorization、Admission Control，总体如下图所示：</p><p><img src="https://slions.gitee.io/picbed/img/api1.png"></p><ul><li>Authentication（认证），<strong>对用户身份进行验证</strong>。认证方式现共有8种，可以启用一种或多种认证方式，只要有一种认证方式通过，就不再进行其它方式的认证。通常启用X509 Client Certs和Service Accout Tokens两种认证方式。</li><li>Authorization（授权），<strong>验证用户是否拥有访问权限</strong>。授权方式现共有6种，可以启用一种或多种授权方式，启用的任一种方式依据授权策略明确允许或拒绝请求，则立即返回，不再进行其它方式的授权。通常启用RBAC和Node授权方式。</li><li>Admission Control（准入控制），<strong>对API资源对象修改、校验</strong>。它有一个插件列表，所有请求需要经过这个列表中的每个准入控制插件修改、校验，如果某一个准入控制插件验证失败，就拒绝请求。</li></ul><p>用户访问 Kubernetes API时，apiserver认证授权模块从HTTPS请求中获取用户的身份信息、请求资源路径和业务对象参数。身份信息是用来确认用户的身份是否合法，资源路径是用于判定用户是否拥有访问操作的权限，业务对象参数则在准入控制中接受修改或校验参数设置是否符合业务要求。</p><p><img src="https://slions.gitee.io/picbed/img/api2.png"></p><ol><li>请求到达后，apiserver从请求的证书、Header中获取用户信息：Name（用户名）、UID（用户唯一标识）、Groups（用户分组）、Extra（用户额外信息）。认证通过后，通过Context将用户信息向下传播。</li><li>授权模块从Context、请求的Method及URI提取用户信息、请求资源属性。使用请求资源属性与授权策略匹配或向外部服务验证判断是否准予访问。</li><li>准入控制接收到HTTPS请求提交的Body内容、用户信息、资源信息，根据不同准入控制插件的功能对上述信息做修改或校验。</li></ol><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>认证即身份验证，认证关注的是谁发送的请求，也就是说用户必须用某种方式证明自己的身份信息。</p><p>Kubernetes集群有两种类型的用户：普通用户（normal users）、服务账户（service accounts），普通用户并不被Kubernetes管理和保存；而服务账户由Kubernetes存储在etcd中，并可通过apiserver API管理。</p><p>1.14版本中已支持8种认证方式，从身份验证的方法上可分为4种类型：Token、证书、代理、密码。Kubernetes可以同时启用多个认证方式，在这种情况下，每个认证模块都按顺序尝试验证用户身份，直到其中一个成功就认证通过。</p><p>启用多个认证方式时，验证顺序如下：</p><p><img src="https://slions.gitee.io/picbed/img/api3.png"></p><p>kubernetes 系统的各组件需要使用 TLS 证书对通信进行加密，需要通过一个权威的机构进行签名许可，也就是ca，ca证书可以用购买的，可以自己通过cfssl来手动创建，也可以使用kubeadm生成的。</p><p>以下是kubeadm自己生成的证书。</p><p>Kubernetes把证书放在了两个文件夹中</p><ul><li>/etc/kubernetes/pki</li><li>/etc/kubernetes/pki/etcd</li></ul><p>具体的证书解释可以看之前写的<a href="/2021/09/23/%E4%BF%AE%E6%94%B9kubeadm%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/" title="修改kubeadm证书过期时间">修改kubeadm证书过期时间</a></p><p><img src="https://slions.gitee.io/picbed/img/api4.png"></p><p>其中可以看到并没有kubelet，kube-scheduler,kube-controller-manager，kube-proxy的证书，是因为kubeadm初始化时已经把证书生成到了/etc/kubernetes下，叫它kubeconfig，就是一个集成了各种安全授权信息的配置文件。</p><p><img src="https://slions.gitee.io/picbed/img/api5.png"></p><p>里面不仅有证书，还有所属的用户（RBAC）对应的权限。</p><p><img src="https://slions.gitee.io/picbed/img/api6.png"></p><p>再研究下node节点怎么认证的：</p><p>当想要加入一个新node节点到集群中时会通过master节点生成一条命令，并到新节点执行，</p><p>比如：</p><p><img src="https://slions.gitee.io/picbed/img/api7.png"></p><p>会由master节点生成一个token再加上经过hash算法生成的ca证书来供节点连接集群。</p><p>这时新节点执行命令后会自动生成kubeconfig文件。</p><p><img src="https://slions.gitee.io/picbed/img/api8.png"></p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权包括六种方式：AlwaysDeny、AlwaysAllow、ABAC、RBAC、Webhook、Node。配置多个授权时，将按顺序检查每个授权，任何一个匹配的授权策略允许或拒绝请求时，则立即返回该决定，并且不会再检查其他授权策略；所有授权策略都没有允许或拒绝时，最终则拒绝该请求。</p><p>通过设置apiserver配置参数（–authorization-mode）启用授权插件。</p><p>授权只依据以下的属性进行判断：</p><p><img src="https://slions.gitee.io/picbed/img/api9.png"></p><p>其中API、Resource、Subresource、Namespace、APIGroup是从请求的URI中解析获取得到。</p><p><img src="https://slions.gitee.io/picbed/img/api10.png"></p><p>当前平台的授权方式是RBAC和NODE，机制为：</p><p><img src="https://slions.gitee.io/picbed/img/api11.png"></p><p><em><strong>RBAC</strong></em></p><p>RBAC包括四种类型：Role、ClusterRole、RoleBinding、ClusterRoleBinding。Role、ClusterRole包含一组权限规则，其中ClusterRole能应用于所有的命名空间（配置中没有命名空间选项），常用于没有命名空间的资源，如nodes；而Role只能包含单个命名空间的权限规则。RoleBinding、ClusterRoleBinding是将角色中定义的权限授予用户、用户组或服务账户。</p><p><em><strong>NODE</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get clusterrole system:node</span><br></pre></td></tr></table></figure><h3 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h3><p>准入控制（Admission Control）是Kubernetes apiserver用于拦截请求的一种方式，运行在认证、授权之后，是权限认证链上的最后一环，对请求API资源对象进行修改（Mutation）和校验（Validating）。 </p><p>在Kubernetes 1.10+之后，用户在使用参数–enable-admission-plugins配置启用准入控制时不需要关注它们的排列顺序，apiserver在注册准入控制插件时，已经定义好了所有插件的执行顺序。</p><p>Admission主要插件列表：</p><p><img src="https://slions.gitee.io/picbed/img/api12.png"></p><h2 id="集群功能模块间的通信"><a href="#集群功能模块间的通信" class="headerlink" title="集群功能模块间的通信"></a>集群功能模块间的通信</h2><p>kubernetes API Server作为集群的核心，负责集群各功能模块之间的通信，集群内各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，通过API Server提供的REST接口（GET\LIST\WATCH方法）来实现，从而实现各模块之间的信息交互。</p><h3 id="kubelet与API-Server交互"><a href="#kubelet与API-Server交互" class="headerlink" title="kubelet与API Server交互"></a>kubelet与API Server交互</h3><p>每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server的Watch接口监听Pod信息，从而对Node机器上的POD进行管理。</p><p>监听信息与kubelet执行动作，当新的POD副本被调度绑定到本节点，则kubelet执行POD对应的容器的创建和启动逻辑。<br>当POD对象被删除，则kubelet删除本节点上相应的POD容器。<br>当修改Pod信息，则kubelet修改本节点的POD容器。</p><h3 id="kube-controller-manager与API-Server交互"><a href="#kube-controller-manager与API-Server交互" class="headerlink" title="kube-controller-manager与API Server交互"></a>kube-controller-manager与API Server交互</h3><p>kube-controller-manager中的Node Controller模块通过API Server提供的Watch接口，实时监控Node的信息，并做相应处理。</p><h3 id="kube-scheduler与API-Server交互"><a href="#kube-scheduler与API-Server交互" class="headerlink" title="kube-scheduler与API Server交互"></a>kube-scheduler与API Server交互</h3><p>Scheduler通过API Server的Watch接口监听到新建Pod副本的信息后，它会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>为了缓解各模块对API Server的访问压力，各功能模块都采用缓存机制来缓存数据，各功能模块定时从API Server获取指定的资源对象信息（LIST/WATCH方法），然后将信息保存到本地缓存，功能模块在某些情况下不直接访问API Server，而是通过访问缓存数据来间接访问API Server。</p><h1 id="apiserver的核心机制"><a href="#apiserver的核心机制" class="headerlink" title="apiserver的核心机制"></a>apiserver的核心机制</h1><h2 id="list-watch"><a href="#list-watch" class="headerlink" title="list-watch"></a><strong>list-watch</strong></h2><p>List-Watch是kubernetes的核心机制。组件kubelet、kube-controller-manager、kube-scheduler需要监控各种资源(pod、service等)的变化，当这些对象发生变化时(add、delete、update)，kube-apiserver会主动通知这些组件。这个过程类似一个发布-订阅系统。</p><p>下图是一个典型的Pod创建过程，在这个过程中，每次当kubectl创建了ReplicaSet对象后，controller-manager都是通过list-watch这种方式得到了最新的ReplicaSet对象，并执行自己的逻辑来创建Pod对象。其他的几个组件，Scheduler/Kubelet也是一样，通过list-watch得知变化并进行处理。</p><p><img src="https://slions.gitee.io/picbed/img/api13.png"></p><p><strong>kube-apiserver对etcd的List-watch并提供watch restful API给其他组件(kubelet、kube-controller-manager、kube-scheduler、kube-proxy)。</strong></p><ul><li>由组件向apiserver而不是etcd发起watch请求，在组件启动时就进行订阅，告诉apiserver需要知道什么数据发生变化。Watch是一个典型的发布-订阅模式。</li><li>组件向apiserver发起的watch请求是可以带条件的，例如，scheduler想要watch的是所有未被调度的Pod，也就是满足Pod.destNode=””的Pod来进行调度操作；而kubelet只关心自己节点上的Pod列表。apiserver向etcd发起的watch是没有条件的，只能知道某个数据发生了变化或创建、删除，但不能过滤具体的值。也就是说对象数据的条件过滤必须在apiserver端而不是etcd端完成。</li><li>list是watch失败，数据太过陈旧后的弥补手段，list本身是一个简单的列表操作，和其它apiserver的增删改操作一样。</li></ul><h1 id="高可用实现"><a href="#高可用实现" class="headerlink" title="高可用实现"></a>高可用实现</h1><p>它被设计为水平扩展，即通过部署更多实例来横向扩展。</p><p>常见的高可用方案是</p><ul><li>keepalived + haproxy</li><li>keepalived + nginx</li><li>公有云LSB</li></ul><p>原理就是利用软件对k8s的6443端口进行负载，再对每台master节点做IP高可用，通过脚本检测后端服务的健康状态。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://blog.csdn.net/karamos/article/details/80121896?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2">Kubernetes API详解</a></p><p><a href="https://www.jianshu.com/p/e9cb0118ec1e">apiserver之list-watch篇</a></p><p><a href="https://baijiahao.baidu.com/s?id=1634394182029344798&wfr=spider&for=pc">Kubernetes API 安全机制详解</a></p><p>《kubernetes权威指南》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;apiserver作用&quot;&gt;&lt;a href=&quot;#apiserver作用&quot; class=&quot;headerlink&quot; title=&quot;apiserver作用&quot;&gt;&lt;/a&gt;apiserver作用&lt;/h1&gt;&lt;p&gt;其对外暴露了Kubernetes API。它是的 Kubernete</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>修改kubeadm证书过期时间</title>
    <link href="https://slions.github.io/2021/09/23/%E4%BF%AE%E6%94%B9kubeadm%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
    <id>https://slions.github.io/2021/09/23/%E4%BF%AE%E6%94%B9kubeadm%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/</id>
    <published>2021-09-23T14:20:58.000Z</published>
    <updated>2021-10-03T04:53:24.512Z</updated>
    
    <content type="html"><![CDATA[<p>使用kubeadm创建完Kubernetes集群后, 默认会在/etc/kubernetes/pki目录下存放集群中需要用到的证书文件, 整体结构如下图所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/etc/kubernetes/pki# tree</span><br><span class="line">.</span><br><span class="line">|-- apiserver.crt</span><br><span class="line">|-- apiserver-etcd-client.crt</span><br><span class="line">|-- apiserver-etcd-client.key</span><br><span class="line">|-- apiserver.key</span><br><span class="line">|-- apiserver-kubelet-client.crt</span><br><span class="line">|-- apiserver-kubelet-client.key</span><br><span class="line">|-- ca.crt</span><br><span class="line">|-- ca.key</span><br><span class="line">|-- etcd</span><br><span class="line">|   |-- ca.crt</span><br><span class="line">|   |-- ca.key</span><br><span class="line">|   |-- healthcheck-client.crt</span><br><span class="line">|   |-- healthcheck-client.key</span><br><span class="line">|   |-- peer.crt</span><br><span class="line">|   |-- peer.key</span><br><span class="line">|   |-- server.crt</span><br><span class="line">|   `-- server.key</span><br><span class="line">|-- front-proxy-ca.crt</span><br><span class="line">|-- front-proxy-ca.key</span><br><span class="line">|-- front-proxy-client.crt</span><br><span class="line">|-- front-proxy-client.key</span><br><span class="line">|-- sa.key</span><br><span class="line">`-- sa.pub</span><br></pre></td></tr></table></figure><h1 id="证书分组"><a href="#证书分组" class="headerlink" title="证书分组"></a>证书分组</h1><p>Kubernetes把证书放在了两个文件夹中</p><ul><li>/etc/kubernetes/pki</li><li>/etc/kubernetes/pki/etcd</li></ul><h2 id="Kubernetes-集群根证书"><a href="#Kubernetes-集群根证书" class="headerlink" title="Kubernetes 集群根证书"></a>Kubernetes 集群根证书</h2><p>Kubernetes 集群根证书CA(Kubernetes集群组件的证书签发机构)</p><ul><li><p>/etc/kubernetes/pki/ca.crt</p></li><li><p>/etc/kubernetes/pki/ca.key</p></li></ul><p>以上这组证书为签发其他Kubernetes组件证书使用的根证书, 可以认为是Kubernetes集群中证书签发机构之一。</p><p>由此根证书签发的证书有:</p><ol><li>kube-apiserver 组件持有的服务端证书</li></ol><ul><li><p>/etc/kubernetes/pki/apiserver.crt</p></li><li><p>/etc/kubernetes/pki/apiserver.key</p></li></ul><ol start="2"><li>kubelet 组件持有的客户端证书, 用作 kube-apiserver 主动向 kubelet 发起请求时的客户端认证</li></ol><ul><li><p>/etc/kubernetes/pki/apiserver-kubelet-client.crt</p></li><li><p>/etc/kubernetes/pki/apiserver-kubelet-client.key</p></li></ul><h2 id="汇聚层证书"><a href="#汇聚层证书" class="headerlink" title="汇聚层证书"></a>汇聚层证书</h2><p>kube-apiserver 的另一种访问方式就是使用 kubectl proxy 来代理访问, 而该证书就是用来支持SSL代理访问的. 在该种访问模式下, 我们是以http的方式发起请求到代理服务的, 此时, 代理服务会将该请求发送给 kube-apiserver, 在此之前, 代理会将发送给 kube-apiserver 的请求头里加入证书信息。</p><p>kube-apiserver 代理根证书(客户端证书)</p><p>用在requestheader-client-ca-file配置选项中, kube-apiserver 使用该证书来验证客户端证书是否为自己所签发</p><ul><li>/etc/kubernetes/pki/front-proxy-ca.crt</li><li>/etc/kubernetes/pki/front-proxy-ca.key</li></ul><p>由此根证书签发的证书只有一组:</p><p>代理层(如汇聚层aggregator)使用此套代理证书来向 kube-apiserver 请求认证</p><p>代理端使用的客户端证书, 用作代用户与 kube-apiserver 认证</p><ul><li>/etc/kubernetes/pki/front-proxy-client.crt</li><li>/etc/kubernetes/pki/front-proxy-client.key</li></ul><h2 id="etcd-集群根证书"><a href="#etcd-集群根证书" class="headerlink" title="etcd 集群根证书"></a>etcd 集群根证书</h2><p>etcd集群所用到的证书都保存在/etc/kubernetes/pki/etcd这路径下, 很明显, 这一套证书是用来专门给etcd集群服务使用的, 设计以下证书文件</p><p>etcd 集群根证书CA(etcd 所用到的所有证书的签发机构)</p><ul><li>/etc/kubernetes/pki/etcd/ca.crt</li><li>/etc/kubernetes/pki/etcd/ca.key</li></ul><p>由此根证书签发机构签发的证书有:</p><ol><li>etcd server 持有的服务端证书</li></ol><ul><li><p>/etc/kubernetes/pki/etcd/server.crt</p></li><li><p>/etc/kubernetes/pki/etcd/server.key</p></li></ul><ol start="2"><li>peer 集群中节点互相通信使用的客户端证书</li></ol><ul><li>/etc/kubernetes/pki/etcd/peer.crt</li><li>/etc/kubernetes/pki/etcd/peer.key</li></ul><ol start="3"><li>pod 中定义 Liveness 探针使用的客户端证书</li></ol><ul><li><p>/etc/kubernetes/pki/etcd/healthcheck-client.crt</p></li><li><p>/etc/kubernetes/pki/etcd/healthcheck-client.key</p></li></ul><blockquote><p>kubeadm 部署的 Kubernetes 集群是以 pod 的方式运行 etcd 服务的, 在该 pod 的定义中, 配置了 Liveness 探活探针。</p><p>当 describe etcd 的 pod 时, 会看到如下一行配置:</p><p>Liveness:       exec [/bin/sh -ec ETCDCTL_API=3 etcdctl –endpoints=https://[127.0.0.1]:2379 –cacert=/etc/kubernetes/pki/etcd/ca.crt –cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt –key=/etc/kubernetes/pki/etcd/healthcheck-client.key get foo] delay=15s timeout=15s period=10s #success=1 #failure=8</p></blockquote><ol start="4"><li>配置在 kube-apiserver 中用来与 etcd server 做双向认证的客户端证书</li></ol><ul><li>/etc/kubernetes/pki/apiserver-etcd-client.crt</li><li>/etc/kubernetes/pki/apiserver-etcd-client.key</li></ul><h2 id="Serveice-Account秘钥"><a href="#Serveice-Account秘钥" class="headerlink" title="Serveice Account秘钥"></a>Serveice Account秘钥</h2><p>最后介绍的这组”证书”其实不是证书, 而是一组秘钥，这组的密钥对儿仅提供给 kube-controller-manager 使用. kube-controller-manager 通过 sa.key 对 token 进行签名, master 节点通过公钥 sa.pub 进行签名的验证。</p><ul><li>/etc/kubernetes/pki/sa.key</li><li>/etc/kubernetes/pki/sa.pub</li></ul><p>因为 kubeadm 创建的集群, kube-proxy 是以 pod 形式运行的, 在 pod 中, 直接使用 service account 与 kube-apiserver 进行认证, 此时就不需要再单独为 kube-proxy 创建证书了。</p><blockquote><p>如果 kube-proxy 是以守护进程的方式直接运行在宿主机的, 那么就需要为它创建一套证书了。创建的方式也很简单, 直接使用上面第一条提到的 Kubernetes 集群根证书 进行签发就可以了(注意CN和O的设置)。</p></blockquote><h1 id="证书过期"><a href="#证书过期" class="headerlink" title="证书过期"></a>证书过期</h1><p>利用kubeadm安装后发现ca的证书过期时间是十年，但是由ca签发的如apiserver.crt的证书过期时间都是一年，这就尴尬了。</p><ol><li>如果已经创建后的集群到了一年执行kubectl命令会出现：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: x509: certificate has expired or is not yet valid</span><br></pre></td></tr></table></figure><p>此时需要手动更新证书。</p><ol start="2"><li>如果我们还没开始搭建，在搭建集群前我们可以直接修改相关源码解决这个问题。</li></ol><p><strong>拉取kubernetes的源码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/kubernetes/kubernetes.git</span><br></pre></td></tr></table></figure><p><strong>切换版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd kubernetes &amp;&amp; git checkout -b remotes/origin/release-1.11  v1.11.0</span><br></pre></td></tr></table></figure><p><strong>安装Go环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.10.2.linux-amd64.tar.gz</span><br><span class="line">tar zxvf go1.10.2.linux-amd64.tar.gz  -C  /usr/local </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">编辑/etc/profile文件添加如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">go setting</span></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile 生效</span><br><span class="line"> </span><br><span class="line">验证：</span><br><span class="line">go version</span><br><span class="line">go version go1.10.2 linux/amd64</span><br></pre></td></tr></table></figure><p><strong>修改源码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd  ~/kubernetes/staging/src/k8s.io/client-<span class="keyword">go</span>/util/cert/</span><br><span class="line">#编辑 cert.<span class="keyword">go</span>文件（<span class="number">107</span>行和<span class="number">180</span>行）</span><br><span class="line">@@<span class="number">107</span>@@</span><br><span class="line">-    NotAfter:     time.Now().Add(duration365d).UTC(),</span><br><span class="line">+    NotAfter:     time.Now().Add(duration365d * <span class="number">10</span>).UTC(),</span><br><span class="line">@@<span class="number">180</span>@@</span><br><span class="line">-    NotAfter:  time.Now().Add(time.Hour * <span class="number">24</span> * <span class="number">365</span>),</span><br><span class="line">+    NotAfter:  time.Now().Add(time.Hour * <span class="number">24</span> * <span class="number">3650</span>),</span><br></pre></td></tr></table></figure><p><strong>编译Go</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /kubernetes/ &amp;&amp; make WHAT=cmd/kubeadm</span><br></pre></td></tr></table></figure><p>查看编译后的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll ~/kubernetes/_output/bin/kubeadm</span><br><span class="line">注意看时间</span><br></pre></td></tr></table></figure><p><strong>替换kubeadm</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/kubeadm /usr/bin/kubeadm_backup</span><br><span class="line">ln -s  ~/kubernetes/_output/bin/kubeadm /usr/bin/kubeadm</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用kubeadm创建完Kubernetes集群后, 默认会在/etc/kubernetes/pki目录下存放集群中需要用到的证书文件, 整体结构如下图所示:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="kubernetes" scheme="https://slions.github.io/categories/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="https://slions.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>我是一个线程（转载）</title>
    <link href="https://slions.github.io/2021/09/19/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://slions.github.io/2021/09/19/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</id>
    <published>2021-09-19T08:14:03.000Z</published>
    <updated>2021-09-30T08:43:51.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自IBM前架构师刘欣</p></blockquote><h1 id="初生牛犊"><a href="#初生牛犊" class="headerlink" title="初生牛犊"></a>初生牛犊</h1><p>我是一个线程，我一出生就被编了个号：<code>0x3704</code>，然后被领到一个昏暗的屋子里，在这里我发现了很多和我一模一样的同伴。</p><p>我身边的同伴<code>0x6900</code> 待的时间比较长，他带着沧桑的口气对我说：“我们线程的宿命就是处理包裹。把包裹处理完以后还得马上回到这里，否则可能永远回不来了。”</p><p>我一脸懵懂，“包裹，什么包裹？”</p><p>“不要着急，马上你就会明白了，我们这里是不养闲人的。”</p><p>果然，没多久，屋子的门开了， 一个面貌凶恶的家伙吼道：“<code>0x3704</code>,出来！”</p><p>我一出来就被塞了一个沉甸甸的包裹，上面还附带着一个写满了操作步骤的纸。 </p><p>“快去，把这个包裹处理了。”</p><p>“去哪儿处理？”</p><p>“跟着指示走，先到就绪车间。”</p><p>果然，地上有指示箭头，跟着它来到了一间明亮的大屋子，这里已经有不少线程了，大家都很紧张，好像时刻准备着往前冲。</p><p>我刚一进来，就听见广播说：“<code>0x3704</code>，进入车间。”</p><p>我赶紧往前走，身后有很多人议论。</p><p>“他太幸运了，刚进入就绪状态就能运行。”</p><p>“是不是有关系？”</p><p>“不是，你看人家的优先级多高啊，唉！”</p><p>前边就是车间，这里简直是太美了，怪不得老线程总是唠叨着说：“要是能一直待在这里就好了。”</p><p>这里空间大，视野好，空气清新，鸟语花香，还有很多从来没见过的人，像服务员一样等着为我服务。</p><p>他们也都有编号，更重要的是每个人还有个标签，上面写着：硬盘、数据库、内存、网卡……</p><p>我现在理解不了，看看操作步骤吧。</p><p><strong>第一步：从包裹中取出参数。</strong></p><p>打开包裹，里边有个HttpRequest对象，可以取到userName、 password两个参数。</p><p><strong>第二步：执行登录操作。</strong></p><p>奥，原来是有人要登录啊，我把userName、password交给数据库服务员，他拿着数据，慢腾腾地走了。</p><p>他怎么这么慢？不过我是不是正好可以在车间里多待一会儿？反正也没法执行第三步。</p><p>就在这时，车间里的广播响了：“<code>0x3704</code>，我是CPU，记住你正在执行的步骤，然后马上带着包裹离开！”</p><p>我慢腾腾地开始收拾。</p><p>“快点，别的线程马上就要进来了。”</p><p>离开这个车间，又来到一个大屋子，这里有很多线程在慢腾腾地喝茶，打牌。</p><p>“哥们，你们没事干了？”</p><p>“你新来的吧，你不知道我在等数据库服务员给我数据啊！据说他们比我们慢好几十万倍，在这里好好歇吧。”</p><p>“啊？ 这么慢！我这里有人在登录系统，能等这么长时间吗？”</p><p>“放心，你没听说过人间一天，CPU一年吗？我们这里是用纳秒、毫秒计时的，人间等待一秒，相当于我们好几天呢，来得及。”</p><p>干脆睡一会吧。不知道过了多久，大喇叭又开始广播了：“<code>0x3704</code>，你的数据来了，快去执行！”</p><p>我转身就往CPU车间跑，发现这里的门只出不进！</p><p>后面传来阵阵哄笑声：“果然是新人，不知道还得去就绪车间等。”</p><p>于是赶紧到就绪车间，这次没有那么好运了，等了好久才被再次叫进CPU车间。</p><p>在等待的时候，我听见有人小声议论：</p><p>“听说了吗，最近有个线程被kill掉了。”</p><p>“为啥啊？”</p><p>“这家伙赖在CPU车间不走，把CPU利用率一直搞成100%，后来就被kill掉了。”</p><p>“Kill掉以后弄哪儿去了？”</p><p>“可能被垃圾回收了吧。”</p><p>我心里打了个寒噤，赶紧接着处理，剩下的动作快多了，第二步登录成功。</p><p><strong>第三步：构建登录成功后的主页。</strong></p><p>这一步有点费时，因为有很多HTML需要处理，不知道代码谁写的，处理起来很烦人。</p><p>我正在紧张的制作HTML呢， CPU又开始叫了：</p><p>“<code>0x3704</code>，我是CPU ，记住你正在执行的步骤，然后马上带着包裹离开！”</p><p>“为啥啊？”</p><p>“每个线程只能在CPU上运行一段时间，到了时间就得让别人用了，你去就绪车间待着，等着叫你吧。”</p><p>就这样，我一直在“就绪——运行”这两个状态中不知道轮转了多少次， 终于按照步骤清单把工作做完了。</p><p>最后顺利地把包含html的包裹发了回去。至于登录以后干什么事儿，我就不管了。马上就要回到我那昏暗的房间了，真有点舍不得这里。不过相对于有些线程，我还是幸运的，他们运行完以后就被彻底地销毁了，而我还活着！</p><p>回到了小黑屋，老线程<code>0x6900</code>问：</p><p>“怎么样？第一天有什么感觉？”</p><p>“我们的世界规则很复杂，首先你不知道什么时候会被挑中执行；第二，在执行的过程中随时可能被打断，让出CPU车间；第三，一旦出现硬盘、数据库这样耗时的操作，也得让出CPU去等待；第四，就是数据来了，你也不一定马上执行，还得等着CPU挑选。”</p><p>“小伙子理解的不错啊。”</p><p>“我不明白为什么很多线程执行完任务就死了，为什么咱们还活着？”</p><p>“你还不知道？长生不老是我们的特权！我们这里有个正式的名称，叫作<strong>线程池</strong>！”</p><h1 id="渐入佳境"><a href="#渐入佳境" class="headerlink" title="渐入佳境"></a>渐入佳境</h1><p>平淡的日子就这么一天天地过去，作为一个线程，我每天的生活都是取包裹、处理包裹，然后回到我们昏暗的家：线程池。</p><p>有一天我回来的时候，听到有个兄弟说，今天要好好休息下，明天就是最疯狂的一天。我看了一眼日历，明天是 11月11号。 </p><p>果然，零点刚过，不知道那些人类怎么了，疯狂地投递包裹，为了应付蜂拥而至的海量包裹，线程池里没有一个人能闲下来，全部出去处理包裹，CPU车间利用率超高，硬盘在嗡嗡转，网卡疯狂的闪，即便如此，还是处理不完，堆积如山。</p><p>我们也没有办法，实在是太多太多了，这些包裹中大部分都是浏览页面，下订单，买、买、买。</p><p>不知道过了多久，包裹山终于慢慢地消失了。终于能够喘口气，我想我永远都不会忘记这一天。</p><p>通过这个事件，我明白了我所处的世界：这是一个电子商务的网站！</p><p>我每天的工作就是处理用户的登录，浏览，购物车，下单，付款。</p><p>我问线程池的元老<code>0x6900</code>：“我们要工作到什么时候？”</p><p>“要一直等到系统重启的那一刻。”<code>0x6900</code>说。</p><p>“那你经历过系统重启吗？”</p><p>“怎么可能？系统重启就是我们的死亡时刻，也就是世界末日，一旦重启，整个线程池全部销毁，时间和空间全部消失，一切从头再来。”</p><p>“那什么时候会重启？”</p><p>“这就不好说了，好好享受眼前的生活吧……”</p><p>其实生活还是丰富多彩的，我最喜欢的包裹是上传图片，由于网络慢，所以能在就绪车间、CPU车间待很长很长时间，可以认识很多好玩的线程。</p><p>比如说上次认识了memecached 线程，他对我说在他的帮助下缓存了很多的用户数据，还是分布式的！很多机器上都有！</p><p>我问他：“怪不得后来的登录操作快了那么多，原来是不再从数据库取数据了你那里就有啊，哎对了你是分布式的你去过别的机器没有？”</p><p>他说：“怎么可能！我每次也只能通过网络往那个机器发送一个GET、PUT命令才存取数据而已，别的一概不知。”</p><p>再比如说上次在等待的时候遇到了数据库连接的线程，我才知道他那里也是一个连接池，和我们的线程池几乎一模一样。</p><p>他告诉我：“有些包裹太变态了，竟然查看一年的订单数据，简直把我累死了。”</p><p>我说：“拉倒吧你，你那是纯数据，你把数据传给我以后，我还得组装成HTML，工作量不知道比你大多少倍。”</p><p>他建议我：“你一定要和memecached搞好关系，直接从他那儿拿数据，尽量少直接调用数据库，这样我们JDBC connection也能活得轻松点。”</p><p>我欣然接纳：“好啊好啊，关键是你得提前把数据搞到缓存啊，要不然我先问一遍缓存，没有数据，我这不还得找你吗？”</p><p>生活就是这样，如果你自己不找点乐子，还有什么意思？</p><h1 id="虎口脱险"><a href="#虎口脱险" class="headerlink" title="虎口脱险"></a>虎口脱险</h1><p>前几天我遇到一个可怕的事情，差一点死在外边，回不了线程池了。其实这次遇险我应该能够预想得到才对，真是太大意了。</p><p>那天我处理了一些从http发来的存款和取款的包裹，老线程<code>0x6900</code>特意嘱咐我：“处理这些包裹的时候一定要特别小心，你必须先获得一把锁，在对账户存款或取款的时候一定要把账户锁住，要不然别的线程就会在你等待的时候趁虚而入，搞破坏，我年轻那会儿很毛糙，就捅了篓子。”</p><p>为了“恐吓”我， 好心的<code>0x6900</code>还给了我两个表格：</p><p><strong>(1)没有加锁的情况</strong></p><p><img src="https://slions.gitee.io/picbed/img/p1.png"></p><p><strong>(2)加锁的情况</strong></p><p><img src="https://slions.gitee.io/picbed/img/p2.png"></p><p>我看得胆颤心惊，原来不加锁会带来这么严重的事故。从此以后看到存款、取款的包裹就倍加小心，还好没有出过事故。</p><p>今天我收到的一个包裹是转账，从某著名演员的账户给某著名导演的账户转钱，具体是谁我就不透漏了，数额可真是不小。</p><p>我按照老线程的吩咐，肯定要加锁啊，先对著名演员的账户加锁，再对著名导演的账户加锁。</p><p>可我万万没想到的是，还有一个线程，对，就是<code>0x7954</code>, 竟然同时在从这个导演的账户往这个演员的账户转账。 </p><p>于是乎，就出现了这么个情况：</p><p><img src="https://slions.gitee.io/picbed/img/p3.png"></p><p>刚开始我还不知道什么情况，一直坐在等待车间傻等，可是等的时间太长了，长达几十秒！我可从来没有经历过这样的事件。</p><p>这时候我就看到了线程<code>0x7954</code> , 他悠闲地坐在那里喝咖啡，我和他聊了起来：</p><p>“哥们，我看你已经喝了8杯咖啡了，怎么还不去干活？”</p><p>“你不喝了9杯茶了吗？”<code>0x7954</code>回敬道。</p><p>“我在等一个锁，不知道哪个孙子一直不释放！”</p><p>“我也在等锁啊，我要是知道哪个孙子不释放锁我非揍死他不可！”<code>0x7954</code>毫不示弱。</p><p>我偷偷地看了一眼，这家伙怀里不就抱着我正等的某导演的锁吗？</p><p>很明显，<code>0x7954</code>也发现了我正抱着他正在等待的锁。</p><p>很快我们两个就吵了起来，互不相让：</p><p>  “把你的锁先给我，让我先做完！”</p><p>“不行，从来都是做完工作才释放锁，现在绝对不能给你！”</p><p>从争吵到打起来，就那么几秒钟的事儿。更重要的是，我们俩不仅仅持有这个著名导演和演员的锁，还有很多其他的锁，导致等待的线程越来越多，围观的人们把屋子都挤满了。最后事情真的闹大了，我从来没见过的终极大boss“操作系统”也来了。大Boss毕竟见多识广，他看了一眼，哼了一声，很不屑地说：</p><p>“又出现死锁了。”</p><p>“你们俩要Kill掉一个，来吧，过来抽签。”</p><p>这一下子把我给吓尿了，这么严重啊！我战战兢兢地抽了签，打开一看，是个“活”字。唉，小命终于保住了。</p><p>可怜的<code>0x7954</code>被迫交出了所有的资源以后，很不幸地被kill掉，消失了。我拿到了导演的锁，可以开始干活了。大Boss“操作系统”如一阵风似的消失了，身后只传来他的声音：</p><p>“记住，我们这里导演&gt;演员，无论任何情况都要先获得导演的锁。”</p><p>由于这里不仅仅只有导演和演员，还有很多其他人，大Boss留下了一个表格， 里边是个算法，用来计算资源的大小，计算出来以后，永远按照从大到小的方式来获得锁：</p><p><img src="https://slions.gitee.io/picbed/img/p4.png"></p><p>我回到线程池，大家都知道了我的历险，围着我问个不停。</p><p>凶神恶煞的线程调度员把大Boss的算法贴到了墙上。</p><p>每天早上，我们都得像无节操的房屋中介、美容美发店的服务员一样，站在门口，像被耍猴一样大声背诵：</p><p>“<strong>多个资源加锁要牢记，一定要按Boss的算法比大小，然后从最大的开始加锁。</strong>”</p><h1 id="江湖再见"><a href="#江湖再见" class="headerlink" title="江湖再见"></a>江湖再见</h1><p>又过了很多天，我和其他线程们发现了一个奇怪的事情：包裹的处理越来越简单，不管任何包裹，不管是登录、浏览、存钱……处理的步骤都是一样的, 返回一个固定的html页面。</p><p>有一次我偷偷地看了一眼，上面写着：“本系统将于今晚 00:00 至4:00 进行维护升级， 给您带来的不便我们深感抱歉！”</p><p>我去告诉了老线程<code>0x6904</code>,他叹了一口气说：</p><p>“唉，我们的生命也到头了，看来马上就要重启系统，我们就要消失了，再见吧兄弟。”</p><p>系统重启的那一刻终于到来了。我看到屋子里的东西一个个的不见了，等待车间、就绪车间，甚至CPU车间都慢慢地消失了。我身边的线程兄弟也越来越少，最后只剩我自己了。</p><p>我在空旷的原野上大喊：“还有人吗？”</p><p>无人应答。</p><p>我们这一代线程池完成了使命……</p><p>不过下一代线程池即将重生！</p><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="https://mp.weixin.qq.com/s/-BMCUuIWYE3O_oC3ZNNJRg">https://mp.weixin.qq.com/s/-BMCUuIWYE3O_oC3ZNNJRg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自IBM前架构师刘欣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;初生牛犊&quot;&gt;&lt;a href=&quot;#初生牛犊&quot; class=&quot;headerlink&quot; title=&quot;初生牛犊&quot;&gt;&lt;/a&gt;初生牛犊&lt;/h1&gt;&lt;p&gt;我是一个线程，我一出生就被</summary>
      
    
    
    
    <category term="好文推荐" scheme="https://slions.github.io/categories/%E5%A5%BD%E6%96%87%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="linux" scheme="https://slions.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git原理及常用命令</title>
    <link href="https://slions.github.io/2021/09/10/git%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://slions.github.io/2021/09/10/git%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-09-10T10:40:15.000Z</published>
    <updated>2021-09-23T08:00:18.865Z</updated>
    
    <content type="html"><![CDATA[<p>关于git的使用介绍网上也比较多了，尤其是廖雪峰大佬的git教程与苏玲大佬的git网课都是git入门的经典。写这篇文章主要是想通过图示化配合文字的方式，加深记忆，也在日常工作中起到速查的作用。</p><h1 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h1><blockquote><p>Git 是一个<a href="https://git-scm.com/about/free-and-open-source">免费的开源</a> 分布式版本控制系统，旨在快速高效地处理从小到大的所有项目。这是git官网对其的描述。</p></blockquote><p>在没有出现版本控制系统前，常见的作法是在一台服务器上把文件共享出来，每个成员各自创个文件夹，以目录拷贝的方式来区别不同的成员开发的东西以及不同的版本，缺点显而易见，公共文件容易被覆盖，代码集成效率低下。慢慢的产生了cvs和svn之类的集中式版本管理系统，其通过一个版本管理服务器来记录每个文件和文件夹的版本演变历史，也有分支管理的功能，集成效率有了明显的提高，但是版本库都集中存放在了中央服务器，干活时需要先从中央服务器拉取最新的版本，然后在本地开发，最后推送到服务器，没网是寸步难行，性能和效率是最大的问题。后来linux创始人linus写出了分布式的版本控制系统——git，其去中心化的思想，让每个客户端都相关于是一个完整的版本库，加上增强性的分支管理能力，使性能和效率有了很大提升，目前已经成为了市场上主流的版本控制系统，伴随着git的日趋成熟，也出现了很多基于git的web端产品，比如github和gitlab。</p><h1 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h1><p>不同操作系统的git安装方式可以参考官方文档<br><a href="https://git-scm.com/downloads">git安装</a></p><h1 id="git核心原理"><a href="#git核心原理" class="headerlink" title="git核心原理"></a>git核心原理</h1><h2 id="版本管理实现-git"><a href="#版本管理实现-git" class="headerlink" title="版本管理实现.git"></a>版本管理实现.git</h2><blockquote><p>git相比svn等工具具备最优的存储能力，也可以实现在没有远端中心服务器的情况下，在本地具备版本管理能力。</p></blockquote><p>当我们使用<code>git init</code>后会在当前目录生成一个<code>.git</code>的隐藏目录，此目录下的各种文件就是git核心的一些东西。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git init</span><br><span class="line">初始化空的 Git 版本库于 /home/first_git/.git/</span><br><span class="line">[root@slions_pc1 first_git]# tree .git/</span><br><span class="line">.git/</span><br><span class="line">├── branches</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure><h3 id="git-config文件"><a href="#git-config文件" class="headerlink" title=".git/config文件"></a>.git/config文件</h3><p>顾名思义，config文件存储的是当前仓库的配置信息，如果什么也没有配置时，它长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br></pre></td></tr></table></figure><p>修改此文件的配置会立即生效，当然推荐做法是使用命令<code>git config --local</code>来配置。</p><p>在多人协助时，一定要配置<code>user.name</code>与<code>user.email</code>,这样才能区别用户。</p><p>如下示例，我配置当前仓库的用户与邮箱，可以看到配置完<code>.git/config</code>也更新了信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git config --global user.name slions</span><br><span class="line">[root@slions_pc1 first_git]# git config --local user.email slions@163.com</span><br><span class="line">[root@slions_pc1 first_git]# cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[user]</span><br><span class="line">        email = slions@163.com</span><br><span class="line">        name = slions</span><br></pre></td></tr></table></figure><p>后续我们在此仓库中提交的用户就都是<code>slions</code>了。</p><p>使用<code>git config --global</code>可以配置全局的git配置，也就是说如果本地仓库没有设置专属配置时，就会以全局配置作为默认配置，相应的全局也有config文件，linux的在<code>/root/.gitconfig</code>,windows在用户宿主目录下的<code>~/.gitconfig </code>。</p><h3 id="git-objects目录"><a href="#git-objects目录" class="headerlink" title=".git/objects目录"></a>.git/objects目录</h3><blockquote><p>存储是版本控制系统中非常重要的技术点，特别是当各种文档频繁的进行变更与回退，如果没有一个好的存储系统作为支撑，那版本库会随着日积月累越来越大，性能和效率都会变差。</p></blockquote><blockquote><p>git使用SHA-1的Hash算法来记录与存储文件，不管输入数据的数据量有多大，使用同一个哈希算法，得到的加密结果长度固定；哈希算法确定，输入数据确定，输出结果保证不变。</p></blockquote><p>git是一个内容寻址文件系统，通过hash算法得到文件的“指纹”（40位16进制数字），通过文件指纹存取数据，存取的数据都在objects目录。</p><p>object目录下有3种类型的数据：</p><ul><li>Commit</li><li>Tree</li><li>Blob    </li></ul><p>在使用git的过程中，创建的提交会被存储为<code>Commit</code>类型的文件，文件夹会被存储为<code>Tree</code>类型的文件，文件会被存储为<code>Blob</code>类型的文件。其中pack目录会存储的是一些打包文件（Git 往磁盘保存对象时默认使用的格式叫松散对象 (loose object) 格式，Git 时不时地将这些对象打包至一个叫 packfile 的二进制文件以节省空间并提高效率）。</p><p><strong>示例说明：</strong></p><p>此时我们位于默认的master分支，工作区与暂存区都是干净的，创建一个hello.file文件，查看<code>.git/objects</code>无任何变化，因为hello.file还没被git纳管。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 位于分支 master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 初始提交</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash">无文件要提交（创建/拷贝文件并使用 <span class="string">&quot;git add&quot;</span> 建立跟踪）</span></span><br><span class="line">[root@slions_pc1 first_git]# ls</span><br><span class="line">[root@slions_pc1 first_git]# echo hello world! &gt;&gt; hello.file</span><br><span class="line">[root@slions_pc1 first_git]# cat hello.file</span><br><span class="line">hello world!</span><br><span class="line">[root@slions_pc1 first_git]# tree .git</span><br><span class="line">.git</span><br><span class="line">├── config</span><br><span class="line">...</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">9 directories, 14 files</span><br></pre></td></tr></table></figure><p>添加hello.file到暂存区，可以看到git/objects中多了一个目录与文件，拼起来正是hello.file的hash值，使用<code>git cat-file -p</code>查看文件的内容就是hello.file的内容，使用<code>git cat-file -t</code>查看其类型为blob。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git add .</span><br><span class="line">[root@slions_pc1 first_git]# tree .git</span><br><span class="line">.git</span><br><span class="line">├── config</span><br><span class="line">...</span><br><span class="line">├── objects</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── 423896973644771497bdc03eb99d5281615b51</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">10 directories, 15 files</span><br><span class="line">[root@slions_pc1 first_git]# git hash-object hello.file</span><br><span class="line">a0423896973644771497bdc03eb99d5281615b51</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p a0423896973644771497bdc03eb99d5281615b51</span><br><span class="line">hello world!</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t a0423896973644771497bdc03eb99d5281615b51</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><p>创建一个文件夹试试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# mkdir mydir</span><br><span class="line">[root@slions_pc1 first_git]# echo &quot;这个文件处于mydir目录中&quot; &gt; mydir/test.file</span><br><span class="line">[root@slions_pc1 first_git]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 位于分支 master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 初始提交</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 要提交的变更：</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   （使用 <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> 撤出暂存区）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#       新文件：    hello.file</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 未跟踪的文件:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   （使用 <span class="string">&quot;git add &lt;file&gt;...&quot;</span> 以包含要提交的内容）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#       mydir/</span></span></span><br><span class="line">[root@slions_pc1 first_git]# git add .</span><br><span class="line">[root@slions_pc1 first_git]# tree .git/</span><br><span class="line">.git/</span><br><span class="line">├── config</span><br><span class="line">...</span><br><span class="line">├── objects</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── 423896973644771497bdc03eb99d5281615b51</span><br><span class="line">│   ├── b4</span><br><span class="line">│   │   └── 742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">11 directories, 16 files</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p b4742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">这个文件处于mydir目录中</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t b4742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><p>提交看看效果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# tree .git/</span><br><span class="line">.git/</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">...</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── 423896973644771497bdc03eb99d5281615b51</span><br><span class="line">│   ├── af</span><br><span class="line">│   │   └── 5f8664975db42eb0780392064254516a5386ae</span><br><span class="line">│   ├── b4</span><br><span class="line">│   │   └── 742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">│   ├── c6</span><br><span class="line">│   │   └── 98f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">│   ├── e9</span><br><span class="line">│   │   └── a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure><p>将hello.file与mydir/test.file提交后，发现在objects下多了3个文件，分别是<code>af/5f8664975db42eb0780392064254516a5386ae</code>，<code>c6/98f655405d32c8d5130f3cd5393dfa5897275d</code>,<code>e9/a3da963bf7298300b2130a64315799b6baef31</code></p><p>查看其内容与类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git cat-file -p af5f8664975db42eb0780392064254516a5386ae</span><br><span class="line">100644 blob b4742fdeca5b697ffdf5b0e0d1c7b74085f36bca    test.file</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t af5f8664975db42eb0780392064254516a5386ae</span><br><span class="line">tree</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p c698f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">100644 blob a0423896973644771497bdc03eb99d5281615b51    hello.file</span><br><span class="line">040000 tree af5f8664975db42eb0780392064254516a5386ae    mydir</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t c698f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">tree</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p e9a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">tree c698f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">author slions &lt;slions@163.com&gt; 1631430170 +0800</span><br><span class="line">committer slions &lt;slions@163.com&gt; 1631430170 +0800</span><br><span class="line"></span><br><span class="line">我的第一次提交,创建hello.file与mydir/test.file文件</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t e9a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">commit</span><br></pre></td></tr></table></figure><p>可以发现，objects中commit类型的文件内容与<code>git log</code>的内容如出一辙，且commit ID一致。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git log</span><br><span class="line">commit e9a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">Author: slions &lt;slions@163.com&gt;</span><br><span class="line">Date:   Sun Sep 12 15:02:50 2021 +0800</span><br><span class="line"></span><br><span class="line">    我的第一次提交,创建hello.file与mydir/test.file文件</span><br></pre></td></tr></table></figure><p>再创建个提交来观察下变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# echo test2 &gt;   mydir/test2.file</span><br><span class="line">[root@slions_pc1 first_git]# git add .</span><br><span class="line">[root@slions_pc1 first_git]# git commit -m &#x27;第二次提交，创建mydir/test2.file文件&#x27;</span><br><span class="line">[master 48acad0] 第二次提交，创建mydir/test2.file文件</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 mydir/test2.file</span><br><span class="line">[root@slions_pc1 first_git]# tree .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">├── 18</span><br><span class="line">│   └── 0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">├── 48</span><br><span class="line">│   └── acad07a1446a569f8fe2ea06ef15973291561b</span><br><span class="line">├── 71</span><br><span class="line">│   └── bac679881c174b509333379601f4096220809b</span><br><span class="line">├── 77</span><br><span class="line">│   └── 8da9f040bedfbf92188332f2d0097cfd1b4fb2</span><br><span class="line">├── a0</span><br><span class="line">│   └── 423896973644771497bdc03eb99d5281615b51</span><br><span class="line">├── af</span><br><span class="line">│   └── 5f8664975db42eb0780392064254516a5386ae</span><br><span class="line">├── b4</span><br><span class="line">│   └── 742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">├── c6</span><br><span class="line">│   └── 98f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">├── e9</span><br><span class="line">│   └── a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure><p>查看多出来的这4个文件的内容与类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git cat-file -p 180cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">test2</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t 180cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">blob</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p  48acad07a1446a569f8fe2ea06ef15973291561b</span><br><span class="line">tree 71bac679881c174b509333379601f4096220809b</span><br><span class="line">parent e9a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">author slions &lt;slions@163.com&gt; 1631432193 +0800</span><br><span class="line">committer slions &lt;slions@163.com&gt; 1631432193 +0800</span><br><span class="line"></span><br><span class="line">第二次提交，创建mydir/test2.file文件</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t  48acad07a1446a569f8fe2ea06ef15973291561b</span><br><span class="line">commit</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p  71bac679881c174b509333379601f4096220809b</span><br><span class="line">100644 blob a0423896973644771497bdc03eb99d5281615b51    hello.file</span><br><span class="line">040000 tree 778da9f040bedfbf92188332f2d0097cfd1b4fb2    mydir</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t  71bac679881c174b509333379601f4096220809b</span><br><span class="line">tree</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p  778da9f040bedfbf92188332f2d0097cfd1b4fb2</span><br><span class="line">100644 blob b4742fdeca5b697ffdf5b0e0d1c7b74085f36bca    test.file</span><br><span class="line">100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827    test2.file</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t  778da9f040bedfbf92188332f2d0097cfd1b4fb2</span><br><span class="line">tree</span><br></pre></td></tr></table></figure><p>这次可以看到<code>48acad07a1446a569f8fe2ea06ef15973291561b</code>的内容多了一个parent行，其“指纹”和第一次提交时的一致。</p><p>通过一张图来说明当前我本地环境中commit、tree、blob之间的关系。</p><p><img src="https://slions.gitee.io/picbed/img/git01.png"></p><p>如果我们创建相同的100个文件，并且分别进行提交操作，因为文件内容都一样，所以object中只会存一份blob，会出现100个tree，大大的提高了存储空间的利用率于寻址效率。</p><p>当前提交两个commit后git仓库可简化为下图：</p><p><img src="https://slions.gitee.io/picbed/img/git02.jpg"></p><h3 id="git-refs目录"><a href="#git-refs目录" class="headerlink" title=".git/refs目录"></a>.git/refs目录</h3><p>refs目录存储的都是引用文件。如本地分支，远端分支，标签等。</p><ul><li>refs/heads/xxx 本地分支</li><li>refs/remotes/origin/xxx 远端分支</li><li>refs/tags/xxx 本地tag</li></ul><p>引用文件的内容都是40位长度的commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# tree .git/refs/</span><br><span class="line">.git/refs/</span><br><span class="line">├── heads</span><br><span class="line">│   └── master</span><br><span class="line">└── tags</span><br><span class="line">[root@slions_pc1 first_git]# cat .git/refs/heads/master</span><br><span class="line">48acad07a1446a569f8fe2ea06ef15973291561b</span><br></pre></td></tr></table></figure><p>当前git仓库逻辑拓扑为下图：</p><p><img src="https://slions.gitee.io/picbed/img/git03.jpg"></p><h3 id="git-HEAD文件"><a href="#git-HEAD文件" class="headerlink" title=".git/HEAD文件"></a>.git/HEAD文件</h3><p>HEAD目录存储的是当前所在的位置，内容是分支的名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>当前git仓库逻辑拓扑为下图：</p><p><img src="https://slions.gitee.io/picbed/img/git04.jpg"></p><h3 id="git-branches文件"><a href="#git-branches文件" class="headerlink" title=".git/branches文件"></a>.git/branches文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git branch -v</span><br><span class="line">* master 48acad0 第二次提交，创建mydir/test2.file文件</span><br><span class="line">[root@slions_pc1 first_git]# git checkout -b test e9a3da9</span><br><span class="line">A       hello</span><br><span class="line">D       hello.file</span><br><span class="line">切换到一个新分支 &#x27;test&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="git常用命令速查"><a href="#git常用命令速查" class="headerlink" title="git常用命令速查"></a>git常用命令速查</h1><p><img src="https://slions.gitee.io/picbed/img/git05.jpg"></p><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><p>把已有的项目代码纳入git管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 项目代码所在的文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span> </span><br></pre></td></tr></table></figure><p>新建的项目直接用git管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 某个文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> project-name</span></span><br></pre></td></tr></table></figure><p>下载一个项目和它的整个代码历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>显示当前的Git配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br></pre></td></tr></table></figure><p>编辑Git配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global]</span></span><br></pre></td></tr></table></figure><p>设置提交代码时的用户信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config [--global/<span class="built_in">local</span>] user.name <span class="string">&quot;[name]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global/<span class="built_in">local</span>] user.email <span class="string">&quot;[email address]&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="增加删除文件"><a href="#增加删除文件" class="headerlink" title="增加删除文件"></a>增加删除文件</h2><p> 添加指定文件到暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><p>添加指定目录到暂存区，包括子目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br></pre></td></tr></table></figure><p> 添加当前目录的所有文件到暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><p>删除工作区文件，并且将这次删除放入暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><p>停止追踪指定文件，但该文件会保留在工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br></pre></td></tr></table></figure><h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><p>改名文件，并且将这个改名放入暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><p>提交暂存区到仓库区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br></pre></td></tr></table></figure><p>提交暂存区的指定文件到仓库区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br></pre></td></tr></table></figure><p> 提交工作区自上次commit之后的变化，直接到仓库区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br></pre></td></tr></table></figure><p>提交时显示所有diff信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br></pre></td></tr></table></figure><p> 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br></pre></td></tr></table></figure><p>重做上一次commit，并包括指定文件的新变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>列出所有本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure><p>列出所有远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br></pre></td></tr></table></figure><p>列出所有本地分支和远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br></pre></td></tr></table></figure><p> 新建一个分支，但依然停留在当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br></pre></td></tr></table></figure><p>  新建一个分支，并切换到该分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br></pre></td></tr></table></figure><p>新建一个分支，指向指定commit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br></pre></td></tr></table></figure><p>新建一个分支，与指定的远程分支建立追踪关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br></pre></td></tr></table></figure><p>切换到指定分支，并更新工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br></pre></td></tr></table></figure><p> 切换到上一个分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br></pre></td></tr></table></figure><p>建立追踪关系，在现有分支与指定的远程分支之间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream [branch] [remote-branch]</span></span><br></pre></td></tr></table></figure><p> 合并指定分支到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br></pre></td></tr></table></figure><p> 选择一个commit，合并进当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br></pre></td></tr></table></figure><p> 删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br></pre></td></tr></table></figure><p> 删除远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>列出所有tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br></pre></td></tr></table></figure><p> 新建一个tag在当前commit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br></pre></td></tr></table></figure><p> 新建一个tag在指定commit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br></pre></td></tr></table></figure><p> 删除本地tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br></pre></td></tr></table></figure><p> 删除远程tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br></pre></td></tr></table></figure><p> 查看tag信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br></pre></td></tr></table></figure><p> 提交指定tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br></pre></td></tr></table></figure><p> 提交所有tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br></pre></td></tr></table></figure><p> 新建一个分支，指向某个tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>显示有变更的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p> 显示当前分支的版本历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p> 显示commit历史，以及每次commit发生变更的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br></pre></td></tr></table></figure><p> 搜索提交历史，根据关键词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br></pre></td></tr></table></figure><p> 显示某个commit之后的所有变动，每个commit占据一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br></pre></td></tr></table></figure><p> 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br></pre></td></tr></table></figure><p> 显示某个文件的版本历史，包括文件改名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br></pre></td></tr></table></figure><p> 显示指定文件相关的每一次diff</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br></pre></td></tr></table></figure><p> 显示过去5次提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br></pre></td></tr></table></figure><p> 显示所有提交过的用户，按提交次数排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br></pre></td></tr></table></figure><p> 显示指定文件是什么人在什么时间修改过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br></pre></td></tr></table></figure><p>显示今天你写了多少行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span></span><br></pre></td></tr></table></figure><p> 显示某次提交的元数据和内容变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br></pre></td></tr></table></figure><p> 显示某次提交发生变化的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br></pre></td></tr></table></figure><p> 显示某次提交时，某个文件的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br></pre></td></tr></table></figure><p> 显示当前分支的最近几次提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><p> 从本地master拉取代码更新当前分支：branch 一般为master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase [branch]</span></span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>显示暂存区和工作区的代码差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><p> 显示暂存区和上一个commit的差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br></pre></td></tr></table></figure><p> 显示工作区与当前分支最新commit之间的差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br></pre></td></tr></table></figure><p> 显示两次提交之间的差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br></pre></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><p>更新远程仓储</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote update</span></span><br></pre></td></tr></table></figure><p>下载远程仓库的所有变动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br></pre></td></tr></table></figure><p> 显示所有远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><p> 显示某个远程仓库的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br></pre></td></tr></table></figure><p> 增加一个新的远程仓库，并命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br></pre></td></tr></table></figure><p> 取回远程仓库的变化，并与本地分支合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br></pre></td></tr></table></figure><p> 上传本地指定分支到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br></pre></td></tr></table></figure><p> 强行推送当前分支到远程仓库，即使有冲突</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br></pre></td></tr></table></figure><p> 推送所有分支到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>恢复暂存区的指定文件到工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br></pre></td></tr></table></figure><p> 恢复某个commit的指定文件到暂存区和工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br></pre></td></tr></table></figure><p> 恢复暂存区的所有文件到工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br></pre></td></tr></table></figure><p> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br></pre></td></tr></table></figure><p> 重置暂存区与工作区，与上一次commit保持一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br></pre></td></tr></table></figure><p> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br></pre></td></tr></table></figure><p> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br></pre></td></tr></table></figure><p> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br></pre></td></tr></table></figure><p> 新建一个commit，用来撤销指定commit</p><p>后者的所有变化都将被前者抵消，并且应用到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br></pre></td></tr></table></figure><p> 暂时将未提交的变化移除，稍后再移入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>生成一个可供发布的压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git archive</span></span><br></pre></td></tr></table></figure><h2 id="多彩log输出"><a href="#多彩log输出" class="headerlink" title="多彩log输出"></a>多彩log输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lg</span></span><br></pre></td></tr></table></figure><h1 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h1><p>git动图展示工作流： <a href="https://zhuanlan.zhihu.com/p/132573100">https://zhuanlan.zhihu.com/p/132573100</a></p><p>使用原理视角看git： <a href="https://www.cnblogs.com/Coding-net/p/5577485.html">https://www.cnblogs.com/Coding-net/p/5577485.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于git的使用介绍网上也比较多了，尤其是廖雪峰大佬的git教程与苏玲大佬的git网课都是git入门的经典。写这篇文章主要是想通过图示化配合文字的方式，加深记忆，也在日常工作中起到速查的作用。&lt;/p&gt;
&lt;h1 id=&quot;git简介&quot;&gt;&lt;a href=&quot;#git简介&quot; clas</summary>
      
    
    
    
    <category term="git" scheme="https://slions.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://slions.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的编写dockerfile</title>
    <link href="https://slions.github.io/2021/09/02/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E5%86%99dockerfile/"/>
    <id>https://slions.github.io/2021/09/02/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E5%86%99dockerfile/</id>
    <published>2021-09-02T15:55:40.000Z</published>
    <updated>2021-09-03T12:53:27.383Z</updated>
    
    <content type="html"><![CDATA[<p>写一个能够运行起来的的dockerfile是比较简单的，而写一个“产品化程度高”的dockerfile是需要设计的。</p><p>操作简易的dockerfile意味着几乎任何命令都能成功执行，以致于镜像动不动就1个多G好几百M，要知道的是镜像越大，拉取的速度也会随之增加，对于系统的开销也就越大。dockerhub上有上万个镜像，我们可以随意的拿来作为基础镜像，与之伴随的就是潜在的安全隐患，某些特殊的场景下，比如金融、政府等领域，对于安全性要求特别高，这种随意的镜像制作手法是不被允许的。下文会讲讲如何优雅的构建镜像。</p><h1 id="减少构建时间"><a href="#减少构建时间" class="headerlink" title="减少构建时间"></a>减少构建时间</h1><p>一个开发周期包括构建 Docker 镜像，更改代码，然后重新构建 Docker 镜像。在构建镜像的过程中，如果能够充分利用docker的缓存机制，可以减少不必要的重复构建步骤。</p><h2 id="设计高效的构建顺序"><a href="#设计高效的构建顺序" class="headerlink" title="设计高效的构建顺序"></a>设计高效的构建顺序</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile1.jpg"></p><p>镜像的构建顺序很重要，当你向 Dockerfile 中添加文件，或者修改其中的某一行时，那一部分的缓存就会失效，该缓存的后续步骤都会中断，需要重新构建。所以优化缓存的最佳方法是把不需要经常更改的行放到最前面，更改最频繁的行放到最后面。</p><h2 id="只拷贝需要的文件"><a href="#只拷贝需要的文件" class="headerlink" title="只拷贝需要的文件"></a>只拷贝需要的文件</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile02.jpg"></p><p>当拷贝文件到镜像中时，尽量只拷贝需要的文件，如果被拷贝的文件内容发生了更改，缓存就会被破坏。在上面的示例中，镜像中只需要构建好的 jar 包，因此只需要拷贝这个文件就行了，这样即使其他不相关的文件发生了更改也不会影响缓存。</p><h2 id="缓存层最小化"><a href="#缓存层最小化" class="headerlink" title="缓存层最小化"></a>缓存层最小化</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile03.jpg"></p><p>每一个 <code>RUN</code> 指令都会被看作是可缓存的执行单元。太多的 RUN 指令会增加镜像的层数，增大镜像体积，而将所有的命令都放到同一个 RUN 指令中又会破坏缓存，从而延缓开发周期。当使用包管理器安装软件时，一般都会先更新软件索引信息，然后再安装软件。推荐将更新索引和安装软件放在同一个 RUN 指令中，这样可以形成一个可缓存的执行单元，否则你可能会安装旧的软件包。</p><h2 id="减少网络传输时间"><a href="#减少网络传输时间" class="headerlink" title="减少网络传输时间"></a>减少网络传输时间</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile04.jpg"></p><p>ADD命令可以下载外网URL地址的资源，但由于网络环境性能差异，或者根本就是无网环境，推荐提前将所需的资源包下载下来使用，减少网络对构建过程的影响。</p><h1 id="减小镜像体积"><a href="#减小镜像体积" class="headerlink" title="减小镜像体积"></a>减小镜像体积</h1><p>如果之前接触过k8s就知道，海量集群中有节点故障是常有的事儿，故障节点上的服务会漂移到其他正常节点，此时如果正常节点没有这些服务的镜像就需要从仓库中拉取，而镜像小也就意味着拉取时间短，恢复时间快，一个镜像时看不出来，如果是需同时下载多个镜像就会给系统造成不小的开销。</p><h2 id="删除不必要的依赖"><a href="#删除不必要的依赖" class="headerlink" title="删除不必要的依赖"></a>删除不必要的依赖</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile05.jpg"></p><p>删除不必要的依赖，没有硬性需求不安装调试工具。某些包管理工具（如 <code>yum</code>）除了安装用户指定的包之外，还会安装一些弱依赖包，这会增加镜像的体积。yum 可以通过添加参数 <code>--setopt=install_weak_deps=false</code> 来确保不会安装弱依赖的包，<code>--setopt=tsflags=nodocs</code>参数来取消文档包的安装。</p><p>包管理工具会维护自己的缓存，这些缓存会保留在镜像文件中，推荐的处理方法是在每一个 RUN 指令的末尾删除缓存。如果你在下一条指令中删除缓存，不会减小镜像的体积。</p><h1 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h1><h2 id="使用官方镜像"><a href="#使用官方镜像" class="headerlink" title="使用官方镜像"></a>使用官方镜像</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile06.png"></p><p><img src="https://slions.gitee.io/picbed/img/dockerfile07.png"></p><p>使用官方镜像可以节省大量的维护时间，因为官方镜像的所有安装步骤都使用了最佳实践。</p><h2 id="使用可读性高的标签"><a href="#使用可读性高的标签" class="headerlink" title="使用可读性高的标签"></a>使用可读性高的标签</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile08.jpg"></p><p>基础镜像尽量不要使用 <code>latest</code> 标签。虽然这很方便，但随着时间的推移，latest 镜像可能会发生重大变化。因此在 Dockerfile 中最好指定基础镜像的具体标签。当然，我们构建的镜像也同理。</p><h2 id="使用体积最小的基础镜像"><a href="#使用体积最小的基础镜像" class="headerlink" title="使用体积最小的基础镜像"></a>使用体积最小的基础镜像</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile09.png"></p><p>我们在dockerhub上可以看到一个镜像会有形形色色的标签。其中<code>slim</code> 风格的镜像是基于 Debian 发行版制作的，而 <code>alpine</code> 风格的镜像是基于体积更小的 Alpine Linux 发行版制作的。 以 openjdk 为例，<code>jre</code> 风格的镜像只包含 Java 运行时，不包含 <code>SDK</code>，这么做也可以大大减少镜像体积。</p><h2 id="保持服务的默认端口"><a href="#保持服务的默认端口" class="headerlink" title="保持服务的默认端口"></a>保持服务的默认端口</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile10.jpg"></p><p>构建镜像时需保证此服务的运行端口暴露出来。</p><p><strong>最后，在 Push 之前，切记先在本地运行一下构建好的镜像，确保服务无任何问题，以免为后期排错造成不必要的时间浪费。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写一个能够运行起来的的dockerfile是比较简单的，而写一个“产品化程度高”的dockerfile是需要设计的。&lt;/p&gt;
&lt;p&gt;操作简易的dockerfile意味着几乎任何命令都能成功执行，以致于镜像动不动就1个多G好几百M，要知道的是镜像越大，拉取的速度也会随之增加，</summary>
      
    
    
    
    <category term="docker" scheme="https://slions.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>镜像构建之dockerfile</title>
    <link href="https://slions.github.io/2021/09/02/%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B9%8BDockerfile/"/>
    <id>https://slions.github.io/2021/09/02/%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B9%8BDockerfile/</id>
    <published>2021-09-02T12:35:40.000Z</published>
    <updated>2021-09-05T06:07:12.787Z</updated>
    
    <content type="html"><![CDATA[<p>近几年来容器技术几乎席卷了整个IT界，当今容器已经成为了被大家广泛认可的应用托管技术，各种传统行业也在投入容器化的技术革新浪潮中。</p><p>docker镜像可以被看做容器的基石，虽然dockerhub上提供了大量可用的镜像，但是由于环境的多样性和需求的特殊性，很多时候都需要自己制作适合的镜像。</p><p>制作docker镜像有两种常见的方式：</p><ol><li>docker commit</li><li>Dockerfile</li></ol><p>其中docker commit原理是基于在容器内执行相关操作，并最终通过commit实现打包生成镜像。Dockerfile 就是在一个文件中声明应用环境和应用本身。推荐使用Dockerfile方式，因为其与commit方式相比，具备可追溯性与可维护性，在日常的开发过程中需要频繁的构建镜像，而dockerfile会清晰的记录每一步执行的操作，出现异常时也可以方便的进行调整。</p><h1 id="Dockerfile的基本结构"><a href="#Dockerfile的基本结构" class="headerlink" title="Dockerfile的基本结构"></a>Dockerfile的基本结构</h1><p>Dockerfile一般分为四部分：</p><ul><li>基础镜像信息</li><li>维护者信息（可忽略）</li><li>镜像操作指令</li><li>容器启动时执行指令</li></ul><h1 id="Dockerfile语法"><a href="#Dockerfile语法" class="headerlink" title="Dockerfile语法"></a>Dockerfile语法</h1><p>可以先来一个官方的alpine Dockerfile找找感觉。</p><p><img src="https://slions.gitee.io/picbed/img/alpine.png"></p><p>以下来列举一些常用的Dockerfile指令。</p><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>FORM指令是最重要的一个且必须为Dockerfile文件开篇的第一个非注释行，用于为镜像文件构建过程指定基础镜像，后续的指令运行于此基准镜像所提供的运行环境。</p><p>实践中，基准镜像可以是任何可用镜像文件，默认情况下，docker build会在docker主机上查找指定的镜像文件，在其不存在时，则会从Docker Hub Registry上拉取所需的镜像文件。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;repository&gt;[:&lt;tag&gt;]</span><br><span class="line">或</span><br><span class="line">FROM &lt;repository&gt;@&lt;digest&gt; </span><br></pre></td></tr></table></figure><p><code>&lt;repository&gt;</code>:指定作为base image的名称<br><code>&lt;tag&gt;</code>: base image的标签,为可选项，省略时默认为latest</p><h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><p>用于让Dockerfile制作者提供本人的详细信息，可以是任何文本信息，约定俗成为作者名称和邮件地址，可以放置于Dockerfile的任意位置，建议这个命令放在FORM之后，当然不写也是没问题的。（高版本已弃用，被LABEL替代）</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER [name]</span><br></pre></td></tr></table></figure><h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><p>用于为镜像添加元数据。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>用于从Docker主机复制文件至创建的新镜像文件。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt; .. &lt;dest&gt;</span><br><span class="line">或</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,..&quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure><p><code>&lt;src&gt;</code>：要复制的文件或目录，支持通配符<br><code>&lt;dest&gt;</code>：目标路径，即正在创建的image的文件系统路径；建议为<code>&lt;dest&gt;</code>使用绝对路径，否则，COPY指定则以WORKDIR为其起始路径。</p><h3 id="文件复制准则"><a href="#文件复制准则" class="headerlink" title="文件复制准则"></a>文件复制准则</h3><ul><li><p><code>&lt;src&gt;</code>必须是build上下文中的路径，不能为其父目录中的文件</p></li><li><p>如果<code>&lt;src&gt;</code>是目录，则其内部文件或子目录会被递归复制，但<code>&lt;src&gt;</code>目录自身不会被复制</p></li><li><p>如果指定了多个<code>&lt;src&gt;</code>，或在<code>&lt;src&gt;</code>中使用了通配符，则<code>&lt;dest&gt;</code>必须是一个目录，且必须以 / 结尾</p></li><li><p>如果<code>&lt;dest&gt;</code>事先不存在，它将被自动创建，这包括其父目录路径</p></li></ul><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p>ADD指令类似于COPY指令，ADD支持使用tar文件和URL路径。tar类型文件会自动解压。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; .. &lt;dest&gt;</span><br><span class="line">或</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,..&quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure><p><code>&lt;src&gt;</code>：要复制的文件或目录，支持通配符<br><code>&lt;dest&gt;</code>：目标路径，即正在创建的image的文件系统路径；建议为<code>&lt;dest&gt;</code>使用绝对路径，否则，ADD指定则以WORKDIR为其起始路径。</p><h3 id="文件复制准则-1"><a href="#文件复制准则-1" class="headerlink" title="文件复制准则"></a>文件复制准则</h3><ul><li>同COPY指令</li><li>如果<code>&lt;src&gt;</code>为URL且<code>&lt;dest&gt;</code>不以 / 结尾，则<code> &lt;src&gt;</code>指定的文件将被下载并直接被创建为<code>&lt;dest&gt;</code>;如果<code>&lt;dest&gt;</code>以 / 结尾，则文件名为URL指定的文件将被直接下载并保存为<code>&lt;dest&gt;/&lt;filename&gt;</code></li><li>如果<code>&lt;src&gt;</code>是一个本地系统上的压缩格式的tar文件，它将被展开为一个目录，其行为类似于” tar -x”;然而通过URL获取到的tar文件不会自动展开；</li><li>如果<code>&lt;src&gt;</code>有多个，或其间接或直接使用了通配符，则<code>&lt;dest&gt;</code>必须是一个以 / 结尾的目录路径；如果<code>&lt;dest&gt;</code>不以 / 结尾，则其被视为一个普通文件，<code>&lt;src&gt;</code>的内容将被直接写入到<code>&lt;dest</code>&gt;;</li></ul><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>用于为Dockerfile中所有的<code>RUN</code>，<code>CMD</code>，<code>ENTRYPOINT</code>，<code>COPY</code>和<code>ADD</code>指定设定工作目录。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &lt;dir path&gt;</span><br></pre></td></tr></table></figure><p>在Dockerfile文件中，WORKDIR指令可出现多次，其路径也可以为相对路径，不过，其是相对此前一个WORKDIR指令指定的路径。</p><p>另外，WORKDIR也可以调用由ENV指定定义的变量，例如<code>WORKDIR $STATEPATH</code></p><h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p>用于在image中创建一个挂载点目录，以挂载Docker host上的卷或其它容器上的卷。</p><p>通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的，多用于数据卷容器。</p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VOLUME &lt;mountpoint&gt;</span><br><span class="line">或 </span><br><span class="line">VOLUME [&quot;&lt;mountpoint&gt;&quot;]</span><br></pre></td></tr></table></figure><p>如果挂载点目录路径下此前的文件存在，docker run命令会在卷挂载完成后将此前的所有文件复制到新挂载的卷中。</p><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>用于为容器打开指定要监听的端口以实现与外部通信（因为主机可以允许暴露的端口并不知道，当docker run时加“- P”即可以把容器内服务所需端口暴露到外部来）</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;protocol&gt;] [&lt;port&gt;[/&lt;protocol&gt;]..]</span><br></pre></td></tr></table></figure><p><code>&lt;protocol&gt;</code>用于指定传输层协议，可为tcp或udp二者之一，默认为TCP。</p><p>EXPOSE指令可一次指定多个端口。</p><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>用于为镜像定义所需的环境变量，并可以被Dockerfile文件中位于其后的其它指令（如ENV,ADD,COPY等）所调用。调用格式为 <code>$variable_name</code>或 <code>$&#123;variable_name&#125;</code></p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt; </span><br><span class="line">或</span><br><span class="line">ENV &lt;key&gt; = &lt;value&gt; …</span><br></pre></td></tr></table></figure><p>第一种格式中，<code>&lt;key&gt;</code>之后的所有内容均会被视作其<code>&lt;value&gt;</code>的组成部分，因此，一次只能设置一个变量</p><p>第二种格式可用一次设置多个变量，每个变量为一个<code>&lt;key&gt;=&lt;value&gt;</code>的键值对，如果<code>&lt;value&gt;</code>中包括空格，可以以（ \ ）进行转义，也可以通过对<code>&lt;value&gt;</code>加引号进行标识；另外，反斜线也可用于续行。</p><p>定义多个变量时，建议使用第二种方式，以便在同一层完成所有功能。</p><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>构建镜像时运行的命令。</p><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;   #执行shell内部命令</span><br><span class="line">或</span><br><span class="line">RUN [&quot;&lt;executable&gt;&quot;, &quot;&lt;param1&gt;&quot;, &quot;&lt;param2&gt;&quot;]     # 执行可执行文件</span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>类似于RUN指令，CMD指令也可以用于运行任何命令或应用程序，不过，二者的运行时间点不同。</p><ul><li><p>RUN指令运行于镜像文件构建过程中，而CMD指令运行于基于Dockerfile构建出的新镜像文件启动一个容器时。</p></li><li><p>CMD指令的首要目的在于为启动的容器指定默认要运行的程序，且其运行结束后，容器也将终止；不过，CMD指定的命令其可以被docker run的命令行选项所覆盖。</p></li><li><p>在Dockerfile中可以存在多个CMD指令，但仅最后一个会生效。</p></li></ul><h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;command&gt;       #执行shell内部命令</span><br><span class="line">或</span><br><span class="line">CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]       #执行可执行文件</span><br><span class="line">或</span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]       #设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数</span><br></pre></td></tr></table></figure><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>类似CMD指令的功能，用于为容器指定默认运行程序。</p><p>与CMD不同的是，由ENTRYPOINT启动的程序不会被docker run命令行指定的参数覆盖，而且，这些命令行参数会被当做参数传递给ENTRYPOINT指定的程序。</p><p>docker run命令时加– entrypoint选项的参数可覆盖ENTRYPOINT指令指定的程序。</p><h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT &lt;command&gt;</span><br><span class="line">或</span><br><span class="line">ENTRYPOINT [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;] </span><br></pre></td></tr></table></figure><h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>指定运行容器时的用户名或 UID，后续的 RUN 、CMD、ENTRYPOINT也会使用指定用户。</p><h3 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER &lt;UID&gt;|&lt;UserName&gt;</span><br></pre></td></tr></table></figure><p>必须为镜像中已存在的用户（/etc/passwd）</p><h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p>用于指定传递给构建运行时的变量，ARG命令定义了一个变量，在docker build创建镜像的时候，使用<code> --build-arg &lt;varname&gt;=&lt;value&gt;</code>来指定参数。</p><h3 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><h2 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h2><p>顾名思义，健康检查。</p><h3 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK [OPTIONS] CMD command    #在容器内部运行一个命令来检查容器的健康状况</span><br><span class="line">或</span><br><span class="line">HEALTHCHECK NONE       #取消基础镜像中的健康检查</span><br></pre></td></tr></table></figure><p>[OPTIONS]的选项支持以下选项：</p><ul><li><p>–interval=DURATION 间隔时间，默认30s（30秒），从容器运行起来开始计时interval秒（或者分钟小时）进行第一次健康检查，随后每间隔interval秒进行一次健康检查；还有一种特例请看timeout解析。</p></li><li><p>–timeout=DURATION 超时时间，默认 30s（30秒），执行command需要时间，比如curl 一个地址，如果超过timeout秒则认为超时是错误的状态，此时每次健康检查的时间是timeout+interval秒。</p></li><li><p>–start-period=DURATION 启动时间，默认0s，为需要启动的容器提供了初始化的时间段，在这个时间段内如果检查失败， 则不会记录失败次数。 如果在启动时间内成功执行了健康检查， 则容器将被视为已经启动， 如果在启动时间内再次出现检查失败， 则会记录失败次数。</p></li><li><p>–retries=N 重试次数， 默认 3 </p></li></ul><h2 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h2><p>当容器退出时给系统发送的指令。</p><h3 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure><p>默认的stop-signal是SIGTERM，在docker stop的时候会给容器内PID为1的进程发送这个signal，通过–stop-signal可以设置自己需要的signal，主要的目的是为了让容器内的应用程序在接收到signal之后可以先做一些事情，实现容器的平滑退出，如果不做任何处理，容器将在一段时间之后强制退出，会造成业务的强制中断，这个时间默认是10s。</p><h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p>用于为镜像添加触发器。其参数是任意一个Dockerfile 指令。</p><p>Dockerfile用于构建镜像，此镜像也可以作为base image被其他的Dockerfile引用，并构建出新的镜像。</p><p>当我们编写一个新的Dockerfile文件，FROM的是A镜像，构建的是B镜像时，这时构建A镜像的Dockerfile文件中的ONBUILD指令就生效了，在构建B镜像的过程中，首先会执行ONBUILD指令指定的指令，然后才会执行其它指令。需要注意的是，如果是再利用B镜像构造新的镜像时，那个ONBUILD指令就无效了，也就是说只能再构建子镜像中执行，对孙子镜像构建无效。</p><h3 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD &lt;instruction&gt;</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写父镜像dockerfile</span></span><br><span class="line">[root@slions_pc1 omg]# cat Dockerfile</span><br><span class="line">FROM centos:7</span><br><span class="line">ONBUILD RUN mkdir -p /tmp/slions</span><br><span class="line">ONBUILD RUN yum install iproute -y</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">[root@slions_pc1 omg]# docker build -t slions:father .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动其镜像的容器，查看和我们想的一样，并没有创建目录与安装软件</span></span><br><span class="line">[root@slions_pc1 omg]# docker run -it --rm --name slions-f slions:father /bin/bash</span><br><span class="line">[root@2710becec644 /]# ls /tmp</span><br><span class="line">ks-script-DrRL8A  yum.log</span><br><span class="line">[root@2710becec644 /]# rpm -qa|grep iproute</span><br><span class="line">[root@2710becec644 /]# ip a</span><br><span class="line">bash: ip: command not found</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写子镜像dockerfile</span></span><br><span class="line">[root@slions_pc1 omg]# cat Dockerfile</span><br><span class="line">FROM slions:father</span><br><span class="line">RUN echo 123 &gt; /file</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建子镜像，从这里就能看出来已经开始安装软件了</span></span><br><span class="line">[root@slions_pc1 omg]# docker build -t slions:son .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM slions:father</span><br><span class="line"><span class="meta">#</span><span class="bash"> Executing 2 build triggers</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 43e3db71fb7b</span></span><br><span class="line">Removing intermediate container 43e3db71fb7b</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 22c5c6450487</span></span><br><span class="line">Loaded plugins: fastestmirror, ovl</span><br><span class="line">Determining fastest mirrors</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.huaweicloud.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">Resolving Dependencies</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package iproute.x86_64 0:4.11.0-30.el7 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libmnl.so.0(LIBMNL_1.0)(64bit) <span class="keyword">for</span> package: iproute-4.11.0-30.el7.x86_64</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libxtables.so.10()(64bit) <span class="keyword">for</span> package: iproute-4.11.0-30.el7.x86_64</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libmnl.so.0()(64bit) <span class="keyword">for</span> package: iproute-4.11.0-30.el7.x86_64</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package iptables.x86_64 0:1.4.21-35.el7 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libnfnetlink.so.0()(64bit) <span class="keyword">for</span> package: iptables-1.4.21-35.el7.x86_64</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libnetfilter_conntrack.so.3()(64bit) <span class="keyword">for</span> package: iptables-1.4.21-35.el7.x86_64</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package libmnl.x86_64 0:1.0.3-7.el7 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package libnetfilter_conntrack.x86_64 0:1.0.6-1.el7_3 will be installed</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package libnfnetlink.x86_64 0:1.0.1-4.el7 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Finished Dependency Resolution</span></span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line"> Package                      Arch         Version             Repository  Size</span><br><span class="line">================================================================================</span><br><span class="line">Installing:</span><br><span class="line"> iproute                      x86_64       4.11.0-30.el7       base       805 k</span><br><span class="line">Installing for dependencies:</span><br><span class="line"> iptables                     x86_64       1.4.21-35.el7       base       432 k</span><br><span class="line"> libmnl                       x86_64       1.0.3-7.el7         base        23 k</span><br><span class="line"> libnetfilter_conntrack       x86_64       1.0.6-1.el7_3       base        55 k</span><br><span class="line"> libnfnetlink                 x86_64       1.0.1-4.el7         base        26 k</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">================================================================================</span><br><span class="line">Install  1 Package (+4 Dependent packages)</span><br><span class="line"></span><br><span class="line">Total download size: 1.3 M</span><br><span class="line">Installed size: 3.5 M</span><br><span class="line">Downloading packages:</span><br><span class="line">warning: /var/cache/yum/x86_64/7/base/packages/libmnl-1.0.3-7.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span><br><span class="line">Public key for libmnl-1.0.3-7.el7.x86_64.rpm is not installed</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Total                                              7.7 MB/s | 1.3 MB  00:00</span><br><span class="line">Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">Importing GPG key 0xF4A80EB5:</span><br><span class="line"> Userid     : &quot;CentOS-7 Key (CentOS 7 Official Signing Key) &lt;security@centos.org&gt;&quot;</span><br><span class="line"> Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5</span><br><span class="line"> Package    : centos-release-7-9.2009.0.el7.centos.x86_64 (@CentOS)</span><br><span class="line"> From       : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  Installing : libmnl-1.0.3-7.el7.x86_64                                    1/5</span><br><span class="line">  Installing : libnfnetlink-1.0.1-4.el7.x86_64                              2/5</span><br><span class="line">  Installing : libnetfilter_conntrack-1.0.6-1.el7_3.x86_64                  3/5</span><br><span class="line">  Installing : iptables-1.4.21-35.el7.x86_64                                4/5</span><br><span class="line">  Installing : iproute-4.11.0-30.el7.x86_64                                 5/5</span><br><span class="line">  Verifying  : libnfnetlink-1.0.1-4.el7.x86_64                              1/5</span><br><span class="line">  Verifying  : libnetfilter_conntrack-1.0.6-1.el7_3.x86_64                  2/5</span><br><span class="line">  Verifying  : iptables-1.4.21-35.el7.x86_64                                3/5</span><br><span class="line">  Verifying  : libmnl-1.0.3-7.el7.x86_64                                    4/5</span><br><span class="line">  Verifying  : iproute-4.11.0-30.el7.x86_64                                 5/5</span><br><span class="line"></span><br><span class="line">Installed:</span><br><span class="line">  iproute.x86_64 0:4.11.0-30.el7</span><br><span class="line"></span><br><span class="line">Dependency Installed:</span><br><span class="line">  iptables.x86_64 0:1.4.21-35.el7</span><br><span class="line">  libmnl.x86_64 0:1.0.3-7.el7</span><br><span class="line">  libnetfilter_conntrack.x86_64 0:1.0.6-1.el7_3</span><br><span class="line">  libnfnetlink.x86_64 0:1.0.1-4.el7</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line">Removing intermediate container 22c5c6450487</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> a3a6d207fc28</span></span><br><span class="line">Step 2/2 : RUN echo 123 &gt; /file</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 35558b54b260</span></span><br><span class="line">Removing intermediate container 35558b54b260</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 00f7acbca5de</span></span><br><span class="line">Successfully built 00f7acbca5de</span><br><span class="line">Successfully tagged slions:son</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动子镜像容器，查看是否有相关的目录与软件</span></span><br><span class="line">[root@slions_pc1 omg]# docker run -it --rm --name slions-s slions:son /bin/bash</span><br><span class="line">[root@988d86e2f98b /]# ls /tmp</span><br><span class="line">ks-script-DrRL8A  slions  yum.log</span><br><span class="line">[root@988d86e2f98b /]# rpm -qa|grep iproute</span><br><span class="line">iproute-4.11.0-30.el7.x86_64</span><br><span class="line">[root@988d86e2f98b /]# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">26: eth0@if27: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h1 id="Dockerfile使用"><a href="#Dockerfile使用" class="headerlink" title="Dockerfile使用"></a>Dockerfile使用</h1><p><code>docker build</code>命令用于从Dockerfile中构建镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build --<span class="built_in">help</span></span></span><br><span class="line">Usage:  docker build [OPTIONS] PATH | URL | -</span><br><span class="line">Build an image from a Dockerfile</span><br><span class="line">Options:</span><br><span class="line">      --add-host list           Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">      --build-arg list          Set build-time variables</span><br><span class="line">      --cache-from strings      Images to consider as cache sources</span><br><span class="line">      --cgroup-parent string    Optional parent cgroup for the container</span><br><span class="line">      --compress                Compress the build context using gzip</span><br><span class="line">      --cpu-period int          Limit the CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int           Limit the CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">  -c, --cpu-shares int          CPU shares (relative weight)</span><br><span class="line">      --cpuset-cpus string      CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string      MEMs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">  -f, --file string             Name of the Dockerfile (Default is &#x27;PATH/Dockerfile&#x27;)</span><br><span class="line">      --force-rm                Always remove intermediate containers</span><br><span class="line">      --iidfile string          Write the image ID to the file</span><br><span class="line">      --isolation string        Container isolation technology</span><br><span class="line">      --label list              Set metadata for an image</span><br><span class="line">  -m, --memory bytes            Memory limit</span><br><span class="line">      --memory-swap bytes       Swap limit equal to memory plus swap: &#x27;-1&#x27; to enable unlimited swap</span><br><span class="line">      --network string          Set the networking mode for the RUN instructions during build (default &quot;default&quot;)</span><br><span class="line">      --no-cache                Do not use cache when building the image</span><br><span class="line">      --pull                    Always attempt to pull a newer version of the image</span><br><span class="line">  -q, --quiet                   Suppress the build output and print image ID on success</span><br><span class="line">      --rm                      Remove intermediate containers after a successful build (default true)</span><br><span class="line">      --security-opt strings    Security options</span><br><span class="line">      --shm-size bytes          Size of /dev/shm</span><br><span class="line">  -t, --tag list                Name and optionally a tag in the &#x27;name:tag&#x27; format</span><br><span class="line">      --target string           Set the target build stage to build.</span><br><span class="line">      --ulimit ulimit           Ulimit options (default [])</span><br></pre></td></tr></table></figure><p>基本的docker build [选项] 内容路径，该命令将读取指定路径下(包括子目录)的Dockerfile，并将该路径下的所有内容发送给Docker服务端，由服务端来创建镜像。因此除非生成镜像需要，否则一般建议放置Dockerfile的目录为空目录。</p><h2 id="常用方式示例"><a href="#常用方式示例" class="headerlink" title="常用方式示例"></a>常用方式示例</h2><ol><li>使用当前目录的 Dockerfile 创建镜像，标签为 agree/acaas:v1。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t agree/acaas:v1 .</span><br></pre></td></tr></table></figure><ol start="2"><li>指定Dockerfile路径创建镜像，标签为agree/acaas:v2。(如果Dockerfile中涉及ADD或者COPY本地文件时，需要保证当前执行命令的目录下存在这些文件)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── acaasdemo</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">└── a.txt</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br><span class="line">[root@slions_pc1 mydockerfile]# docker build -f acaasdemo/Dockerfile -t acaas:v2 .</span><br></pre></td></tr></table></figure><h2 id="使用-dockerignore文件"><a href="#使用-dockerignore文件" class="headerlink" title="使用 .dockerignore文件"></a>使用 .dockerignore文件</h2><p>构建镜像时，Docker需要先准备<code>context</code> ，将所有需要的文件收集到进程中。默认的<code>context</code>包含Dockerfile目录中的所有文件，可以通过<code> .dockeringore</code>文件(每一行添加一条匹配模式)来让Docker忽略匹配模式路径下的目录和文件。（可以使用通配符），<code>.dockerignore</code> 的作用和语法类似于 <code>.gitignore</code>，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少Docker镜像的大小。</p><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近几年来容器技术几乎席卷了整个IT界，当今容器已经成为了被大家广泛认可的应用托管技术，各种传统行业也在投入容器化的技术革新浪潮中。&lt;/p&gt;
&lt;p&gt;docker镜像可以被看做容器的基石，虽然dockerhub上提供了大量可用的镜像，但是由于环境的多样性和需求的特殊性，很多时候</summary>
      
    
    
    
    <category term="docker" scheme="https://slions.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>expect使用</title>
    <link href="https://slions.github.io/2021/08/30/expect%E4%BD%BF%E7%94%A8/"/>
    <id>https://slions.github.io/2021/08/30/expect%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-30T07:54:09.000Z</published>
    <updated>2021-08-30T12:24:39.069Z</updated>
    
    <content type="html"><![CDATA[<p>使用ssh和scp时常常需要交互式的输入yes和密码，对于自动化运维中这种还需要人工点击完成的情况就比较烦了，linux的expect工具可以优雅的解决此问题。</p><p>expect是建立在tcl基础上的一个工具，可以让需要交互的任务自动化的完成，相当于是模拟用户进行交互性操作。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install -y expect</span></span><br></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol><li>​    定义脚本的执行shell，类似于bash等shell功能。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">！/usr/bin/expect</span></span><br></pre></td></tr></table></figure><ol start="2"><li>​    设置超时时间，单位为秒，设置为-1意为永不超时。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set timeout 30</span><br></pre></td></tr></table></figure><ol start="3"><li>​    spawn</li></ol><p>spawn是进入expect环境后才能执行的命令，不能直接在默认的shell环境中进行执行，主要功能是传递交互指令。</p><ol start="4"><li>​    expect</li></ol><p>同样是expect内部命令，判断输出结果中是否包含某个字符串，没有即立刻返回，否则就等待一段时间后退出，等待的时间由timeout指定。</p><ol start="5"><li>​    send</li></ol><p>发送交互值，代替我们手动输入，命令字符串后面加上<code>\r</code>代表敲回车。</p><ol start="6"><li>​    interact</li></ol><p>执行完后保持交互状态，把控制权交给控制台。</p><ol start="7"><li>​    exp_continue</li></ol><p>继续执行接下来的交互操作。</p><ol start="8"><li>​    $argv</li></ol><p>expect可以接收从bash传递的参数，可以使用<code>[lindex $argv n]</code>,n从0开始</p><p><strong>示例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat interact</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set timeout 30</span><br><span class="line">set passwd &quot;123&quot;</span><br><span class="line">spawn ssh 192.168.100.11</span><br><span class="line">expect &#123;</span><br><span class="line">  &quot;(yes/no)&quot; &#123; send &quot;yes\r&quot;,exp_continue &#125;</span><br><span class="line">  &quot;password:&quot; &#123; send &quot;$passwd\r&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect &quot;#&quot; &#123;send &quot;cat /etc/sysconfig/network-scripts/ifcfg-ens33\r&quot;&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# chmod +x interact</span><br><span class="line">[root@slions_pc1 ~]# ./interact</span><br><span class="line">spawn ssh 192.168.100.11</span><br><span class="line">root@192.168.100.11&#x27;s password:</span><br><span class="line">Last login: Mon Aug 30 19:34:19 2021 from 192.168.100.10</span><br><span class="line">[root@slions_pc2 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=285fd0e1-1041-4470-abc1-2c97ee6764cf</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.100.11</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.100.2</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">[root@slions_pc2 ~]# exit</span><br><span class="line">登出</span><br><span class="line">Connection to 192.168.100.11 closed.</span><br><span class="line">[root@slions_pc1 ~]#</span><br></pre></td></tr></table></figure><h1 id="expect使用场景"><a href="#expect使用场景" class="headerlink" title="expect使用场景"></a>expect使用场景</h1><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat expect_ssh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set timeout -1</span><br><span class="line">set passwd [lindex $argv 0]</span><br><span class="line">set port [lindex $argv 1]</span><br><span class="line">set dest_ip [lindex $argv 2]</span><br><span class="line">set cmd [lindex $argv 3]</span><br><span class="line"></span><br><span class="line">if &#123;$argc &lt; 4&#125; &#123;</span><br><span class="line">    #do something</span><br><span class="line">    send_user &quot;usage: $argv0 &lt;remote_passwd&gt; &lt;remote_port&gt; &lt;remote_addr&gt; &lt;remote_cmd&gt; \n&quot;</span><br><span class="line">    exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn ssh -p $port $dest_ip $cmd</span><br><span class="line">expect &#123;</span><br><span class="line">  &quot;(yes/no)?&quot;</span><br><span class="line">  &#123;</span><br><span class="line">    send &quot;yes\r&quot;</span><br><span class="line">    expect &quot;password:&quot; &#123; send &quot;$passwd\r&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &quot;password:&quot;</span><br><span class="line">  &#123;</span><br><span class="line">    send &quot;$passwd\r&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# chmod +x expect_ssh</span><br><span class="line">[root@slions_pc1 ~]# ./expect_ssh 123 22 192.168.100.11 &#x27;lsblk&#x27;</span><br><span class="line">spawn ssh -p 22 192.168.100.11 lsblk</span><br><span class="line">root@192.168.100.11&#x27;s password:</span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0   20G  0 disk</span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   19G  0 part</span><br><span class="line">  ├─centos-root 253:0    0   18G  0 lvm  /</span><br><span class="line">  └─centos-swap 253:1    0 1020M  0 lvm  [SWAP]</span><br><span class="line">sr0              11:0    1   10G  0 rom</span><br></pre></td></tr></table></figure><p>改用bash脚本中的写法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat expect.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">password=$1</span><br><span class="line">port=$2</span><br><span class="line">dest_ip=$3</span><br><span class="line">cmd=$4</span><br><span class="line">/usr/bin/expect &lt;&lt;EOF</span><br><span class="line">set timeout -1</span><br><span class="line">spawn ssh -p $port $dest_ip $cmd</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;(yes/no)&quot; &#123; send &quot;yes\r&quot;; exp_continue &#125;</span><br><span class="line">    &quot;password:&quot; &#123; send &quot;$password\r&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat expect_scp</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set timeout -1</span><br><span class="line">set passwd [lindex $argv 0]</span><br><span class="line">set port [lindex $argv 1]</span><br><span class="line">set src_file [lindex $argv 2]</span><br><span class="line">set dest_file [lindex $argv 3]</span><br><span class="line"></span><br><span class="line">if &#123;$argc &lt; 4&#125; &#123;</span><br><span class="line">    #do something</span><br><span class="line">    send_user &quot;usage: $argv0 &lt;remote_passwd&gt; &lt;remote_port&gt; &lt;src_file&gt; &lt;dest_file&gt; \n&quot;</span><br><span class="line">    exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn scp -P $port $src_file $dest_file</span><br><span class="line">    expect &#123;</span><br><span class="line">        &quot;(yes/no)?&quot;</span><br><span class="line">        &#123;</span><br><span class="line">            send &quot;yes\r&quot;</span><br><span class="line">            expect &quot;*assword:&quot; &#123; send &quot;$passwd\r&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;*assword:&quot;</span><br><span class="line">        &#123;</span><br><span class="line">            send &quot;$passwd\r&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">expect &quot;100%&quot;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# chmod +x expect_scp</span><br><span class="line">[root@slions_pc1 ~]# ./expect_scp 123 22 192.168.100.11:/etc/passwd /root/192.168.100.11.passwd_file</span><br><span class="line">spawn scp -P 22 192.168.100.11:/etc/passwd /root/192.168.100.11.passwd_file</span><br><span class="line">root@192.168.100.11&#x27;s password:</span><br><span class="line">passwd                                                                                                                                                 100% 1099   706.8KB/s   00:00</span><br></pre></td></tr></table></figure><h2 id="ssh免密"><a href="#ssh免密" class="headerlink" title="ssh免密"></a>ssh免密</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat ssh.file</span><br><span class="line">192.168.100.10 123</span><br><span class="line">192.168.100.11 123</span><br><span class="line">[root@slions_pc1 ~]# cat sshcopy.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">sed -ri &#x27;35a\StrictHostKeyChecking no&#x27; /etc/ssh/ssh_config</span><br><span class="line">systemctl restart sshd</span><br><span class="line"></span><br><span class="line">if [ ! -f ~/.ssh/id_rsa ]</span><br><span class="line">then</span><br><span class="line">        ssh-keygen -P &quot;&quot; -t rsa -f ~/.ssh/id_rsa</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -f ssh.file ]</span><br><span class="line">then</span><br><span class="line">        echo -e &quot;$&#123;RED_COL&#125;请确认你的ssh.file已经生成$&#123;RESET_COL&#125;&quot;</span><br><span class="line">        break</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">        &#123;</span><br><span class="line">        USER=`whoami`</span><br><span class="line">        IP=`echo $line |awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">        PASSWORD=`echo $line |awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">        /usr/bin/expect &lt;&lt;-EOF</span><br><span class="line">        set timeout -1</span><br><span class="line">        spawn ssh-copy-id $USER@$IP</span><br><span class="line">        expect &#123;</span><br><span class="line">                        &quot;&#123;yes/no&#125;&quot; &#123; send &quot;yes\r&quot;; exp_continue &#125;</span><br><span class="line">                        &quot;password:&quot; &#123; send &quot;$PASSWORD\r&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        expect eof</span><br><span class="line">        EOF</span><br><span class="line">        &#125;&amp;</span><br><span class="line">done &lt; ssh.file</span><br><span class="line">wait</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用ssh和scp时常常需要交互式的输入yes和密码，对于自动化运维中这种还需要人工点击完成的情况就比较烦了，linux的expect工具可以优雅的解决此问题。&lt;/p&gt;
&lt;p&gt;expect是建立在tcl基础上的一个工具，可以让需要交互的任务自动化的完成，相当于是模拟用户进行</summary>
      
    
    
    
    <category term="linux系统" scheme="https://slions.github.io/categories/linux%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="https://slions.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
