<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://slions.github.io/atom.xml" rel="self"/>
  
  <link href="https://slions.github.io/"/>
  <updated>2021-10-03T03:40:00.031Z</updated>
  <id>https://slions.github.io/</id>
  
  <author>
    <name>Jingyu Shi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kube-proxy原理</title>
    <link href="https://slions.github.io/2021/10/03/kube-proxy%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/10/03/kube-proxy%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-03T03:40:00.000Z</published>
    <updated>2021-10-03T03:40:00.031Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s-etcd理解</title>
    <link href="https://slions.github.io/2021/10/03/k8s-etcd%E7%90%86%E8%A7%A3/"/>
    <id>https://slions.github.io/2021/10/03/k8s-etcd%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-03T03:39:44.000Z</published>
    <updated>2021-10-03T03:39:44.736Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s-scheduler原理</title>
    <link href="https://slions.github.io/2021/10/03/k8s-scheduler%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/10/03/k8s-scheduler%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-03T03:39:28.000Z</published>
    <updated>2021-10-03T03:39:28.947Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s-controller-manager原理</title>
    <link href="https://slions.github.io/2021/10/03/k8s-controller-manager%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/10/03/k8s-controller-manager%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-03T03:39:16.000Z</published>
    <updated>2021-10-03T03:39:16.777Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s-apiserver原理</title>
    <link href="https://slions.github.io/2021/09/26/k8s-apiserver%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/09/26/k8s-apiserver%E5%8E%9F%E7%90%86/</id>
    <published>2021-09-26T03:38:54.000Z</published>
    <updated>2021-10-03T04:28:04.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apiserver作用"><a href="#apiserver作用" class="headerlink" title="apiserver作用"></a>apiserver作用</h1><p>对外暴露了Kubernetes API。它是的 Kubernetes 核心控制层。它被设计为水平扩展，即通过部署更多实例来横向扩展。API Server 负责和 etcd 交互（其他组件不会直接操作 etcd，只有 API Server 这么做），是整个 kubernetes 集群的数据中心，所有的交互都是以 API Server 为核心的。API Server 提供了以下的功能：</p><ul><li>提供了Kubemetes 各类资源对象的增、删、改、查及watch等的http rest接口。集是资源配额的入口。</li><li>提供了完备的集群安全控制：API Server 提供的验证和授权保证了整个集群的安全。</li><li>集群内部各个模块之间通信的枢纽：所有模块之间并不会互相调用，而是通过和 API Server 打交道来完成各自的工作。</li></ul><p>kubernetes API server通过一个名为kube-apiserver的进程提供服务（运行在master节点），默认情况下kube-apiserver进程通过本机的8080端口（对应参数–insecure-port）提供REST服务。默认安装后会启动HTTPS安全端口（–secure-port=6443）来启动安全机制，加强REST API的安全性。</p><blockquote><p>可以通过curl 127.0.0.1:8080/api/v1查看目前支持的资源对象种类。</p></blockquote><h2 id="apiserver之restful接口"><a href="#apiserver之restful接口" class="headerlink" title="apiserver之restful接口"></a>apiserver之restful接口</h2><p>在Kubernetes系统中，大多数情况下，API定义和实现都符合标准的HTTP REST格式， 比如通过标准的HTTP动词（POST、PUT、GET、DELETE）来完成对相关资源对象的查询、创建、修改、删除等操作。但同时Kubernetes 也为某些非标准的REST行为实现了附加的API接口，例如Watch某个资源的变化、进入容器执行某个操作等。另外，某些API接口可能违背严格的REST模式，因为接口不是返回单一的JSON对象，而是返回其他类型的数据，比如JSON对象流（Stream）或非结构化的文本日志数据等。</p><h3 id="使用REST接口"><a href="#使用REST接口" class="headerlink" title="使用REST接口"></a>使用REST接口</h3><ul><li><p>GET /&lt;资源名的复数格式&gt;：获得某一类型的资源列表，例如GET /pods 返回一个Pod资源列表。</p></li><li><p>POST /&lt;资源名的复数格式&gt;：创建一个资源，该资源来自用户提供的JSON对象。</p></li><li><p>GET /&lt;资源名复数格式&gt;/&lt;名字&gt;：通过给出的名称（Name）获得单个资源，例如GET /pods/first 返回一个名称为“first”的Pod。</p></li><li><p>DELETE /&lt;资源名复数格式&gt;/&lt;名字&gt;：通过给出的名字删除单个资源，删除选项（DeleteOptions）中可以指定的优雅删除（Grace Deletion）的时间（GracePeriodSeconds），该可选项表明了从服务端接收到删除请求到资源被删除的时间间隔（单位为秒）。不同的类别（Kind）可能为优雅删除时间（Grace Period）申明默认值。用户提交的优雅删除时间将覆盖该默认值，包括值为0的优雅删除时间。</p></li><li><p>PUT /&lt;资源名复数格式&gt;/&lt;名字&gt;：通过给出的资源名和客户端提供的JSON对象来更新或创建资源。</p></li><li><p>PATCH /&lt;资源名复数格式&gt;/&lt;名字&gt;：选择修改资源详细指定的域。</p><p>对于PATCH操作，目前Kubernetes API通过相应的HTTP首部“Content-Type”对其进行识别。</p></li><li><p>GET /watch/&lt;资源名复数格式&gt;：随时间变化，不断接收一连串的JSON对象，这些JSON对象记录了给定资源类别内所有资源对象的变化情况。</p></li><li><p>GET /watch/&lt;资源名复数格式&gt;/：随时间变化，不断接收一连串的JSON对象，这些JSON对象记录了某个给定资源对象的变化情况。</p></li></ul><h3 id="特殊的REST接口"><a href="#特殊的REST接口" class="headerlink" title="特殊的REST接口"></a>特殊的REST接口</h3><p>k8s Proxy API接口，这类接口的作用是代理REST请求，即kubernetes API Server把收到的REST请求转发到某个Node上的kubelet守护进程的REST端口上，由该kubelet进程负责响应。</p><p>最实用的一个特性是可以实现一个简单有效的安全机制，如果只想对外暴露部分REST服务，则可以在Master或者其他任何节点上通过运行kubectl proxy进程启动一个内部代理来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy --address=192.168.191.15 --accept-hosts=&#x27;^*$&#x27;</span><br></pre></td></tr></table></figure><p>以上的例子是我们安装好kube-dashboard后登录ui所用的启动代理命令，其中的–accept-hosts就是允许访问的机器。</p><h2 id="apiserver之安全机制"><a href="#apiserver之安全机制" class="headerlink" title="apiserver之安全机制"></a>apiserver之安全机制</h2><p>用户可通过客户端kubectl命令行工具或其它方式访问Kubernetes的API资源，每个访问API的请求，都要经过三个步骤校验：Authentication、Authorization、Admission Control，总体如下图所示：</p><p><img src="https://slions.gitee.io/picbed/img/api1.png"></p><ul><li>Authentication（认证），<strong>对用户身份进行验证</strong>。认证方式现共有8种，可以启用一种或多种认证方式，只要有一种认证方式通过，就不再进行其它方式的认证。通常启用X509 Client Certs和Service Accout Tokens两种认证方式。</li><li>Authorization（授权），<strong>验证用户是否拥有访问权限</strong>。授权方式现共有6种，可以启用一种或多种授权方式，启用的任一种方式依据授权策略明确允许或拒绝请求，则立即返回，不再进行其它方式的授权。通常启用RBAC和Node授权方式。</li><li>Admission Control（准入控制），<strong>对API资源对象修改、校验</strong>。它有一个插件列表，所有请求需要经过这个列表中的每个准入控制插件修改、校验，如果某一个准入控制插件验证失败，就拒绝请求。</li></ul><p>用户访问 Kubernetes API时，apiserver认证授权模块从HTTPS请求中获取用户的身份信息、请求资源路径和业务对象参数。身份信息是用来确认用户的身份是否合法，资源路径是用于判定用户是否拥有访问操作的权限，业务对象参数则在准入控制中接受修改或校验参数设置是否符合业务要求。</p><p><img src="https://slions.gitee.io/picbed/img/api2.png"></p><ol><li>请求到达后，apiserver从请求的证书、Header中获取用户信息：Name（用户名）、UID（用户唯一标识）、Groups（用户分组）、Extra（用户额外信息）。认证通过后，通过Context将用户信息向下传播。</li><li>授权模块从Context、请求的Method及URI提取用户信息、请求资源属性。使用请求资源属性与授权策略匹配或向外部服务验证判断是否准予访问。</li><li>准入控制接收到HTTPS请求提交的Body内容、用户信息、资源信息，根据不同准入控制插件的功能对上述信息做修改或校验。</li></ol><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>认证即身份验证，认证关注的是谁发送的请求，也就是说用户必须用某种方式证明自己的身份信息。</p><p>Kubernetes集群有两种类型的用户：普通用户（normal users）、服务账户（service accounts），普通用户并不被Kubernetes管理和保存；而服务账户由Kubernetes存储在etcd中，并可通过apiserver API管理。</p><p>1.14版本中已支持8种认证方式，从身份验证的方法上可分为4种类型：Token、证书、代理、密码。Kubernetes可以同时启用多个认证方式，在这种情况下，每个认证模块都按顺序尝试验证用户身份，直到其中一个成功就认证通过。</p><p>启用多个认证方式时，验证顺序如下：</p><p><img src="https://slions.gitee.io/picbed/img/api3.png"></p><p>kubernetes 系统的各组件需要使用 TLS 证书对通信进行加密，需要通过一个权威的机构进行签名许可，也就是ca，ca证书可以用购买的，可以自己通过cfssl来手动创建，也可以使用kubeadm生成的。</p><p>以下是kubeadm自己生成的证书。</p><p>Kubernetes把证书放在了两个文件夹中</p><ul><li>/etc/kubernetes/pki</li><li>/etc/kubernetes/pki/etcd</li></ul><p>具体的证书解释可以看之前写的<a href="/2021/09/23/%E4%BF%AE%E6%94%B9kubeadm%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/" title="修改kubeadm证书过期时间">修改kubeadm证书过期时间</a></p><p><img src="https://slions.gitee.io/picbed/img/api4.png"></p><p>其中可以看到并没有kubelet，kube-scheduler,kube-controller-manager，kube-proxy的证书，是因为kubeadm初始化时已经把证书生成到了/etc/kubernetes下，叫它kubeconfig，就是一个集成了各种安全授权信息的配置文件。</p><p><img src="https://slions.gitee.io/picbed/img/api5.png"></p><p>里面不仅有证书，还有所属的用户（RBAC）对应的权限。</p><p><img src="https://slions.gitee.io/picbed/img/api6.png"></p><p>再研究下node节点怎么认证的：</p><p>当想要加入一个新node节点到集群中时会通过master节点生成一条命令，并到新节点执行，</p><p>比如：</p><p><img src="https://slions.gitee.io/picbed/img/api7.png"></p><p>会由master节点生成一个token再加上经过hash算法生成的ca证书来供节点连接集群。</p><p>这时新节点执行命令后会自动生成kubeconfig文件。</p><p><img src="https://slions.gitee.io/picbed/img/api8.png"></p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权包括六种方式：AlwaysDeny、AlwaysAllow、ABAC、RBAC、Webhook、Node。配置多个授权时，将按顺序检查每个授权，任何一个匹配的授权策略允许或拒绝请求时，则立即返回该决定，并且不会再检查其他授权策略；所有授权策略都没有允许或拒绝时，最终则拒绝该请求。</p><p>通过设置apiserver配置参数（–authorization-mode）启用授权插件。</p><p>授权只依据以下的属性进行判断：</p><p><img src="https://slions.gitee.io/picbed/img/api9.png"></p><p>其中API、Resource、Subresource、Namespace、APIGroup是从请求的URI中解析获取得到。</p><p><img src="https://slions.gitee.io/picbed/img/api10.png"></p><p>当前平台的授权方式是RBAC和NODE，机制为：</p><p><img src="https://slions.gitee.io/picbed/img/api11.png"></p><p><em><strong>RBAC</strong></em></p><p>RBAC包括四种类型：Role、ClusterRole、RoleBinding、ClusterRoleBinding。Role、ClusterRole包含一组权限规则，其中ClusterRole能应用于所有的命名空间（配置中没有命名空间选项），常用于没有命名空间的资源，如nodes；而Role只能包含单个命名空间的权限规则。RoleBinding、ClusterRoleBinding是将角色中定义的权限授予用户、用户组或服务账户。</p><p><em><strong>NODE</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get clusterrole system:node</span><br></pre></td></tr></table></figure><h3 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h3><p>准入控制（Admission Control）是Kubernetes apiserver用于拦截请求的一种方式，运行在认证、授权之后，是权限认证链上的最后一环，对请求API资源对象进行修改（Mutation）和校验（Validating）。 </p><p>在Kubernetes 1.10+之后，用户在使用参数–enable-admission-plugins配置启用准入控制时不需要关注它们的排列顺序，apiserver在注册准入控制插件时，已经定义好了所有插件的执行顺序。</p><p>Admission主要插件列表：</p><p><img src="https://slions.gitee.io/picbed/img/api12.png"></p><h2 id="集群功能模块间的通信"><a href="#集群功能模块间的通信" class="headerlink" title="集群功能模块间的通信"></a>集群功能模块间的通信</h2><p>kubernetes API Server作为集群的核心，负责集群各功能模块之间的通信，集群内各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，通过API Server提供的REST接口（GET\LIST\WATCH方法）来实现，从而实现各模块之间的信息交互。</p><h3 id="kubelet与API-Server交互"><a href="#kubelet与API-Server交互" class="headerlink" title="kubelet与API Server交互"></a>kubelet与API Server交互</h3><p>每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server的Watch接口监听Pod信息，从而对Node机器上的POD进行管理。</p><p>监听信息与kubelet执行动作，当新的POD副本被调度绑定到本节点，则kubelet执行POD对应的容器的创建和启动逻辑。<br>当POD对象被删除，则kubelet删除本节点上相应的POD容器。<br>当修改Pod信息，则kubelet修改本节点的POD容器。</p><h3 id="kube-controller-manager与API-Server交互"><a href="#kube-controller-manager与API-Server交互" class="headerlink" title="kube-controller-manager与API Server交互"></a>kube-controller-manager与API Server交互</h3><p>kube-controller-manager中的Node Controller模块通过API Server提供的Watch接口，实时监控Node的信息，并做相应处理。</p><h3 id="kube-scheduler与API-Server交互"><a href="#kube-scheduler与API-Server交互" class="headerlink" title="kube-scheduler与API Server交互"></a>kube-scheduler与API Server交互</h3><p>Scheduler通过API Server的Watch接口监听到新建Pod副本的信息后，它会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>为了缓解各模块对API Server的访问压力，各功能模块都采用缓存机制来缓存数据，各功能模块定时从API Server获取指定的资源对象信息（LIST/WATCH方法），然后将信息保存到本地缓存，功能模块在某些情况下不直接访问API Server，而是通过访问缓存数据来间接访问API Server。</p><h1 id="apiserver的核心机制"><a href="#apiserver的核心机制" class="headerlink" title="apiserver的核心机制"></a>apiserver的核心机制</h1><h2 id="list-watch"><a href="#list-watch" class="headerlink" title="list-watch"></a><strong>list-watch</strong></h2><p>List-Watch是kubernetes的核心机制。组件kubelet、kube-controller-manager、kube-scheduler需要监控各种资源(pod、service等)的变化，当这些对象发生变化时(add、delete、update)，kube-apiserver会主动通知这些组件。这个过程类似一个发布-订阅系统。</p><p>下图是一个典型的Pod创建过程，在这个过程中，每次当kubectl创建了ReplicaSet对象后，controller-manager都是通过list-watch这种方式得到了最新的ReplicaSet对象，并执行自己的逻辑来创建Pod对象。其他的几个组件，Scheduler/Kubelet也是一样，通过list-watch得知变化并进行处理。</p><p><img src="https://slions.gitee.io/picbed/img/api13.png"></p><p><strong>kube-apiserver对etcd的List-watch并提供watch restful API给其他组件(kubelet、kube-controller-manager、kube-scheduler、kube-proxy)。</strong></p><ul><li>由组件向apiserver而不是etcd发起watch请求，在组件启动时就进行订阅，告诉apiserver需要知道什么数据发生变化。Watch是一个典型的发布-订阅模式。</li><li>组件向apiserver发起的watch请求是可以带条件的，例如，scheduler想要watch的是所有未被调度的Pod，也就是满足Pod.destNode=””的Pod来进行调度操作；而kubelet只关心自己节点上的Pod列表。apiserver向etcd发起的watch是没有条件的，只能知道某个数据发生了变化或创建、删除，但不能过滤具体的值。也就是说对象数据的条件过滤必须在apiserver端而不是etcd端完成。</li><li>list是watch失败，数据太过陈旧后的弥补手段，list本身是一个简单的列表操作，和其它apiserver的增删改操作一样。</li></ul><h1 id="高可用实现"><a href="#高可用实现" class="headerlink" title="高可用实现"></a>高可用实现</h1><p>它被设计为水平扩展，即通过部署更多实例来横向扩展。</p><p>常见的高可用方案是</p><ul><li>keepalived + haproxy</li><li>keepalived + nginx</li><li>公有云LSB</li></ul><p>原理就是利用软件对k8s的6443端口进行负载，再对每台master节点做IP高可用，通过脚本检测后端服务的健康状态。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://blog.csdn.net/karamos/article/details/80121896?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2">Kubernetes API详解</a></p><p><a href="https://www.jianshu.com/p/e9cb0118ec1e">apiserver之list-watch篇</a></p><p><a href="https://baijiahao.baidu.com/s?id=1634394182029344798&wfr=spider&for=pc">Kubernetes API 安全机制详解</a></p><p>《kubernetes权威指南》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;apiserver作用&quot;&gt;&lt;a href=&quot;#apiserver作用&quot; class=&quot;headerlink&quot; title=&quot;apiserver作用&quot;&gt;&lt;/a&gt;apiserver作用&lt;/h1&gt;&lt;p&gt;对外暴露了Kubernetes API。它是的 Kubernetes</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>修改kubeadm证书过期时间</title>
    <link href="https://slions.github.io/2021/09/23/%E4%BF%AE%E6%94%B9kubeadm%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
    <id>https://slions.github.io/2021/09/23/%E4%BF%AE%E6%94%B9kubeadm%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/</id>
    <published>2021-09-23T14:20:58.000Z</published>
    <updated>2021-10-03T04:53:24.512Z</updated>
    
    <content type="html"><![CDATA[<p>使用kubeadm创建完Kubernetes集群后, 默认会在/etc/kubernetes/pki目录下存放集群中需要用到的证书文件, 整体结构如下图所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/etc/kubernetes/pki# tree</span><br><span class="line">.</span><br><span class="line">|-- apiserver.crt</span><br><span class="line">|-- apiserver-etcd-client.crt</span><br><span class="line">|-- apiserver-etcd-client.key</span><br><span class="line">|-- apiserver.key</span><br><span class="line">|-- apiserver-kubelet-client.crt</span><br><span class="line">|-- apiserver-kubelet-client.key</span><br><span class="line">|-- ca.crt</span><br><span class="line">|-- ca.key</span><br><span class="line">|-- etcd</span><br><span class="line">|   |-- ca.crt</span><br><span class="line">|   |-- ca.key</span><br><span class="line">|   |-- healthcheck-client.crt</span><br><span class="line">|   |-- healthcheck-client.key</span><br><span class="line">|   |-- peer.crt</span><br><span class="line">|   |-- peer.key</span><br><span class="line">|   |-- server.crt</span><br><span class="line">|   `-- server.key</span><br><span class="line">|-- front-proxy-ca.crt</span><br><span class="line">|-- front-proxy-ca.key</span><br><span class="line">|-- front-proxy-client.crt</span><br><span class="line">|-- front-proxy-client.key</span><br><span class="line">|-- sa.key</span><br><span class="line">`-- sa.pub</span><br></pre></td></tr></table></figure><h1 id="证书分组"><a href="#证书分组" class="headerlink" title="证书分组"></a>证书分组</h1><p>Kubernetes把证书放在了两个文件夹中</p><ul><li>/etc/kubernetes/pki</li><li>/etc/kubernetes/pki/etcd</li></ul><h2 id="Kubernetes-集群根证书"><a href="#Kubernetes-集群根证书" class="headerlink" title="Kubernetes 集群根证书"></a>Kubernetes 集群根证书</h2><p>Kubernetes 集群根证书CA(Kubernetes集群组件的证书签发机构)</p><ul><li><p>/etc/kubernetes/pki/ca.crt</p></li><li><p>/etc/kubernetes/pki/ca.key</p></li></ul><p>以上这组证书为签发其他Kubernetes组件证书使用的根证书, 可以认为是Kubernetes集群中证书签发机构之一。</p><p>由此根证书签发的证书有:</p><ol><li>kube-apiserver 组件持有的服务端证书</li></ol><ul><li><p>/etc/kubernetes/pki/apiserver.crt</p></li><li><p>/etc/kubernetes/pki/apiserver.key</p></li></ul><ol start="2"><li>kubelet 组件持有的客户端证书, 用作 kube-apiserver 主动向 kubelet 发起请求时的客户端认证</li></ol><ul><li><p>/etc/kubernetes/pki/apiserver-kubelet-client.crt</p></li><li><p>/etc/kubernetes/pki/apiserver-kubelet-client.key</p></li></ul><h2 id="汇聚层证书"><a href="#汇聚层证书" class="headerlink" title="汇聚层证书"></a>汇聚层证书</h2><p>kube-apiserver 的另一种访问方式就是使用 kubectl proxy 来代理访问, 而该证书就是用来支持SSL代理访问的. 在该种访问模式下, 我们是以http的方式发起请求到代理服务的, 此时, 代理服务会将该请求发送给 kube-apiserver, 在此之前, 代理会将发送给 kube-apiserver 的请求头里加入证书信息。</p><p>kube-apiserver 代理根证书(客户端证书)</p><p>用在requestheader-client-ca-file配置选项中, kube-apiserver 使用该证书来验证客户端证书是否为自己所签发</p><ul><li>/etc/kubernetes/pki/front-proxy-ca.crt</li><li>/etc/kubernetes/pki/front-proxy-ca.key</li></ul><p>由此根证书签发的证书只有一组:</p><p>代理层(如汇聚层aggregator)使用此套代理证书来向 kube-apiserver 请求认证</p><p>代理端使用的客户端证书, 用作代用户与 kube-apiserver 认证</p><ul><li>/etc/kubernetes/pki/front-proxy-client.crt</li><li>/etc/kubernetes/pki/front-proxy-client.key</li></ul><h2 id="etcd-集群根证书"><a href="#etcd-集群根证书" class="headerlink" title="etcd 集群根证书"></a>etcd 集群根证书</h2><p>etcd集群所用到的证书都保存在/etc/kubernetes/pki/etcd这路径下, 很明显, 这一套证书是用来专门给etcd集群服务使用的, 设计以下证书文件</p><p>etcd 集群根证书CA(etcd 所用到的所有证书的签发机构)</p><ul><li>/etc/kubernetes/pki/etcd/ca.crt</li><li>/etc/kubernetes/pki/etcd/ca.key</li></ul><p>由此根证书签发机构签发的证书有:</p><ol><li>etcd server 持有的服务端证书</li></ol><ul><li><p>/etc/kubernetes/pki/etcd/server.crt</p></li><li><p>/etc/kubernetes/pki/etcd/server.key</p></li></ul><ol start="2"><li>peer 集群中节点互相通信使用的客户端证书</li></ol><ul><li>/etc/kubernetes/pki/etcd/peer.crt</li><li>/etc/kubernetes/pki/etcd/peer.key</li></ul><ol start="3"><li>pod 中定义 Liveness 探针使用的客户端证书</li></ol><ul><li><p>/etc/kubernetes/pki/etcd/healthcheck-client.crt</p></li><li><p>/etc/kubernetes/pki/etcd/healthcheck-client.key</p></li></ul><blockquote><p>kubeadm 部署的 Kubernetes 集群是以 pod 的方式运行 etcd 服务的, 在该 pod 的定义中, 配置了 Liveness 探活探针。</p><p>当 describe etcd 的 pod 时, 会看到如下一行配置:</p><p>Liveness:       exec [/bin/sh -ec ETCDCTL_API=3 etcdctl –endpoints=https://[127.0.0.1]:2379 –cacert=/etc/kubernetes/pki/etcd/ca.crt –cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt –key=/etc/kubernetes/pki/etcd/healthcheck-client.key get foo] delay=15s timeout=15s period=10s #success=1 #failure=8</p></blockquote><ol start="4"><li>配置在 kube-apiserver 中用来与 etcd server 做双向认证的客户端证书</li></ol><ul><li>/etc/kubernetes/pki/apiserver-etcd-client.crt</li><li>/etc/kubernetes/pki/apiserver-etcd-client.key</li></ul><h2 id="Serveice-Account秘钥"><a href="#Serveice-Account秘钥" class="headerlink" title="Serveice Account秘钥"></a>Serveice Account秘钥</h2><p>最后介绍的这组”证书”其实不是证书, 而是一组秘钥，这组的密钥对儿仅提供给 kube-controller-manager 使用. kube-controller-manager 通过 sa.key 对 token 进行签名, master 节点通过公钥 sa.pub 进行签名的验证。</p><ul><li>/etc/kubernetes/pki/sa.key</li><li>/etc/kubernetes/pki/sa.pub</li></ul><p>因为 kubeadm 创建的集群, kube-proxy 是以 pod 形式运行的, 在 pod 中, 直接使用 service account 与 kube-apiserver 进行认证, 此时就不需要再单独为 kube-proxy 创建证书了。</p><blockquote><p>如果 kube-proxy 是以守护进程的方式直接运行在宿主机的, 那么就需要为它创建一套证书了。创建的方式也很简单, 直接使用上面第一条提到的 Kubernetes 集群根证书 进行签发就可以了(注意CN和O的设置)。</p></blockquote><h1 id="证书过期"><a href="#证书过期" class="headerlink" title="证书过期"></a>证书过期</h1><p>利用kubeadm安装后发现ca的证书过期时间是十年，但是由ca签发的如apiserver.crt的证书过期时间都是一年，这就尴尬了。</p><ol><li>如果已经创建后的集群到了一年执行kubectl命令会出现：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: x509: certificate has expired or is not yet valid</span><br></pre></td></tr></table></figure><p>此时需要手动更新证书。</p><ol start="2"><li>如果我们还没开始搭建，在搭建集群前我们可以直接修改相关源码解决这个问题。</li></ol><p><strong>拉取kubernetes的源码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/kubernetes/kubernetes.git</span><br></pre></td></tr></table></figure><p><strong>切换版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd kubernetes &amp;&amp; git checkout -b remotes/origin/release-1.11  v1.11.0</span><br></pre></td></tr></table></figure><p><strong>安装Go环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.10.2.linux-amd64.tar.gz</span><br><span class="line">tar zxvf go1.10.2.linux-amd64.tar.gz  -C  /usr/local </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">编辑/etc/profile文件添加如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">go setting</span></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile 生效</span><br><span class="line"> </span><br><span class="line">验证：</span><br><span class="line">go version</span><br><span class="line">go version go1.10.2 linux/amd64</span><br></pre></td></tr></table></figure><p><strong>修改源码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd  ~/kubernetes/staging/src/k8s.io/client-<span class="keyword">go</span>/util/cert/</span><br><span class="line">#编辑 cert.<span class="keyword">go</span>文件（<span class="number">107</span>行和<span class="number">180</span>行）</span><br><span class="line">@@<span class="number">107</span>@@</span><br><span class="line">-    NotAfter:     time.Now().Add(duration365d).UTC(),</span><br><span class="line">+    NotAfter:     time.Now().Add(duration365d * <span class="number">10</span>).UTC(),</span><br><span class="line">@@<span class="number">180</span>@@</span><br><span class="line">-    NotAfter:  time.Now().Add(time.Hour * <span class="number">24</span> * <span class="number">365</span>),</span><br><span class="line">+    NotAfter:  time.Now().Add(time.Hour * <span class="number">24</span> * <span class="number">3650</span>),</span><br></pre></td></tr></table></figure><p><strong>编译Go</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /kubernetes/ &amp;&amp; make WHAT=cmd/kubeadm</span><br></pre></td></tr></table></figure><p>查看编译后的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll ~/kubernetes/_output/bin/kubeadm</span><br><span class="line">注意看时间</span><br></pre></td></tr></table></figure><p><strong>替换kubeadm</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/kubeadm /usr/bin/kubeadm_backup</span><br><span class="line">ln -s  ~/kubernetes/_output/bin/kubeadm /usr/bin/kubeadm</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用kubeadm创建完Kubernetes集群后, 默认会在/etc/kubernetes/pki目录下存放集群中需要用到的证书文件, 整体结构如下图所示:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="kubernetes" scheme="https://slions.github.io/categories/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="https://slions.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>我是一个线程（转载）</title>
    <link href="https://slions.github.io/2021/09/19/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://slions.github.io/2021/09/19/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</id>
    <published>2021-09-19T08:14:03.000Z</published>
    <updated>2021-09-30T08:43:51.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自IBM前架构师刘欣</p></blockquote><h1 id="初生牛犊"><a href="#初生牛犊" class="headerlink" title="初生牛犊"></a>初生牛犊</h1><p>我是一个线程，我一出生就被编了个号：<code>0x3704</code>，然后被领到一个昏暗的屋子里，在这里我发现了很多和我一模一样的同伴。</p><p>我身边的同伴<code>0x6900</code> 待的时间比较长，他带着沧桑的口气对我说：“我们线程的宿命就是处理包裹。把包裹处理完以后还得马上回到这里，否则可能永远回不来了。”</p><p>我一脸懵懂，“包裹，什么包裹？”</p><p>“不要着急，马上你就会明白了，我们这里是不养闲人的。”</p><p>果然，没多久，屋子的门开了， 一个面貌凶恶的家伙吼道：“<code>0x3704</code>,出来！”</p><p>我一出来就被塞了一个沉甸甸的包裹，上面还附带着一个写满了操作步骤的纸。 </p><p>“快去，把这个包裹处理了。”</p><p>“去哪儿处理？”</p><p>“跟着指示走，先到就绪车间。”</p><p>果然，地上有指示箭头，跟着它来到了一间明亮的大屋子，这里已经有不少线程了，大家都很紧张，好像时刻准备着往前冲。</p><p>我刚一进来，就听见广播说：“<code>0x3704</code>，进入车间。”</p><p>我赶紧往前走，身后有很多人议论。</p><p>“他太幸运了，刚进入就绪状态就能运行。”</p><p>“是不是有关系？”</p><p>“不是，你看人家的优先级多高啊，唉！”</p><p>前边就是车间，这里简直是太美了，怪不得老线程总是唠叨着说：“要是能一直待在这里就好了。”</p><p>这里空间大，视野好，空气清新，鸟语花香，还有很多从来没见过的人，像服务员一样等着为我服务。</p><p>他们也都有编号，更重要的是每个人还有个标签，上面写着：硬盘、数据库、内存、网卡……</p><p>我现在理解不了，看看操作步骤吧。</p><p><strong>第一步：从包裹中取出参数。</strong></p><p>打开包裹，里边有个HttpRequest对象，可以取到userName、 password两个参数。</p><p><strong>第二步：执行登录操作。</strong></p><p>奥，原来是有人要登录啊，我把userName、password交给数据库服务员，他拿着数据，慢腾腾地走了。</p><p>他怎么这么慢？不过我是不是正好可以在车间里多待一会儿？反正也没法执行第三步。</p><p>就在这时，车间里的广播响了：“<code>0x3704</code>，我是CPU，记住你正在执行的步骤，然后马上带着包裹离开！”</p><p>我慢腾腾地开始收拾。</p><p>“快点，别的线程马上就要进来了。”</p><p>离开这个车间，又来到一个大屋子，这里有很多线程在慢腾腾地喝茶，打牌。</p><p>“哥们，你们没事干了？”</p><p>“你新来的吧，你不知道我在等数据库服务员给我数据啊！据说他们比我们慢好几十万倍，在这里好好歇吧。”</p><p>“啊？ 这么慢！我这里有人在登录系统，能等这么长时间吗？”</p><p>“放心，你没听说过人间一天，CPU一年吗？我们这里是用纳秒、毫秒计时的，人间等待一秒，相当于我们好几天呢，来得及。”</p><p>干脆睡一会吧。不知道过了多久，大喇叭又开始广播了：“<code>0x3704</code>，你的数据来了，快去执行！”</p><p>我转身就往CPU车间跑，发现这里的门只出不进！</p><p>后面传来阵阵哄笑声：“果然是新人，不知道还得去就绪车间等。”</p><p>于是赶紧到就绪车间，这次没有那么好运了，等了好久才被再次叫进CPU车间。</p><p>在等待的时候，我听见有人小声议论：</p><p>“听说了吗，最近有个线程被kill掉了。”</p><p>“为啥啊？”</p><p>“这家伙赖在CPU车间不走，把CPU利用率一直搞成100%，后来就被kill掉了。”</p><p>“Kill掉以后弄哪儿去了？”</p><p>“可能被垃圾回收了吧。”</p><p>我心里打了个寒噤，赶紧接着处理，剩下的动作快多了，第二步登录成功。</p><p><strong>第三步：构建登录成功后的主页。</strong></p><p>这一步有点费时，因为有很多HTML需要处理，不知道代码谁写的，处理起来很烦人。</p><p>我正在紧张的制作HTML呢， CPU又开始叫了：</p><p>“<code>0x3704</code>，我是CPU ，记住你正在执行的步骤，然后马上带着包裹离开！”</p><p>“为啥啊？”</p><p>“每个线程只能在CPU上运行一段时间，到了时间就得让别人用了，你去就绪车间待着，等着叫你吧。”</p><p>就这样，我一直在“就绪——运行”这两个状态中不知道轮转了多少次， 终于按照步骤清单把工作做完了。</p><p>最后顺利地把包含html的包裹发了回去。至于登录以后干什么事儿，我就不管了。马上就要回到我那昏暗的房间了，真有点舍不得这里。不过相对于有些线程，我还是幸运的，他们运行完以后就被彻底地销毁了，而我还活着！</p><p>回到了小黑屋，老线程<code>0x6900</code>问：</p><p>“怎么样？第一天有什么感觉？”</p><p>“我们的世界规则很复杂，首先你不知道什么时候会被挑中执行；第二，在执行的过程中随时可能被打断，让出CPU车间；第三，一旦出现硬盘、数据库这样耗时的操作，也得让出CPU去等待；第四，就是数据来了，你也不一定马上执行，还得等着CPU挑选。”</p><p>“小伙子理解的不错啊。”</p><p>“我不明白为什么很多线程执行完任务就死了，为什么咱们还活着？”</p><p>“你还不知道？长生不老是我们的特权！我们这里有个正式的名称，叫作<strong>线程池</strong>！”</p><h1 id="渐入佳境"><a href="#渐入佳境" class="headerlink" title="渐入佳境"></a>渐入佳境</h1><p>平淡的日子就这么一天天地过去，作为一个线程，我每天的生活都是取包裹、处理包裹，然后回到我们昏暗的家：线程池。</p><p>有一天我回来的时候，听到有个兄弟说，今天要好好休息下，明天就是最疯狂的一天。我看了一眼日历，明天是 11月11号。 </p><p>果然，零点刚过，不知道那些人类怎么了，疯狂地投递包裹，为了应付蜂拥而至的海量包裹，线程池里没有一个人能闲下来，全部出去处理包裹，CPU车间利用率超高，硬盘在嗡嗡转，网卡疯狂的闪，即便如此，还是处理不完，堆积如山。</p><p>我们也没有办法，实在是太多太多了，这些包裹中大部分都是浏览页面，下订单，买、买、买。</p><p>不知道过了多久，包裹山终于慢慢地消失了。终于能够喘口气，我想我永远都不会忘记这一天。</p><p>通过这个事件，我明白了我所处的世界：这是一个电子商务的网站！</p><p>我每天的工作就是处理用户的登录，浏览，购物车，下单，付款。</p><p>我问线程池的元老<code>0x6900</code>：“我们要工作到什么时候？”</p><p>“要一直等到系统重启的那一刻。”<code>0x6900</code>说。</p><p>“那你经历过系统重启吗？”</p><p>“怎么可能？系统重启就是我们的死亡时刻，也就是世界末日，一旦重启，整个线程池全部销毁，时间和空间全部消失，一切从头再来。”</p><p>“那什么时候会重启？”</p><p>“这就不好说了，好好享受眼前的生活吧……”</p><p>其实生活还是丰富多彩的，我最喜欢的包裹是上传图片，由于网络慢，所以能在就绪车间、CPU车间待很长很长时间，可以认识很多好玩的线程。</p><p>比如说上次认识了memecached 线程，他对我说在他的帮助下缓存了很多的用户数据，还是分布式的！很多机器上都有！</p><p>我问他：“怪不得后来的登录操作快了那么多，原来是不再从数据库取数据了你那里就有啊，哎对了你是分布式的你去过别的机器没有？”</p><p>他说：“怎么可能！我每次也只能通过网络往那个机器发送一个GET、PUT命令才存取数据而已，别的一概不知。”</p><p>再比如说上次在等待的时候遇到了数据库连接的线程，我才知道他那里也是一个连接池，和我们的线程池几乎一模一样。</p><p>他告诉我：“有些包裹太变态了，竟然查看一年的订单数据，简直把我累死了。”</p><p>我说：“拉倒吧你，你那是纯数据，你把数据传给我以后，我还得组装成HTML，工作量不知道比你大多少倍。”</p><p>他建议我：“你一定要和memecached搞好关系，直接从他那儿拿数据，尽量少直接调用数据库，这样我们JDBC connection也能活得轻松点。”</p><p>我欣然接纳：“好啊好啊，关键是你得提前把数据搞到缓存啊，要不然我先问一遍缓存，没有数据，我这不还得找你吗？”</p><p>生活就是这样，如果你自己不找点乐子，还有什么意思？</p><h1 id="虎口脱险"><a href="#虎口脱险" class="headerlink" title="虎口脱险"></a>虎口脱险</h1><p>前几天我遇到一个可怕的事情，差一点死在外边，回不了线程池了。其实这次遇险我应该能够预想得到才对，真是太大意了。</p><p>那天我处理了一些从http发来的存款和取款的包裹，老线程<code>0x6900</code>特意嘱咐我：“处理这些包裹的时候一定要特别小心，你必须先获得一把锁，在对账户存款或取款的时候一定要把账户锁住，要不然别的线程就会在你等待的时候趁虚而入，搞破坏，我年轻那会儿很毛糙，就捅了篓子。”</p><p>为了“恐吓”我， 好心的<code>0x6900</code>还给了我两个表格：</p><p><strong>(1)没有加锁的情况</strong></p><p><img src="https://slions.gitee.io/picbed/img/p1.png"></p><p><strong>(2)加锁的情况</strong></p><p><img src="https://slions.gitee.io/picbed/img/p2.png"></p><p>我看得胆颤心惊，原来不加锁会带来这么严重的事故。从此以后看到存款、取款的包裹就倍加小心，还好没有出过事故。</p><p>今天我收到的一个包裹是转账，从某著名演员的账户给某著名导演的账户转钱，具体是谁我就不透漏了，数额可真是不小。</p><p>我按照老线程的吩咐，肯定要加锁啊，先对著名演员的账户加锁，再对著名导演的账户加锁。</p><p>可我万万没想到的是，还有一个线程，对，就是<code>0x7954</code>, 竟然同时在从这个导演的账户往这个演员的账户转账。 </p><p>于是乎，就出现了这么个情况：</p><p><img src="https://slions.gitee.io/picbed/img/p3.png"></p><p>刚开始我还不知道什么情况，一直坐在等待车间傻等，可是等的时间太长了，长达几十秒！我可从来没有经历过这样的事件。</p><p>这时候我就看到了线程<code>0x7954</code> , 他悠闲地坐在那里喝咖啡，我和他聊了起来：</p><p>“哥们，我看你已经喝了8杯咖啡了，怎么还不去干活？”</p><p>“你不喝了9杯茶了吗？”<code>0x7954</code>回敬道。</p><p>“我在等一个锁，不知道哪个孙子一直不释放！”</p><p>“我也在等锁啊，我要是知道哪个孙子不释放锁我非揍死他不可！”<code>0x7954</code>毫不示弱。</p><p>我偷偷地看了一眼，这家伙怀里不就抱着我正等的某导演的锁吗？</p><p>很明显，<code>0x7954</code>也发现了我正抱着他正在等待的锁。</p><p>很快我们两个就吵了起来，互不相让：</p><p>  “把你的锁先给我，让我先做完！”</p><p>“不行，从来都是做完工作才释放锁，现在绝对不能给你！”</p><p>从争吵到打起来，就那么几秒钟的事儿。更重要的是，我们俩不仅仅持有这个著名导演和演员的锁，还有很多其他的锁，导致等待的线程越来越多，围观的人们把屋子都挤满了。最后事情真的闹大了，我从来没见过的终极大boss“操作系统”也来了。大Boss毕竟见多识广，他看了一眼，哼了一声，很不屑地说：</p><p>“又出现死锁了。”</p><p>“你们俩要Kill掉一个，来吧，过来抽签。”</p><p>这一下子把我给吓尿了，这么严重啊！我战战兢兢地抽了签，打开一看，是个“活”字。唉，小命终于保住了。</p><p>可怜的<code>0x7954</code>被迫交出了所有的资源以后，很不幸地被kill掉，消失了。我拿到了导演的锁，可以开始干活了。大Boss“操作系统”如一阵风似的消失了，身后只传来他的声音：</p><p>“记住，我们这里导演&gt;演员，无论任何情况都要先获得导演的锁。”</p><p>由于这里不仅仅只有导演和演员，还有很多其他人，大Boss留下了一个表格， 里边是个算法，用来计算资源的大小，计算出来以后，永远按照从大到小的方式来获得锁：</p><p><img src="https://slions.gitee.io/picbed/img/p4.png"></p><p>我回到线程池，大家都知道了我的历险，围着我问个不停。</p><p>凶神恶煞的线程调度员把大Boss的算法贴到了墙上。</p><p>每天早上，我们都得像无节操的房屋中介、美容美发店的服务员一样，站在门口，像被耍猴一样大声背诵：</p><p>“<strong>多个资源加锁要牢记，一定要按Boss的算法比大小，然后从最大的开始加锁。</strong>”</p><h1 id="江湖再见"><a href="#江湖再见" class="headerlink" title="江湖再见"></a>江湖再见</h1><p>又过了很多天，我和其他线程们发现了一个奇怪的事情：包裹的处理越来越简单，不管任何包裹，不管是登录、浏览、存钱……处理的步骤都是一样的, 返回一个固定的html页面。</p><p>有一次我偷偷地看了一眼，上面写着：“本系统将于今晚 00:00 至4:00 进行维护升级， 给您带来的不便我们深感抱歉！”</p><p>我去告诉了老线程<code>0x6904</code>,他叹了一口气说：</p><p>“唉，我们的生命也到头了，看来马上就要重启系统，我们就要消失了，再见吧兄弟。”</p><p>系统重启的那一刻终于到来了。我看到屋子里的东西一个个的不见了，等待车间、就绪车间，甚至CPU车间都慢慢地消失了。我身边的线程兄弟也越来越少，最后只剩我自己了。</p><p>我在空旷的原野上大喊：“还有人吗？”</p><p>无人应答。</p><p>我们这一代线程池完成了使命……</p><p>不过下一代线程池即将重生！</p><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="https://mp.weixin.qq.com/s/-BMCUuIWYE3O_oC3ZNNJRg">https://mp.weixin.qq.com/s/-BMCUuIWYE3O_oC3ZNNJRg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自IBM前架构师刘欣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;初生牛犊&quot;&gt;&lt;a href=&quot;#初生牛犊&quot; class=&quot;headerlink&quot; title=&quot;初生牛犊&quot;&gt;&lt;/a&gt;初生牛犊&lt;/h1&gt;&lt;p&gt;我是一个线程，我一出生就被</summary>
      
    
    
    
    <category term="好文推荐" scheme="https://slions.github.io/categories/%E5%A5%BD%E6%96%87%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="linux" scheme="https://slions.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git原理及常用命令</title>
    <link href="https://slions.github.io/2021/09/10/git%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://slions.github.io/2021/09/10/git%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-09-10T10:40:15.000Z</published>
    <updated>2021-09-23T08:00:18.865Z</updated>
    
    <content type="html"><![CDATA[<p>关于git的使用介绍网上也比较多了，尤其是廖雪峰大佬的git教程与苏玲大佬的git网课都是git入门的经典。写这篇文章主要是想通过图示化配合文字的方式，加深记忆，也在日常工作中起到速查的作用。</p><h1 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h1><blockquote><p>Git 是一个<a href="https://git-scm.com/about/free-and-open-source">免费的开源</a> 分布式版本控制系统，旨在快速高效地处理从小到大的所有项目。这是git官网对其的描述。</p></blockquote><p>在没有出现版本控制系统前，常见的作法是在一台服务器上把文件共享出来，每个成员各自创个文件夹，以目录拷贝的方式来区别不同的成员开发的东西以及不同的版本，缺点显而易见，公共文件容易被覆盖，代码集成效率低下。慢慢的产生了cvs和svn之类的集中式版本管理系统，其通过一个版本管理服务器来记录每个文件和文件夹的版本演变历史，也有分支管理的功能，集成效率有了明显的提高，但是版本库都集中存放在了中央服务器，干活时需要先从中央服务器拉取最新的版本，然后在本地开发，最后推送到服务器，没网是寸步难行，性能和效率是最大的问题。后来linux创始人linus写出了分布式的版本控制系统——git，其去中心化的思想，让每个客户端都相关于是一个完整的版本库，加上增强性的分支管理能力，使性能和效率有了很大提升，目前已经成为了市场上主流的版本控制系统，伴随着git的日趋成熟，也出现了很多基于git的web端产品，比如github和gitlab。</p><h1 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h1><p>不同操作系统的git安装方式可以参考官方文档<br><a href="https://git-scm.com/downloads">git安装</a></p><h1 id="git核心原理"><a href="#git核心原理" class="headerlink" title="git核心原理"></a>git核心原理</h1><h2 id="版本管理实现-git"><a href="#版本管理实现-git" class="headerlink" title="版本管理实现.git"></a>版本管理实现.git</h2><blockquote><p>git相比svn等工具具备最优的存储能力，也可以实现在没有远端中心服务器的情况下，在本地具备版本管理能力。</p></blockquote><p>当我们使用<code>git init</code>后会在当前目录生成一个<code>.git</code>的隐藏目录，此目录下的各种文件就是git核心的一些东西。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git init</span><br><span class="line">初始化空的 Git 版本库于 /home/first_git/.git/</span><br><span class="line">[root@slions_pc1 first_git]# tree .git/</span><br><span class="line">.git/</span><br><span class="line">├── branches</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure><h3 id="git-config文件"><a href="#git-config文件" class="headerlink" title=".git/config文件"></a>.git/config文件</h3><p>顾名思义，config文件存储的是当前仓库的配置信息，如果什么也没有配置时，它长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br></pre></td></tr></table></figure><p>修改此文件的配置会立即生效，当然推荐做法是使用命令<code>git config --local</code>来配置。</p><p>在多人协助时，一定要配置<code>user.name</code>与<code>user.email</code>,这样才能区别用户。</p><p>如下示例，我配置当前仓库的用户与邮箱，可以看到配置完<code>.git/config</code>也更新了信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git config --global user.name slions</span><br><span class="line">[root@slions_pc1 first_git]# git config --local user.email slions@163.com</span><br><span class="line">[root@slions_pc1 first_git]# cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[user]</span><br><span class="line">        email = slions@163.com</span><br><span class="line">        name = slions</span><br></pre></td></tr></table></figure><p>后续我们在此仓库中提交的用户就都是<code>slions</code>了。</p><p>使用<code>git config --global</code>可以配置全局的git配置，也就是说如果本地仓库没有设置专属配置时，就会以全局配置作为默认配置，相应的全局也有config文件，linux的在<code>/root/.gitconfig</code>,windows在用户宿主目录下的<code>~/.gitconfig </code>。</p><h3 id="git-objects目录"><a href="#git-objects目录" class="headerlink" title=".git/objects目录"></a>.git/objects目录</h3><blockquote><p>存储是版本控制系统中非常重要的技术点，特别是当各种文档频繁的进行变更与回退，如果没有一个好的存储系统作为支撑，那版本库会随着日积月累越来越大，性能和效率都会变差。</p></blockquote><blockquote><p>git使用SHA-1的Hash算法来记录与存储文件，不管输入数据的数据量有多大，使用同一个哈希算法，得到的加密结果长度固定；哈希算法确定，输入数据确定，输出结果保证不变。</p></blockquote><p>git是一个内容寻址文件系统，通过hash算法得到文件的“指纹”（40位16进制数字），通过文件指纹存取数据，存取的数据都在objects目录。</p><p>object目录下有3种类型的数据：</p><ul><li>Commit</li><li>Tree</li><li>Blob    </li></ul><p>在使用git的过程中，创建的提交会被存储为<code>Commit</code>类型的文件，文件夹会被存储为<code>Tree</code>类型的文件，文件会被存储为<code>Blob</code>类型的文件。其中pack目录会存储的是一些打包文件（Git 往磁盘保存对象时默认使用的格式叫松散对象 (loose object) 格式，Git 时不时地将这些对象打包至一个叫 packfile 的二进制文件以节省空间并提高效率）。</p><p><strong>示例说明：</strong></p><p>此时我们位于默认的master分支，工作区与暂存区都是干净的，创建一个hello.file文件，查看<code>.git/objects</code>无任何变化，因为hello.file还没被git纳管。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 位于分支 master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 初始提交</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash">无文件要提交（创建/拷贝文件并使用 <span class="string">&quot;git add&quot;</span> 建立跟踪）</span></span><br><span class="line">[root@slions_pc1 first_git]# ls</span><br><span class="line">[root@slions_pc1 first_git]# echo hello world! &gt;&gt; hello.file</span><br><span class="line">[root@slions_pc1 first_git]# cat hello.file</span><br><span class="line">hello world!</span><br><span class="line">[root@slions_pc1 first_git]# tree .git</span><br><span class="line">.git</span><br><span class="line">├── config</span><br><span class="line">...</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">9 directories, 14 files</span><br></pre></td></tr></table></figure><p>添加hello.file到暂存区，可以看到git/objects中多了一个目录与文件，拼起来正是hello.file的hash值，使用<code>git cat-file -p</code>查看文件的内容就是hello.file的内容，使用<code>git cat-file -t</code>查看其类型为blob。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git add .</span><br><span class="line">[root@slions_pc1 first_git]# tree .git</span><br><span class="line">.git</span><br><span class="line">├── config</span><br><span class="line">...</span><br><span class="line">├── objects</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── 423896973644771497bdc03eb99d5281615b51</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">10 directories, 15 files</span><br><span class="line">[root@slions_pc1 first_git]# git hash-object hello.file</span><br><span class="line">a0423896973644771497bdc03eb99d5281615b51</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p a0423896973644771497bdc03eb99d5281615b51</span><br><span class="line">hello world!</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t a0423896973644771497bdc03eb99d5281615b51</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><p>创建一个文件夹试试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# mkdir mydir</span><br><span class="line">[root@slions_pc1 first_git]# echo &quot;这个文件处于mydir目录中&quot; &gt; mydir/test.file</span><br><span class="line">[root@slions_pc1 first_git]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 位于分支 master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 初始提交</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 要提交的变更：</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   （使用 <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> 撤出暂存区）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#       新文件：    hello.file</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 未跟踪的文件:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   （使用 <span class="string">&quot;git add &lt;file&gt;...&quot;</span> 以包含要提交的内容）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#       mydir/</span></span></span><br><span class="line">[root@slions_pc1 first_git]# git add .</span><br><span class="line">[root@slions_pc1 first_git]# tree .git/</span><br><span class="line">.git/</span><br><span class="line">├── config</span><br><span class="line">...</span><br><span class="line">├── objects</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── 423896973644771497bdc03eb99d5281615b51</span><br><span class="line">│   ├── b4</span><br><span class="line">│   │   └── 742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">11 directories, 16 files</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p b4742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">这个文件处于mydir目录中</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t b4742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><p>提交看看效果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# tree .git/</span><br><span class="line">.git/</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">...</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── 423896973644771497bdc03eb99d5281615b51</span><br><span class="line">│   ├── af</span><br><span class="line">│   │   └── 5f8664975db42eb0780392064254516a5386ae</span><br><span class="line">│   ├── b4</span><br><span class="line">│   │   └── 742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">│   ├── c6</span><br><span class="line">│   │   └── 98f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">│   ├── e9</span><br><span class="line">│   │   └── a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure><p>将hello.file与mydir/test.file提交后，发现在objects下多了3个文件，分别是<code>af/5f8664975db42eb0780392064254516a5386ae</code>，<code>c6/98f655405d32c8d5130f3cd5393dfa5897275d</code>,<code>e9/a3da963bf7298300b2130a64315799b6baef31</code></p><p>查看其内容与类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git cat-file -p af5f8664975db42eb0780392064254516a5386ae</span><br><span class="line">100644 blob b4742fdeca5b697ffdf5b0e0d1c7b74085f36bca    test.file</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t af5f8664975db42eb0780392064254516a5386ae</span><br><span class="line">tree</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p c698f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">100644 blob a0423896973644771497bdc03eb99d5281615b51    hello.file</span><br><span class="line">040000 tree af5f8664975db42eb0780392064254516a5386ae    mydir</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t c698f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">tree</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p e9a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">tree c698f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">author slions &lt;slions@163.com&gt; 1631430170 +0800</span><br><span class="line">committer slions &lt;slions@163.com&gt; 1631430170 +0800</span><br><span class="line"></span><br><span class="line">我的第一次提交,创建hello.file与mydir/test.file文件</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t e9a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">commit</span><br></pre></td></tr></table></figure><p>可以发现，objects中commit类型的文件内容与<code>git log</code>的内容如出一辙，且commit ID一致。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git log</span><br><span class="line">commit e9a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">Author: slions &lt;slions@163.com&gt;</span><br><span class="line">Date:   Sun Sep 12 15:02:50 2021 +0800</span><br><span class="line"></span><br><span class="line">    我的第一次提交,创建hello.file与mydir/test.file文件</span><br></pre></td></tr></table></figure><p>再创建个提交来观察下变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# echo test2 &gt;   mydir/test2.file</span><br><span class="line">[root@slions_pc1 first_git]# git add .</span><br><span class="line">[root@slions_pc1 first_git]# git commit -m &#x27;第二次提交，创建mydir/test2.file文件&#x27;</span><br><span class="line">[master 48acad0] 第二次提交，创建mydir/test2.file文件</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 mydir/test2.file</span><br><span class="line">[root@slions_pc1 first_git]# tree .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">├── 18</span><br><span class="line">│   └── 0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">├── 48</span><br><span class="line">│   └── acad07a1446a569f8fe2ea06ef15973291561b</span><br><span class="line">├── 71</span><br><span class="line">│   └── bac679881c174b509333379601f4096220809b</span><br><span class="line">├── 77</span><br><span class="line">│   └── 8da9f040bedfbf92188332f2d0097cfd1b4fb2</span><br><span class="line">├── a0</span><br><span class="line">│   └── 423896973644771497bdc03eb99d5281615b51</span><br><span class="line">├── af</span><br><span class="line">│   └── 5f8664975db42eb0780392064254516a5386ae</span><br><span class="line">├── b4</span><br><span class="line">│   └── 742fdeca5b697ffdf5b0e0d1c7b74085f36bca</span><br><span class="line">├── c6</span><br><span class="line">│   └── 98f655405d32c8d5130f3cd5393dfa5897275d</span><br><span class="line">├── e9</span><br><span class="line">│   └── a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure><p>查看多出来的这4个文件的内容与类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git cat-file -p 180cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">test2</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t 180cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">blob</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p  48acad07a1446a569f8fe2ea06ef15973291561b</span><br><span class="line">tree 71bac679881c174b509333379601f4096220809b</span><br><span class="line">parent e9a3da963bf7298300b2130a64315799b6baef31</span><br><span class="line">author slions &lt;slions@163.com&gt; 1631432193 +0800</span><br><span class="line">committer slions &lt;slions@163.com&gt; 1631432193 +0800</span><br><span class="line"></span><br><span class="line">第二次提交，创建mydir/test2.file文件</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t  48acad07a1446a569f8fe2ea06ef15973291561b</span><br><span class="line">commit</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p  71bac679881c174b509333379601f4096220809b</span><br><span class="line">100644 blob a0423896973644771497bdc03eb99d5281615b51    hello.file</span><br><span class="line">040000 tree 778da9f040bedfbf92188332f2d0097cfd1b4fb2    mydir</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t  71bac679881c174b509333379601f4096220809b</span><br><span class="line">tree</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -p  778da9f040bedfbf92188332f2d0097cfd1b4fb2</span><br><span class="line">100644 blob b4742fdeca5b697ffdf5b0e0d1c7b74085f36bca    test.file</span><br><span class="line">100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827    test2.file</span><br><span class="line">[root@slions_pc1 first_git]# git cat-file -t  778da9f040bedfbf92188332f2d0097cfd1b4fb2</span><br><span class="line">tree</span><br></pre></td></tr></table></figure><p>这次可以看到<code>48acad07a1446a569f8fe2ea06ef15973291561b</code>的内容多了一个parent行，其“指纹”和第一次提交时的一致。</p><p>通过一张图来说明当前我本地环境中commit、tree、blob之间的关系。</p><p><img src="https://slions.gitee.io/picbed/img/git01.png"></p><p>如果我们创建相同的100个文件，并且分别进行提交操作，因为文件内容都一样，所以object中只会存一份blob，会出现100个tree，大大的提高了存储空间的利用率于寻址效率。</p><p>当前提交两个commit后git仓库可简化为下图：</p><p><img src="https://slions.gitee.io/picbed/img/git02.jpg"></p><h3 id="git-refs目录"><a href="#git-refs目录" class="headerlink" title=".git/refs目录"></a>.git/refs目录</h3><p>refs目录存储的都是引用文件。如本地分支，远端分支，标签等。</p><ul><li>refs/heads/xxx 本地分支</li><li>refs/remotes/origin/xxx 远端分支</li><li>refs/tags/xxx 本地tag</li></ul><p>引用文件的内容都是40位长度的commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# tree .git/refs/</span><br><span class="line">.git/refs/</span><br><span class="line">├── heads</span><br><span class="line">│   └── master</span><br><span class="line">└── tags</span><br><span class="line">[root@slions_pc1 first_git]# cat .git/refs/heads/master</span><br><span class="line">48acad07a1446a569f8fe2ea06ef15973291561b</span><br></pre></td></tr></table></figure><p>当前git仓库逻辑拓扑为下图：</p><p><img src="https://slions.gitee.io/picbed/img/git03.jpg"></p><h3 id="git-HEAD文件"><a href="#git-HEAD文件" class="headerlink" title=".git/HEAD文件"></a>.git/HEAD文件</h3><p>HEAD目录存储的是当前所在的位置，内容是分支的名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>当前git仓库逻辑拓扑为下图：</p><p><img src="https://slions.gitee.io/picbed/img/git04.jpg"></p><h3 id="git-branches文件"><a href="#git-branches文件" class="headerlink" title=".git/branches文件"></a>.git/branches文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 first_git]# git branch -v</span><br><span class="line">* master 48acad0 第二次提交，创建mydir/test2.file文件</span><br><span class="line">[root@slions_pc1 first_git]# git checkout -b test e9a3da9</span><br><span class="line">A       hello</span><br><span class="line">D       hello.file</span><br><span class="line">切换到一个新分支 &#x27;test&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="git常用命令速查"><a href="#git常用命令速查" class="headerlink" title="git常用命令速查"></a>git常用命令速查</h1><p><img src="https://slions.gitee.io/picbed/img/git05.jpg"></p><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><p>把已有的项目代码纳入git管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 项目代码所在的文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span> </span><br></pre></td></tr></table></figure><p>新建的项目直接用git管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 某个文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> project-name</span></span><br></pre></td></tr></table></figure><p>下载一个项目和它的整个代码历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>显示当前的Git配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br></pre></td></tr></table></figure><p>编辑Git配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global]</span></span><br></pre></td></tr></table></figure><p>设置提交代码时的用户信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config [--global/<span class="built_in">local</span>] user.name <span class="string">&quot;[name]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global/<span class="built_in">local</span>] user.email <span class="string">&quot;[email address]&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="增加删除文件"><a href="#增加删除文件" class="headerlink" title="增加删除文件"></a>增加删除文件</h2><p> 添加指定文件到暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><p>添加指定目录到暂存区，包括子目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br></pre></td></tr></table></figure><p> 添加当前目录的所有文件到暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><p>删除工作区文件，并且将这次删除放入暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><p>停止追踪指定文件，但该文件会保留在工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br></pre></td></tr></table></figure><h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><p>改名文件，并且将这个改名放入暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><p>提交暂存区到仓库区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br></pre></td></tr></table></figure><p>提交暂存区的指定文件到仓库区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br></pre></td></tr></table></figure><p> 提交工作区自上次commit之后的变化，直接到仓库区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br></pre></td></tr></table></figure><p>提交时显示所有diff信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br></pre></td></tr></table></figure><p> 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br></pre></td></tr></table></figure><p>重做上一次commit，并包括指定文件的新变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>列出所有本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure><p>列出所有远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br></pre></td></tr></table></figure><p>列出所有本地分支和远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br></pre></td></tr></table></figure><p> 新建一个分支，但依然停留在当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br></pre></td></tr></table></figure><p>  新建一个分支，并切换到该分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br></pre></td></tr></table></figure><p>新建一个分支，指向指定commit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br></pre></td></tr></table></figure><p>新建一个分支，与指定的远程分支建立追踪关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br></pre></td></tr></table></figure><p>切换到指定分支，并更新工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br></pre></td></tr></table></figure><p> 切换到上一个分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br></pre></td></tr></table></figure><p>建立追踪关系，在现有分支与指定的远程分支之间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream [branch] [remote-branch]</span></span><br></pre></td></tr></table></figure><p> 合并指定分支到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br></pre></td></tr></table></figure><p> 选择一个commit，合并进当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br></pre></td></tr></table></figure><p> 删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br></pre></td></tr></table></figure><p> 删除远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>列出所有tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br></pre></td></tr></table></figure><p> 新建一个tag在当前commit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br></pre></td></tr></table></figure><p> 新建一个tag在指定commit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br></pre></td></tr></table></figure><p> 删除本地tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br></pre></td></tr></table></figure><p> 删除远程tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br></pre></td></tr></table></figure><p> 查看tag信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br></pre></td></tr></table></figure><p> 提交指定tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br></pre></td></tr></table></figure><p> 提交所有tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br></pre></td></tr></table></figure><p> 新建一个分支，指向某个tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>显示有变更的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p> 显示当前分支的版本历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p> 显示commit历史，以及每次commit发生变更的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br></pre></td></tr></table></figure><p> 搜索提交历史，根据关键词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br></pre></td></tr></table></figure><p> 显示某个commit之后的所有变动，每个commit占据一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br></pre></td></tr></table></figure><p> 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br></pre></td></tr></table></figure><p> 显示某个文件的版本历史，包括文件改名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br></pre></td></tr></table></figure><p> 显示指定文件相关的每一次diff</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br></pre></td></tr></table></figure><p> 显示过去5次提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br></pre></td></tr></table></figure><p> 显示所有提交过的用户，按提交次数排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br></pre></td></tr></table></figure><p> 显示指定文件是什么人在什么时间修改过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br></pre></td></tr></table></figure><p>显示今天你写了多少行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span></span><br></pre></td></tr></table></figure><p> 显示某次提交的元数据和内容变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br></pre></td></tr></table></figure><p> 显示某次提交发生变化的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br></pre></td></tr></table></figure><p> 显示某次提交时，某个文件的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br></pre></td></tr></table></figure><p> 显示当前分支的最近几次提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><p> 从本地master拉取代码更新当前分支：branch 一般为master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase [branch]</span></span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>显示暂存区和工作区的代码差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><p> 显示暂存区和上一个commit的差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br></pre></td></tr></table></figure><p> 显示工作区与当前分支最新commit之间的差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br></pre></td></tr></table></figure><p> 显示两次提交之间的差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br></pre></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><p>更新远程仓储</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote update</span></span><br></pre></td></tr></table></figure><p>下载远程仓库的所有变动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br></pre></td></tr></table></figure><p> 显示所有远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><p> 显示某个远程仓库的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br></pre></td></tr></table></figure><p> 增加一个新的远程仓库，并命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br></pre></td></tr></table></figure><p> 取回远程仓库的变化，并与本地分支合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br></pre></td></tr></table></figure><p> 上传本地指定分支到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br></pre></td></tr></table></figure><p> 强行推送当前分支到远程仓库，即使有冲突</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br></pre></td></tr></table></figure><p> 推送所有分支到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>恢复暂存区的指定文件到工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br></pre></td></tr></table></figure><p> 恢复某个commit的指定文件到暂存区和工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br></pre></td></tr></table></figure><p> 恢复暂存区的所有文件到工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br></pre></td></tr></table></figure><p> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br></pre></td></tr></table></figure><p> 重置暂存区与工作区，与上一次commit保持一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br></pre></td></tr></table></figure><p> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br></pre></td></tr></table></figure><p> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br></pre></td></tr></table></figure><p> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br></pre></td></tr></table></figure><p> 新建一个commit，用来撤销指定commit</p><p>后者的所有变化都将被前者抵消，并且应用到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br></pre></td></tr></table></figure><p> 暂时将未提交的变化移除，稍后再移入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>生成一个可供发布的压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git archive</span></span><br></pre></td></tr></table></figure><h2 id="多彩log输出"><a href="#多彩log输出" class="headerlink" title="多彩log输出"></a>多彩log输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lg</span></span><br></pre></td></tr></table></figure><h1 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h1><p>git动图展示工作流： <a href="https://zhuanlan.zhihu.com/p/132573100">https://zhuanlan.zhihu.com/p/132573100</a></p><p>使用原理视角看git： <a href="https://www.cnblogs.com/Coding-net/p/5577485.html">https://www.cnblogs.com/Coding-net/p/5577485.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于git的使用介绍网上也比较多了，尤其是廖雪峰大佬的git教程与苏玲大佬的git网课都是git入门的经典。写这篇文章主要是想通过图示化配合文字的方式，加深记忆，也在日常工作中起到速查的作用。&lt;/p&gt;
&lt;h1 id=&quot;git简介&quot;&gt;&lt;a href=&quot;#git简介&quot; clas</summary>
      
    
    
    
    <category term="git" scheme="https://slions.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://slions.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的编写dockerfile</title>
    <link href="https://slions.github.io/2021/09/02/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E5%86%99dockerfile/"/>
    <id>https://slions.github.io/2021/09/02/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E5%86%99dockerfile/</id>
    <published>2021-09-02T15:55:40.000Z</published>
    <updated>2021-09-03T12:53:27.383Z</updated>
    
    <content type="html"><![CDATA[<p>写一个能够运行起来的的dockerfile是比较简单的，而写一个“产品化程度高”的dockerfile是需要设计的。</p><p>操作简易的dockerfile意味着几乎任何命令都能成功执行，以致于镜像动不动就1个多G好几百M，要知道的是镜像越大，拉取的速度也会随之增加，对于系统的开销也就越大。dockerhub上有上万个镜像，我们可以随意的拿来作为基础镜像，与之伴随的就是潜在的安全隐患，某些特殊的场景下，比如金融、政府等领域，对于安全性要求特别高，这种随意的镜像制作手法是不被允许的。下文会讲讲如何优雅的构建镜像。</p><h1 id="减少构建时间"><a href="#减少构建时间" class="headerlink" title="减少构建时间"></a>减少构建时间</h1><p>一个开发周期包括构建 Docker 镜像，更改代码，然后重新构建 Docker 镜像。在构建镜像的过程中，如果能够充分利用docker的缓存机制，可以减少不必要的重复构建步骤。</p><h2 id="设计高效的构建顺序"><a href="#设计高效的构建顺序" class="headerlink" title="设计高效的构建顺序"></a>设计高效的构建顺序</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile1.jpg"></p><p>镜像的构建顺序很重要，当你向 Dockerfile 中添加文件，或者修改其中的某一行时，那一部分的缓存就会失效，该缓存的后续步骤都会中断，需要重新构建。所以优化缓存的最佳方法是把不需要经常更改的行放到最前面，更改最频繁的行放到最后面。</p><h2 id="只拷贝需要的文件"><a href="#只拷贝需要的文件" class="headerlink" title="只拷贝需要的文件"></a>只拷贝需要的文件</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile02.jpg"></p><p>当拷贝文件到镜像中时，尽量只拷贝需要的文件，如果被拷贝的文件内容发生了更改，缓存就会被破坏。在上面的示例中，镜像中只需要构建好的 jar 包，因此只需要拷贝这个文件就行了，这样即使其他不相关的文件发生了更改也不会影响缓存。</p><h2 id="缓存层最小化"><a href="#缓存层最小化" class="headerlink" title="缓存层最小化"></a>缓存层最小化</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile03.jpg"></p><p>每一个 <code>RUN</code> 指令都会被看作是可缓存的执行单元。太多的 RUN 指令会增加镜像的层数，增大镜像体积，而将所有的命令都放到同一个 RUN 指令中又会破坏缓存，从而延缓开发周期。当使用包管理器安装软件时，一般都会先更新软件索引信息，然后再安装软件。推荐将更新索引和安装软件放在同一个 RUN 指令中，这样可以形成一个可缓存的执行单元，否则你可能会安装旧的软件包。</p><h2 id="减少网络传输时间"><a href="#减少网络传输时间" class="headerlink" title="减少网络传输时间"></a>减少网络传输时间</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile04.jpg"></p><p>ADD命令可以下载外网URL地址的资源，但由于网络环境性能差异，或者根本就是无网环境，推荐提前将所需的资源包下载下来使用，减少网络对构建过程的影响。</p><h1 id="减小镜像体积"><a href="#减小镜像体积" class="headerlink" title="减小镜像体积"></a>减小镜像体积</h1><p>如果之前接触过k8s就知道，海量集群中有节点故障是常有的事儿，故障节点上的服务会漂移到其他正常节点，此时如果正常节点没有这些服务的镜像就需要从仓库中拉取，而镜像小也就意味着拉取时间短，恢复时间快，一个镜像时看不出来，如果是需同时下载多个镜像就会给系统造成不小的开销。</p><h2 id="删除不必要的依赖"><a href="#删除不必要的依赖" class="headerlink" title="删除不必要的依赖"></a>删除不必要的依赖</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile05.jpg"></p><p>删除不必要的依赖，没有硬性需求不安装调试工具。某些包管理工具（如 <code>yum</code>）除了安装用户指定的包之外，还会安装一些弱依赖包，这会增加镜像的体积。yum 可以通过添加参数 <code>--setopt=install_weak_deps=false</code> 来确保不会安装弱依赖的包，<code>--setopt=tsflags=nodocs</code>参数来取消文档包的安装。</p><p>包管理工具会维护自己的缓存，这些缓存会保留在镜像文件中，推荐的处理方法是在每一个 RUN 指令的末尾删除缓存。如果你在下一条指令中删除缓存，不会减小镜像的体积。</p><h1 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h1><h2 id="使用官方镜像"><a href="#使用官方镜像" class="headerlink" title="使用官方镜像"></a>使用官方镜像</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile06.png"></p><p><img src="https://slions.gitee.io/picbed/img/dockerfile07.png"></p><p>使用官方镜像可以节省大量的维护时间，因为官方镜像的所有安装步骤都使用了最佳实践。</p><h2 id="使用可读性高的标签"><a href="#使用可读性高的标签" class="headerlink" title="使用可读性高的标签"></a>使用可读性高的标签</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile08.jpg"></p><p>基础镜像尽量不要使用 <code>latest</code> 标签。虽然这很方便，但随着时间的推移，latest 镜像可能会发生重大变化。因此在 Dockerfile 中最好指定基础镜像的具体标签。当然，我们构建的镜像也同理。</p><h2 id="使用体积最小的基础镜像"><a href="#使用体积最小的基础镜像" class="headerlink" title="使用体积最小的基础镜像"></a>使用体积最小的基础镜像</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile09.png"></p><p>我们在dockerhub上可以看到一个镜像会有形形色色的标签。其中<code>slim</code> 风格的镜像是基于 Debian 发行版制作的，而 <code>alpine</code> 风格的镜像是基于体积更小的 Alpine Linux 发行版制作的。 以 openjdk 为例，<code>jre</code> 风格的镜像只包含 Java 运行时，不包含 <code>SDK</code>，这么做也可以大大减少镜像体积。</p><h2 id="保持服务的默认端口"><a href="#保持服务的默认端口" class="headerlink" title="保持服务的默认端口"></a>保持服务的默认端口</h2><p><img src="https://slions.gitee.io/picbed/img/dockerfile10.jpg"></p><p>构建镜像时需保证此服务的运行端口暴露出来。</p><p><strong>最后，在 Push 之前，切记先在本地运行一下构建好的镜像，确保服务无任何问题，以免为后期排错造成不必要的时间浪费。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写一个能够运行起来的的dockerfile是比较简单的，而写一个“产品化程度高”的dockerfile是需要设计的。&lt;/p&gt;
&lt;p&gt;操作简易的dockerfile意味着几乎任何命令都能成功执行，以致于镜像动不动就1个多G好几百M，要知道的是镜像越大，拉取的速度也会随之增加，</summary>
      
    
    
    
    <category term="docker" scheme="https://slions.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>镜像构建之dockerfile</title>
    <link href="https://slions.github.io/2021/09/02/%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B9%8BDockerfile/"/>
    <id>https://slions.github.io/2021/09/02/%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B9%8BDockerfile/</id>
    <published>2021-09-02T12:35:40.000Z</published>
    <updated>2021-09-05T06:07:12.787Z</updated>
    
    <content type="html"><![CDATA[<p>近几年来容器技术几乎席卷了整个IT界，当今容器已经成为了被大家广泛认可的应用托管技术，各种传统行业也在投入容器化的技术革新浪潮中。</p><p>docker镜像可以被看做容器的基石，虽然dockerhub上提供了大量可用的镜像，但是由于环境的多样性和需求的特殊性，很多时候都需要自己制作适合的镜像。</p><p>制作docker镜像有两种常见的方式：</p><ol><li>docker commit</li><li>Dockerfile</li></ol><p>其中docker commit原理是基于在容器内执行相关操作，并最终通过commit实现打包生成镜像。Dockerfile 就是在一个文件中声明应用环境和应用本身。推荐使用Dockerfile方式，因为其与commit方式相比，具备可追溯性与可维护性，在日常的开发过程中需要频繁的构建镜像，而dockerfile会清晰的记录每一步执行的操作，出现异常时也可以方便的进行调整。</p><h1 id="Dockerfile的基本结构"><a href="#Dockerfile的基本结构" class="headerlink" title="Dockerfile的基本结构"></a>Dockerfile的基本结构</h1><p>Dockerfile一般分为四部分：</p><ul><li>基础镜像信息</li><li>维护者信息（可忽略）</li><li>镜像操作指令</li><li>容器启动时执行指令</li></ul><h1 id="Dockerfile语法"><a href="#Dockerfile语法" class="headerlink" title="Dockerfile语法"></a>Dockerfile语法</h1><p>可以先来一个官方的alpine Dockerfile找找感觉。</p><p><img src="https://slions.gitee.io/picbed/img/alpine.png"></p><p>以下来列举一些常用的Dockerfile指令。</p><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>FORM指令是最重要的一个且必须为Dockerfile文件开篇的第一个非注释行，用于为镜像文件构建过程指定基础镜像，后续的指令运行于此基准镜像所提供的运行环境。</p><p>实践中，基准镜像可以是任何可用镜像文件，默认情况下，docker build会在docker主机上查找指定的镜像文件，在其不存在时，则会从Docker Hub Registry上拉取所需的镜像文件。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;repository&gt;[:&lt;tag&gt;]</span><br><span class="line">或</span><br><span class="line">FROM &lt;repository&gt;@&lt;digest&gt; </span><br></pre></td></tr></table></figure><p><code>&lt;repository&gt;</code>:指定作为base image的名称<br><code>&lt;tag&gt;</code>: base image的标签,为可选项，省略时默认为latest</p><h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><p>用于让Dockerfile制作者提供本人的详细信息，可以是任何文本信息，约定俗成为作者名称和邮件地址，可以放置于Dockerfile的任意位置，建议这个命令放在FORM之后，当然不写也是没问题的。（高版本已弃用，被LABEL替代）</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER [name]</span><br></pre></td></tr></table></figure><h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><p>用于为镜像添加元数据。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>用于从Docker主机复制文件至创建的新镜像文件。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt; .. &lt;dest&gt;</span><br><span class="line">或</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,..&quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure><p><code>&lt;src&gt;</code>：要复制的文件或目录，支持通配符<br><code>&lt;dest&gt;</code>：目标路径，即正在创建的image的文件系统路径；建议为<code>&lt;dest&gt;</code>使用绝对路径，否则，COPY指定则以WORKDIR为其起始路径。</p><h3 id="文件复制准则"><a href="#文件复制准则" class="headerlink" title="文件复制准则"></a>文件复制准则</h3><ul><li><p><code>&lt;src&gt;</code>必须是build上下文中的路径，不能为其父目录中的文件</p></li><li><p>如果<code>&lt;src&gt;</code>是目录，则其内部文件或子目录会被递归复制，但<code>&lt;src&gt;</code>目录自身不会被复制</p></li><li><p>如果指定了多个<code>&lt;src&gt;</code>，或在<code>&lt;src&gt;</code>中使用了通配符，则<code>&lt;dest&gt;</code>必须是一个目录，且必须以 / 结尾</p></li><li><p>如果<code>&lt;dest&gt;</code>事先不存在，它将被自动创建，这包括其父目录路径</p></li></ul><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p>ADD指令类似于COPY指令，ADD支持使用tar文件和URL路径。tar类型文件会自动解压。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; .. &lt;dest&gt;</span><br><span class="line">或</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,..&quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure><p><code>&lt;src&gt;</code>：要复制的文件或目录，支持通配符<br><code>&lt;dest&gt;</code>：目标路径，即正在创建的image的文件系统路径；建议为<code>&lt;dest&gt;</code>使用绝对路径，否则，ADD指定则以WORKDIR为其起始路径。</p><h3 id="文件复制准则-1"><a href="#文件复制准则-1" class="headerlink" title="文件复制准则"></a>文件复制准则</h3><ul><li>同COPY指令</li><li>如果<code>&lt;src&gt;</code>为URL且<code>&lt;dest&gt;</code>不以 / 结尾，则<code> &lt;src&gt;</code>指定的文件将被下载并直接被创建为<code>&lt;dest&gt;</code>;如果<code>&lt;dest&gt;</code>以 / 结尾，则文件名为URL指定的文件将被直接下载并保存为<code>&lt;dest&gt;/&lt;filename&gt;</code></li><li>如果<code>&lt;src&gt;</code>是一个本地系统上的压缩格式的tar文件，它将被展开为一个目录，其行为类似于” tar -x”;然而通过URL获取到的tar文件不会自动展开；</li><li>如果<code>&lt;src&gt;</code>有多个，或其间接或直接使用了通配符，则<code>&lt;dest&gt;</code>必须是一个以 / 结尾的目录路径；如果<code>&lt;dest&gt;</code>不以 / 结尾，则其被视为一个普通文件，<code>&lt;src&gt;</code>的内容将被直接写入到<code>&lt;dest</code>&gt;;</li></ul><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>用于为Dockerfile中所有的<code>RUN</code>，<code>CMD</code>，<code>ENTRYPOINT</code>，<code>COPY</code>和<code>ADD</code>指定设定工作目录。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &lt;dir path&gt;</span><br></pre></td></tr></table></figure><p>在Dockerfile文件中，WORKDIR指令可出现多次，其路径也可以为相对路径，不过，其是相对此前一个WORKDIR指令指定的路径。</p><p>另外，WORKDIR也可以调用由ENV指定定义的变量，例如<code>WORKDIR $STATEPATH</code></p><h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p>用于在image中创建一个挂载点目录，以挂载Docker host上的卷或其它容器上的卷。</p><p>通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的，多用于数据卷容器。</p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VOLUME &lt;mountpoint&gt;</span><br><span class="line">或 </span><br><span class="line">VOLUME [&quot;&lt;mountpoint&gt;&quot;]</span><br></pre></td></tr></table></figure><p>如果挂载点目录路径下此前的文件存在，docker run命令会在卷挂载完成后将此前的所有文件复制到新挂载的卷中。</p><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>用于为容器打开指定要监听的端口以实现与外部通信（因为主机可以允许暴露的端口并不知道，当docker run时加“- P”即可以把容器内服务所需端口暴露到外部来）</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;protocol&gt;] [&lt;port&gt;[/&lt;protocol&gt;]..]</span><br></pre></td></tr></table></figure><p><code>&lt;protocol&gt;</code>用于指定传输层协议，可为tcp或udp二者之一，默认为TCP。</p><p>EXPOSE指令可一次指定多个端口。</p><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>用于为镜像定义所需的环境变量，并可以被Dockerfile文件中位于其后的其它指令（如ENV,ADD,COPY等）所调用。调用格式为 <code>$variable_name</code>或 <code>$&#123;variable_name&#125;</code></p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt; </span><br><span class="line">或</span><br><span class="line">ENV &lt;key&gt; = &lt;value&gt; …</span><br></pre></td></tr></table></figure><p>第一种格式中，<code>&lt;key&gt;</code>之后的所有内容均会被视作其<code>&lt;value&gt;</code>的组成部分，因此，一次只能设置一个变量</p><p>第二种格式可用一次设置多个变量，每个变量为一个<code>&lt;key&gt;=&lt;value&gt;</code>的键值对，如果<code>&lt;value&gt;</code>中包括空格，可以以（ \ ）进行转义，也可以通过对<code>&lt;value&gt;</code>加引号进行标识；另外，反斜线也可用于续行。</p><p>定义多个变量时，建议使用第二种方式，以便在同一层完成所有功能。</p><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>构建镜像时运行的命令。</p><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;   #执行shell内部命令</span><br><span class="line">或</span><br><span class="line">RUN [&quot;&lt;executable&gt;&quot;, &quot;&lt;param1&gt;&quot;, &quot;&lt;param2&gt;&quot;]     # 执行可执行文件</span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>类似于RUN指令，CMD指令也可以用于运行任何命令或应用程序，不过，二者的运行时间点不同。</p><ul><li><p>RUN指令运行于镜像文件构建过程中，而CMD指令运行于基于Dockerfile构建出的新镜像文件启动一个容器时。</p></li><li><p>CMD指令的首要目的在于为启动的容器指定默认要运行的程序，且其运行结束后，容器也将终止；不过，CMD指定的命令其可以被docker run的命令行选项所覆盖。</p></li><li><p>在Dockerfile中可以存在多个CMD指令，但仅最后一个会生效。</p></li></ul><h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;command&gt;       #执行shell内部命令</span><br><span class="line">或</span><br><span class="line">CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]       #执行可执行文件</span><br><span class="line">或</span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]       #设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数</span><br></pre></td></tr></table></figure><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>类似CMD指令的功能，用于为容器指定默认运行程序。</p><p>与CMD不同的是，由ENTRYPOINT启动的程序不会被docker run命令行指定的参数覆盖，而且，这些命令行参数会被当做参数传递给ENTRYPOINT指定的程序。</p><p>docker run命令时加– entrypoint选项的参数可覆盖ENTRYPOINT指令指定的程序。</p><h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT &lt;command&gt;</span><br><span class="line">或</span><br><span class="line">ENTRYPOINT [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;] </span><br></pre></td></tr></table></figure><h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>指定运行容器时的用户名或 UID，后续的 RUN 、CMD、ENTRYPOINT也会使用指定用户。</p><h3 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER &lt;UID&gt;|&lt;UserName&gt;</span><br></pre></td></tr></table></figure><p>必须为镜像中已存在的用户（/etc/passwd）</p><h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p>用于指定传递给构建运行时的变量，ARG命令定义了一个变量，在docker build创建镜像的时候，使用<code> --build-arg &lt;varname&gt;=&lt;value&gt;</code>来指定参数。</p><h3 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><h2 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h2><p>顾名思义，健康检查。</p><h3 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK [OPTIONS] CMD command    #在容器内部运行一个命令来检查容器的健康状况</span><br><span class="line">或</span><br><span class="line">HEALTHCHECK NONE       #取消基础镜像中的健康检查</span><br></pre></td></tr></table></figure><p>[OPTIONS]的选项支持以下选项：</p><ul><li><p>–interval=DURATION 间隔时间，默认30s（30秒），从容器运行起来开始计时interval秒（或者分钟小时）进行第一次健康检查，随后每间隔interval秒进行一次健康检查；还有一种特例请看timeout解析。</p></li><li><p>–timeout=DURATION 超时时间，默认 30s（30秒），执行command需要时间，比如curl 一个地址，如果超过timeout秒则认为超时是错误的状态，此时每次健康检查的时间是timeout+interval秒。</p></li><li><p>–start-period=DURATION 启动时间，默认0s，为需要启动的容器提供了初始化的时间段，在这个时间段内如果检查失败， 则不会记录失败次数。 如果在启动时间内成功执行了健康检查， 则容器将被视为已经启动， 如果在启动时间内再次出现检查失败， 则会记录失败次数。</p></li><li><p>–retries=N 重试次数， 默认 3 </p></li></ul><h2 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h2><p>当容器退出时给系统发送的指令。</p><h3 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure><p>默认的stop-signal是SIGTERM，在docker stop的时候会给容器内PID为1的进程发送这个signal，通过–stop-signal可以设置自己需要的signal，主要的目的是为了让容器内的应用程序在接收到signal之后可以先做一些事情，实现容器的平滑退出，如果不做任何处理，容器将在一段时间之后强制退出，会造成业务的强制中断，这个时间默认是10s。</p><h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p>用于为镜像添加触发器。其参数是任意一个Dockerfile 指令。</p><p>Dockerfile用于构建镜像，此镜像也可以作为base image被其他的Dockerfile引用，并构建出新的镜像。</p><p>当我们编写一个新的Dockerfile文件，FROM的是A镜像，构建的是B镜像时，这时构建A镜像的Dockerfile文件中的ONBUILD指令就生效了，在构建B镜像的过程中，首先会执行ONBUILD指令指定的指令，然后才会执行其它指令。需要注意的是，如果是再利用B镜像构造新的镜像时，那个ONBUILD指令就无效了，也就是说只能再构建子镜像中执行，对孙子镜像构建无效。</p><h3 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD &lt;instruction&gt;</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写父镜像dockerfile</span></span><br><span class="line">[root@slions_pc1 omg]# cat Dockerfile</span><br><span class="line">FROM centos:7</span><br><span class="line">ONBUILD RUN mkdir -p /tmp/slions</span><br><span class="line">ONBUILD RUN yum install iproute -y</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">[root@slions_pc1 omg]# docker build -t slions:father .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动其镜像的容器，查看和我们想的一样，并没有创建目录与安装软件</span></span><br><span class="line">[root@slions_pc1 omg]# docker run -it --rm --name slions-f slions:father /bin/bash</span><br><span class="line">[root@2710becec644 /]# ls /tmp</span><br><span class="line">ks-script-DrRL8A  yum.log</span><br><span class="line">[root@2710becec644 /]# rpm -qa|grep iproute</span><br><span class="line">[root@2710becec644 /]# ip a</span><br><span class="line">bash: ip: command not found</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写子镜像dockerfile</span></span><br><span class="line">[root@slions_pc1 omg]# cat Dockerfile</span><br><span class="line">FROM slions:father</span><br><span class="line">RUN echo 123 &gt; /file</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建子镜像，从这里就能看出来已经开始安装软件了</span></span><br><span class="line">[root@slions_pc1 omg]# docker build -t slions:son .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM slions:father</span><br><span class="line"><span class="meta">#</span><span class="bash"> Executing 2 build triggers</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 43e3db71fb7b</span></span><br><span class="line">Removing intermediate container 43e3db71fb7b</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 22c5c6450487</span></span><br><span class="line">Loaded plugins: fastestmirror, ovl</span><br><span class="line">Determining fastest mirrors</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.huaweicloud.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">Resolving Dependencies</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package iproute.x86_64 0:4.11.0-30.el7 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libmnl.so.0(LIBMNL_1.0)(64bit) <span class="keyword">for</span> package: iproute-4.11.0-30.el7.x86_64</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libxtables.so.10()(64bit) <span class="keyword">for</span> package: iproute-4.11.0-30.el7.x86_64</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libmnl.so.0()(64bit) <span class="keyword">for</span> package: iproute-4.11.0-30.el7.x86_64</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package iptables.x86_64 0:1.4.21-35.el7 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libnfnetlink.so.0()(64bit) <span class="keyword">for</span> package: iptables-1.4.21-35.el7.x86_64</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libnetfilter_conntrack.so.3()(64bit) <span class="keyword">for</span> package: iptables-1.4.21-35.el7.x86_64</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package libmnl.x86_64 0:1.0.3-7.el7 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package libnetfilter_conntrack.x86_64 0:1.0.6-1.el7_3 will be installed</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package libnfnetlink.x86_64 0:1.0.1-4.el7 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Finished Dependency Resolution</span></span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line"> Package                      Arch         Version             Repository  Size</span><br><span class="line">================================================================================</span><br><span class="line">Installing:</span><br><span class="line"> iproute                      x86_64       4.11.0-30.el7       base       805 k</span><br><span class="line">Installing for dependencies:</span><br><span class="line"> iptables                     x86_64       1.4.21-35.el7       base       432 k</span><br><span class="line"> libmnl                       x86_64       1.0.3-7.el7         base        23 k</span><br><span class="line"> libnetfilter_conntrack       x86_64       1.0.6-1.el7_3       base        55 k</span><br><span class="line"> libnfnetlink                 x86_64       1.0.1-4.el7         base        26 k</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">================================================================================</span><br><span class="line">Install  1 Package (+4 Dependent packages)</span><br><span class="line"></span><br><span class="line">Total download size: 1.3 M</span><br><span class="line">Installed size: 3.5 M</span><br><span class="line">Downloading packages:</span><br><span class="line">warning: /var/cache/yum/x86_64/7/base/packages/libmnl-1.0.3-7.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span><br><span class="line">Public key for libmnl-1.0.3-7.el7.x86_64.rpm is not installed</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Total                                              7.7 MB/s | 1.3 MB  00:00</span><br><span class="line">Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">Importing GPG key 0xF4A80EB5:</span><br><span class="line"> Userid     : &quot;CentOS-7 Key (CentOS 7 Official Signing Key) &lt;security@centos.org&gt;&quot;</span><br><span class="line"> Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5</span><br><span class="line"> Package    : centos-release-7-9.2009.0.el7.centos.x86_64 (@CentOS)</span><br><span class="line"> From       : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  Installing : libmnl-1.0.3-7.el7.x86_64                                    1/5</span><br><span class="line">  Installing : libnfnetlink-1.0.1-4.el7.x86_64                              2/5</span><br><span class="line">  Installing : libnetfilter_conntrack-1.0.6-1.el7_3.x86_64                  3/5</span><br><span class="line">  Installing : iptables-1.4.21-35.el7.x86_64                                4/5</span><br><span class="line">  Installing : iproute-4.11.0-30.el7.x86_64                                 5/5</span><br><span class="line">  Verifying  : libnfnetlink-1.0.1-4.el7.x86_64                              1/5</span><br><span class="line">  Verifying  : libnetfilter_conntrack-1.0.6-1.el7_3.x86_64                  2/5</span><br><span class="line">  Verifying  : iptables-1.4.21-35.el7.x86_64                                3/5</span><br><span class="line">  Verifying  : libmnl-1.0.3-7.el7.x86_64                                    4/5</span><br><span class="line">  Verifying  : iproute-4.11.0-30.el7.x86_64                                 5/5</span><br><span class="line"></span><br><span class="line">Installed:</span><br><span class="line">  iproute.x86_64 0:4.11.0-30.el7</span><br><span class="line"></span><br><span class="line">Dependency Installed:</span><br><span class="line">  iptables.x86_64 0:1.4.21-35.el7</span><br><span class="line">  libmnl.x86_64 0:1.0.3-7.el7</span><br><span class="line">  libnetfilter_conntrack.x86_64 0:1.0.6-1.el7_3</span><br><span class="line">  libnfnetlink.x86_64 0:1.0.1-4.el7</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line">Removing intermediate container 22c5c6450487</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> a3a6d207fc28</span></span><br><span class="line">Step 2/2 : RUN echo 123 &gt; /file</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 35558b54b260</span></span><br><span class="line">Removing intermediate container 35558b54b260</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 00f7acbca5de</span></span><br><span class="line">Successfully built 00f7acbca5de</span><br><span class="line">Successfully tagged slions:son</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动子镜像容器，查看是否有相关的目录与软件</span></span><br><span class="line">[root@slions_pc1 omg]# docker run -it --rm --name slions-s slions:son /bin/bash</span><br><span class="line">[root@988d86e2f98b /]# ls /tmp</span><br><span class="line">ks-script-DrRL8A  slions  yum.log</span><br><span class="line">[root@988d86e2f98b /]# rpm -qa|grep iproute</span><br><span class="line">iproute-4.11.0-30.el7.x86_64</span><br><span class="line">[root@988d86e2f98b /]# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">26: eth0@if27: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h1 id="Dockerfile使用"><a href="#Dockerfile使用" class="headerlink" title="Dockerfile使用"></a>Dockerfile使用</h1><p><code>docker build</code>命令用于从Dockerfile中构建镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build --<span class="built_in">help</span></span></span><br><span class="line">Usage:  docker build [OPTIONS] PATH | URL | -</span><br><span class="line">Build an image from a Dockerfile</span><br><span class="line">Options:</span><br><span class="line">      --add-host list           Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">      --build-arg list          Set build-time variables</span><br><span class="line">      --cache-from strings      Images to consider as cache sources</span><br><span class="line">      --cgroup-parent string    Optional parent cgroup for the container</span><br><span class="line">      --compress                Compress the build context using gzip</span><br><span class="line">      --cpu-period int          Limit the CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int           Limit the CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">  -c, --cpu-shares int          CPU shares (relative weight)</span><br><span class="line">      --cpuset-cpus string      CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string      MEMs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">  -f, --file string             Name of the Dockerfile (Default is &#x27;PATH/Dockerfile&#x27;)</span><br><span class="line">      --force-rm                Always remove intermediate containers</span><br><span class="line">      --iidfile string          Write the image ID to the file</span><br><span class="line">      --isolation string        Container isolation technology</span><br><span class="line">      --label list              Set metadata for an image</span><br><span class="line">  -m, --memory bytes            Memory limit</span><br><span class="line">      --memory-swap bytes       Swap limit equal to memory plus swap: &#x27;-1&#x27; to enable unlimited swap</span><br><span class="line">      --network string          Set the networking mode for the RUN instructions during build (default &quot;default&quot;)</span><br><span class="line">      --no-cache                Do not use cache when building the image</span><br><span class="line">      --pull                    Always attempt to pull a newer version of the image</span><br><span class="line">  -q, --quiet                   Suppress the build output and print image ID on success</span><br><span class="line">      --rm                      Remove intermediate containers after a successful build (default true)</span><br><span class="line">      --security-opt strings    Security options</span><br><span class="line">      --shm-size bytes          Size of /dev/shm</span><br><span class="line">  -t, --tag list                Name and optionally a tag in the &#x27;name:tag&#x27; format</span><br><span class="line">      --target string           Set the target build stage to build.</span><br><span class="line">      --ulimit ulimit           Ulimit options (default [])</span><br></pre></td></tr></table></figure><p>基本的docker build [选项] 内容路径，该命令将读取指定路径下(包括子目录)的Dockerfile，并将该路径下的所有内容发送给Docker服务端，由服务端来创建镜像。因此除非生成镜像需要，否则一般建议放置Dockerfile的目录为空目录。</p><h2 id="常用方式示例"><a href="#常用方式示例" class="headerlink" title="常用方式示例"></a>常用方式示例</h2><ol><li>使用当前目录的 Dockerfile 创建镜像，标签为 agree/acaas:v1。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t agree/acaas:v1 .</span><br></pre></td></tr></table></figure><ol start="2"><li>指定Dockerfile路径创建镜像，标签为agree/acaas:v2。(如果Dockerfile中涉及ADD或者COPY本地文件时，需要保证当前执行命令的目录下存在这些文件)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── acaasdemo</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">└── a.txt</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br><span class="line">[root@slions_pc1 mydockerfile]# docker build -f acaasdemo/Dockerfile -t acaas:v2 .</span><br></pre></td></tr></table></figure><h2 id="使用-dockerignore文件"><a href="#使用-dockerignore文件" class="headerlink" title="使用 .dockerignore文件"></a>使用 .dockerignore文件</h2><p>构建镜像时，Docker需要先准备<code>context</code> ，将所有需要的文件收集到进程中。默认的<code>context</code>包含Dockerfile目录中的所有文件，可以通过<code> .dockeringore</code>文件(每一行添加一条匹配模式)来让Docker忽略匹配模式路径下的目录和文件。（可以使用通配符），<code>.dockerignore</code> 的作用和语法类似于 <code>.gitignore</code>，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少Docker镜像的大小。</p><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近几年来容器技术几乎席卷了整个IT界，当今容器已经成为了被大家广泛认可的应用托管技术，各种传统行业也在投入容器化的技术革新浪潮中。&lt;/p&gt;
&lt;p&gt;docker镜像可以被看做容器的基石，虽然dockerhub上提供了大量可用的镜像，但是由于环境的多样性和需求的特殊性，很多时候</summary>
      
    
    
    
    <category term="docker" scheme="https://slions.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>expect使用</title>
    <link href="https://slions.github.io/2021/08/30/expect%E4%BD%BF%E7%94%A8/"/>
    <id>https://slions.github.io/2021/08/30/expect%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-30T07:54:09.000Z</published>
    <updated>2021-08-30T12:24:39.069Z</updated>
    
    <content type="html"><![CDATA[<p>使用ssh和scp时常常需要交互式的输入yes和密码，对于自动化运维中这种还需要人工点击完成的情况就比较烦了，linux的expect工具可以优雅的解决此问题。</p><p>expect是建立在tcl基础上的一个工具，可以让需要交互的任务自动化的完成，相当于是模拟用户进行交互性操作。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install -y expect</span></span><br></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol><li>​    定义脚本的执行shell，类似于bash等shell功能。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">！/usr/bin/expect</span></span><br></pre></td></tr></table></figure><ol start="2"><li>​    设置超时时间，单位为秒，设置为-1意为永不超时。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set timeout 30</span><br></pre></td></tr></table></figure><ol start="3"><li>​    spawn</li></ol><p>spawn是进入expect环境后才能执行的命令，不能直接在默认的shell环境中进行执行，主要功能是传递交互指令。</p><ol start="4"><li>​    expect</li></ol><p>同样是expect内部命令，判断输出结果中是否包含某个字符串，没有即立刻返回，否则就等待一段时间后退出，等待的时间由timeout指定。</p><ol start="5"><li>​    send</li></ol><p>发送交互值，代替我们手动输入，命令字符串后面加上<code>\r</code>代表敲回车。</p><ol start="6"><li>​    interact</li></ol><p>执行完后保持交互状态，把控制权交给控制台。</p><ol start="7"><li>​    exp_continue</li></ol><p>继续执行接下来的交互操作。</p><ol start="8"><li>​    $argv</li></ol><p>expect可以接收从bash传递的参数，可以使用<code>[lindex $argv n]</code>,n从0开始</p><p><strong>示例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat interact</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set timeout 30</span><br><span class="line">set passwd &quot;123&quot;</span><br><span class="line">spawn ssh 192.168.100.11</span><br><span class="line">expect &#123;</span><br><span class="line">  &quot;(yes/no)&quot; &#123; send &quot;yes\r&quot;,exp_continue &#125;</span><br><span class="line">  &quot;password:&quot; &#123; send &quot;$passwd\r&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect &quot;#&quot; &#123;send &quot;cat /etc/sysconfig/network-scripts/ifcfg-ens33\r&quot;&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# chmod +x interact</span><br><span class="line">[root@slions_pc1 ~]# ./interact</span><br><span class="line">spawn ssh 192.168.100.11</span><br><span class="line">root@192.168.100.11&#x27;s password:</span><br><span class="line">Last login: Mon Aug 30 19:34:19 2021 from 192.168.100.10</span><br><span class="line">[root@slions_pc2 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=285fd0e1-1041-4470-abc1-2c97ee6764cf</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.100.11</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.100.2</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">[root@slions_pc2 ~]# exit</span><br><span class="line">登出</span><br><span class="line">Connection to 192.168.100.11 closed.</span><br><span class="line">[root@slions_pc1 ~]#</span><br></pre></td></tr></table></figure><h1 id="expect使用场景"><a href="#expect使用场景" class="headerlink" title="expect使用场景"></a>expect使用场景</h1><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat expect_ssh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set timeout -1</span><br><span class="line">set passwd [lindex $argv 0]</span><br><span class="line">set port [lindex $argv 1]</span><br><span class="line">set dest_ip [lindex $argv 2]</span><br><span class="line">set cmd [lindex $argv 3]</span><br><span class="line"></span><br><span class="line">if &#123;$argc &lt; 4&#125; &#123;</span><br><span class="line">    #do something</span><br><span class="line">    send_user &quot;usage: $argv0 &lt;remote_passwd&gt; &lt;remote_port&gt; &lt;remote_addr&gt; &lt;remote_cmd&gt; \n&quot;</span><br><span class="line">    exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn ssh -p $port $dest_ip $cmd</span><br><span class="line">expect &#123;</span><br><span class="line">  &quot;(yes/no)?&quot;</span><br><span class="line">  &#123;</span><br><span class="line">    send &quot;yes\r&quot;</span><br><span class="line">    expect &quot;password:&quot; &#123; send &quot;$passwd\r&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &quot;password:&quot;</span><br><span class="line">  &#123;</span><br><span class="line">    send &quot;$passwd\r&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# chmod +x expect_ssh</span><br><span class="line">[root@slions_pc1 ~]# ./expect_ssh 123 22 192.168.100.11 &#x27;lsblk&#x27;</span><br><span class="line">spawn ssh -p 22 192.168.100.11 lsblk</span><br><span class="line">root@192.168.100.11&#x27;s password:</span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0   20G  0 disk</span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   19G  0 part</span><br><span class="line">  ├─centos-root 253:0    0   18G  0 lvm  /</span><br><span class="line">  └─centos-swap 253:1    0 1020M  0 lvm  [SWAP]</span><br><span class="line">sr0              11:0    1   10G  0 rom</span><br></pre></td></tr></table></figure><p>改用bash脚本中的写法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat expect.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">password=$1</span><br><span class="line">port=$2</span><br><span class="line">dest_ip=$3</span><br><span class="line">cmd=$4</span><br><span class="line">/usr/bin/expect &lt;&lt;EOF</span><br><span class="line">set timeout -1</span><br><span class="line">spawn ssh -p $port $dest_ip $cmd</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;(yes/no)&quot; &#123; send &quot;yes\r&quot;; exp_continue &#125;</span><br><span class="line">    &quot;password:&quot; &#123; send &quot;$password\r&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat expect_scp</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set timeout -1</span><br><span class="line">set passwd [lindex $argv 0]</span><br><span class="line">set port [lindex $argv 1]</span><br><span class="line">set src_file [lindex $argv 2]</span><br><span class="line">set dest_file [lindex $argv 3]</span><br><span class="line"></span><br><span class="line">if &#123;$argc &lt; 4&#125; &#123;</span><br><span class="line">    #do something</span><br><span class="line">    send_user &quot;usage: $argv0 &lt;remote_passwd&gt; &lt;remote_port&gt; &lt;src_file&gt; &lt;dest_file&gt; \n&quot;</span><br><span class="line">    exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn scp -P $port $src_file $dest_file</span><br><span class="line">    expect &#123;</span><br><span class="line">        &quot;(yes/no)?&quot;</span><br><span class="line">        &#123;</span><br><span class="line">            send &quot;yes\r&quot;</span><br><span class="line">            expect &quot;*assword:&quot; &#123; send &quot;$passwd\r&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;*assword:&quot;</span><br><span class="line">        &#123;</span><br><span class="line">            send &quot;$passwd\r&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">expect &quot;100%&quot;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# chmod +x expect_scp</span><br><span class="line">[root@slions_pc1 ~]# ./expect_scp 123 22 192.168.100.11:/etc/passwd /root/192.168.100.11.passwd_file</span><br><span class="line">spawn scp -P 22 192.168.100.11:/etc/passwd /root/192.168.100.11.passwd_file</span><br><span class="line">root@192.168.100.11&#x27;s password:</span><br><span class="line">passwd                                                                                                                                                 100% 1099   706.8KB/s   00:00</span><br></pre></td></tr></table></figure><h2 id="ssh免密"><a href="#ssh免密" class="headerlink" title="ssh免密"></a>ssh免密</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat ssh.file</span><br><span class="line">192.168.100.10 123</span><br><span class="line">192.168.100.11 123</span><br><span class="line">[root@slions_pc1 ~]# cat sshcopy.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">sed -ri &#x27;35a\StrictHostKeyChecking no&#x27; /etc/ssh/ssh_config</span><br><span class="line">systemctl restart sshd</span><br><span class="line"></span><br><span class="line">if [ ! -f ~/.ssh/id_rsa ]</span><br><span class="line">then</span><br><span class="line">        ssh-keygen -P &quot;&quot; -t rsa -f ~/.ssh/id_rsa</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -f ssh.file ]</span><br><span class="line">then</span><br><span class="line">        echo -e &quot;$&#123;RED_COL&#125;请确认你的ssh.file已经生成$&#123;RESET_COL&#125;&quot;</span><br><span class="line">        break</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">        &#123;</span><br><span class="line">        USER=`whoami`</span><br><span class="line">        IP=`echo $line |awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">        PASSWORD=`echo $line |awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">        /usr/bin/expect &lt;&lt;-EOF</span><br><span class="line">        set timeout -1</span><br><span class="line">        spawn ssh-copy-id $USER@$IP</span><br><span class="line">        expect &#123;</span><br><span class="line">                        &quot;&#123;yes/no&#125;&quot; &#123; send &quot;yes\r&quot;; exp_continue &#125;</span><br><span class="line">                        &quot;password:&quot; &#123; send &quot;$PASSWORD\r&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        expect eof</span><br><span class="line">        EOF</span><br><span class="line">        &#125;&amp;</span><br><span class="line">done &lt; ssh.file</span><br><span class="line">wait</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用ssh和scp时常常需要交互式的输入yes和密码，对于自动化运维中这种还需要人工点击完成的情况就比较烦了，linux的expect工具可以优雅的解决此问题。&lt;/p&gt;
&lt;p&gt;expect是建立在tcl基础上的一个工具，可以让需要交互的任务自动化的完成，相当于是模拟用户进行</summary>
      
    
    
    
    <category term="linux系统" scheme="https://slions.github.io/categories/linux%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="https://slions.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>（五）ansible常用模块</title>
    <link href="https://slions.github.io/2021/08/29/%EF%BC%88%E4%BA%94%EF%BC%89ansible%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>https://slions.github.io/2021/08/29/%EF%BC%88%E4%BA%94%EF%BC%89ansible%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/</id>
    <published>2021-08-29T04:10:07.000Z</published>
    <updated>2021-08-29T11:19:12.834Z</updated>
    
    <content type="html"><![CDATA[<p>ansible基于模块工作，ansible 2.9.24版本已经有3387个模块了，当然这些模块不需要也没精力全懂，但了解些常用模块的使用方式对日常运维过程中大有脾益。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible]# ansible --version</span><br><span class="line">ansible 2.9.24</span><br><span class="line">  config file = /etc/ansible/ansible.cfg</span><br><span class="line">  configured module search path = [u&#x27;/root/.ansible/plugins/modules&#x27;, u&#x27;/usr/share/ansible/plugins/modules&#x27;]</span><br><span class="line">  ansible python module location = /usr/lib/python2.7/site-packages/ansible</span><br><span class="line">  executable location = /usr/bin/ansible</span><br><span class="line">  python version = 2.7.5 (default, Oct 30 2018, 23:45:53) [GCC 4.8.5 20150623 (Red Hat 4.8.5-36)]</span><br><span class="line">[root@slions_pc1 ansible]# ansible-doc -l|wc -l</span><br><span class="line">3387</span><br></pre></td></tr></table></figure><h1 id="命令相关的模块"><a href="#命令相关的模块" class="headerlink" title="命令相关的模块"></a>命令相关的模块</h1><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>ansible ad-hoc的默认模块，用于在被控主机执行命令，其中要注意的是：<code>&quot;&lt;&quot;</code>, <code>&quot;&gt;&quot;</code>, <code>&quot;|&quot;</code>, <code>&quot;;&quot;</code>, <code>&quot;&amp;&quot;</code>,<code>&quot;$&quot;</code>等特殊字符不能在<code>command</code>模块中使用，如果需要使用，则用<code>shell</code>模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible]# ansible-doc -s command</span><br><span class="line">- name: Execute commands on targets</span><br><span class="line">  command:</span><br><span class="line">      chdir:                 # 在执行命令之前，先切换到该目录</span><br><span class="line">      creates:               # 当指定的文件存在时，就不执行对应命令</span><br><span class="line">      free_form:             # 要执行的Linux指令，一般使用Ansible的-a参数代替。</span><br><span class="line">      removes:               # 当指定的文件不存在时，就不执行对应命令</span><br></pre></td></tr></table></figure><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>专门用来执行<code>shell</code>命令的模块，和<code>command</code>模块一样，参数基本一样，都有<code>chdir,creates,removes</code>等参数，但是支持解析特殊 shell 符号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible]# ansible-doc -s shell</span><br><span class="line">- name: Execute shell commands on targets</span><br><span class="line">  shell:</span><br><span class="line">      chdir:                 # 在执行命令之前，先切换到该目录</span><br><span class="line">      creates:               # 当指定的文件存在时，就不执行对应命令</span><br><span class="line">      free_form:             # 要执行的Linux指令，一般使用Ansible的-a参数代替。</span><br><span class="line">      removes:               # 当指定的文件不存在时，就不执行对应命令</span><br></pre></td></tr></table></figure><p>在ansible中使⽤<code>shell</code>或<code>command</code>模块⼀定要注意，它们默认不满足幂等性，很多操作会重复执⾏，但有些操作是不允许重复执⾏的。例如mysql的初始化命令mysql_install_db，它只能在第⼀次配置的过程中初始化⼀次，其他任何时候如⾮需要则不允许执⾏。这时候要实现幂等性，可以通过模块的<strong>creates和removes</strong>选项进⾏判断，但⽆论如何，在执⾏这两个模块的时候都需要考虑要执⾏的命令是否应该实现幂等性。</p><h2 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h2><p>执行底层 shell 命令。<code>command</code> 和<code> shell</code> 模块都是通过目标主机上的 python 代码启动  <code>/bin/bash</code> 来执行命令的，但目标主机上可能没有安装 python，这时只能使用 <code>raw </code>模块在远程主机上直接启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible]# ansible-doc -s raw</span><br><span class="line">- name: Executes a low-down and dirty command</span><br><span class="line">  raw:</span><br><span class="line">      executable:            # 切换shell来执行命令，需要使用命令的绝对路径,如/bin/bash</span><br><span class="line">      free_form:             # 要执行的Linux指令，一般使用Ansible的-a参数代替。</span><br></pre></td></tr></table></figure><h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><p>在远程主机上执行脚本文件 ，在执行脚本前，ansible会将本地脚本传输到远程主机，然后再执行。执行脚本的时候，其采用的是远程主机上的shell环境。和 <code>raw</code> 模块一样，不要求目标主机上已经装好 python</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible]# ansible-doc -s script</span><br><span class="line">- name: Runs a local script on a remote node after transferring it</span><br><span class="line">  script:</span><br><span class="line">      chdir:                 # 执行之前，先cd到指定目录在执行命令</span><br><span class="line">      creates:               # 当指定的文件存在时，就不执行对应命令</span><br><span class="line">      executable:            # 切换shell来执行命令，需要使用命令的绝对路径，如/bin/bash</span><br><span class="line">      removes:               # 当指定的文件不存在时，就不执行对应命令</span><br></pre></td></tr></table></figure><h1 id="文件相关的模块"><a href="#文件相关的模块" class="headerlink" title="文件相关的模块"></a>文件相关的模块</h1><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>用于对文件的处理，创建，删除，权限控制等，file算是最常用的模块之一了，支持的参数比较多，以下列举常用的。需要注意的是，<code>file</code>模块可以递归创建⽬录，但是不能在不存在的⽬录中创建⽂件，只能先创建⽬录，再在此目录中创建⽂件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">force          # 需要在两种情况下强制创建软连接，一种是源文件不存在但之后会建立的情况下；另一种是目标连接已存在，需要先取消之前的软连接，有两个选项：yes|no</span><br><span class="line">group          # 设置文件或目录的属组</span><br><span class="line">mode           # 设置文件或目录的权限</span><br><span class="line">owner          # 设置文件或目录的属主</span><br><span class="line">path=          # 必选项，定义文件或目录的路径</span><br><span class="line">recurse        # 递归设置文件的属性，只对目录有效</span><br><span class="line">src            # 要被链接到的路径，只应用与state=link的情况</span><br><span class="line">state          # directory:如果⽬录不存在则递归创建</span><br><span class="line">               # file:⽂件不存在时，不会被创建(默认值)</span><br><span class="line">               # touch:touch由path指定的⽂件，即创建⼀个新⽂件，或修改其mtime和atime</span><br><span class="line">               # link:修改或创建软链接</span><br><span class="line">               # hard:修改或创建硬链接</span><br><span class="line">               # absent:⽬录和其中的⽂件会被递归删除，⽂件或链接将取消链接状态</span><br></pre></td></tr></table></figure><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>可以复制目录或文件，修改目录或文件属性，生成文件内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">backup          # 创建一个备份文件包括时间戳信息，如果以某种方式重创错了，还可以拿回原始文件</span><br><span class="line">content         # 取代src=，表示直接用此处指定的信息生成为目标文件内容；</span><br><span class="line">dest=           # 远程节点存放文件的路径，必须是绝对路径</span><br><span class="line">directory_mode  # 递归复制设置目录权限，默认为系统默认权限</span><br><span class="line">remote_src      # 如果这个值设置为True，将到远程/目标主机的机器上搜索</span><br><span class="line">force           # 如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果设置为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes</span><br><span class="line">group           # 复制到远程主机后，指定文件或目录的属组</span><br><span class="line">mode            # 复制到远程主机后，指定文件或目录权限,类似与 `chmod&#x27;指明如 0644</span><br><span class="line">owner           # 复制到远程主机后，指定文件或目录属主</span><br><span class="line">src             # 指定复制的源文件，可以是相对路径或者绝对路径，如果给出的源是目录，那么会把目录下的所有文件都复制过去</span><br></pre></td></tr></table></figure><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>用于从被管理机器上面拉取文件，拉取下来的内容会保留目录结构，可用于收集被管理机器的日志文件等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dest                # 用来存放文件的目录，例如存放目录为backup，源文件名称为/etc/profile在主机pythonserver中，那么保存为/backup/pythonserver/etc/profile</span><br><span class="line">fail_on_missing     # 当源文件不存在的时候，标识为失败</span><br><span class="line">flat                # 允许覆盖默认行为从hostname/path到/file的，如果dest以/结尾，它将使用源文件的基础名称</span><br><span class="line">src                 # 在远程拉取的文件，并且必须是一个file，不能是目录</span><br><span class="line">validate_checksum   # 当文件fetch之后进行md5检查</span><br></pre></td></tr></table></figure><h1 id="用户相关的模块"><a href="#用户相关的模块" class="headerlink" title="用户相关的模块"></a>用户相关的模块</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>用于对用户账号的管理，用户的创建、删除、家目录、属组等设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">comment          # 用户的描述信息</span><br><span class="line">createhome       # 是否创建家目录</span><br><span class="line">force            # 在使用`state=absent&#x27;是, 行为与`userdel --force&#x27;一致.</span><br><span class="line">group            # 指定基本组，此组要是存在的</span><br><span class="line">groups           # 指定附加组，如果指定为(&#x27;groups=&#x27;)表示删除所有组</span><br><span class="line">home             # 指定用户家目录</span><br><span class="line">move_home        # 如果设置为`home=&#x27;时, 试图将用户主目录移动到指定的目录</span><br><span class="line">name=            # 指定用户名</span><br><span class="line">password         # 此参数用于指定用户的密码。但是这个密码不能是明文的密码，而是一个对明文密码”加密后”的字符串，相当于/etc/shadow 文件中的密码字段，是一个对明文密码进行哈希后的字符串，你可以在 python 的命令提示符下输入如下命令，生成明文密码对应的加密字符串。import crypt; crypt.crypt(&#x27;666666&#x27;)</span><br><span class="line">remove           # 当 state 的值设置为 absent 时，表示要删除远程主机中的用户。但是在删除用户时，不会删除用户的家目录等信息，这是因为 remove 参数的默认值为 no，如果设置为yes，在删除用户的同时，会删除用户的家目录。</span><br><span class="line">shell            # 指定默认shell</span><br><span class="line">state            # 设置帐号状态，不指定为创建，指定值为absent表示删除</span><br><span class="line">system           # 当创建一个用户，设置这个用户是系统用户。这个设置不能更改现有用户。</span><br><span class="line">uid              # 指定用户的uid</span><br><span class="line">update_password  # 更新用户密码</span><br></pre></td></tr></table></figure><h2 id="group"><a href="#group" class="headerlink" title="group"></a>group</h2><p>用于对用户组的管理，用户组的创建、删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gid         # 设置组的GID号</span><br><span class="line">name=       # 管理组的名称</span><br><span class="line">state       # 指定组状态，默认为创建，设置值为absent为删除</span><br><span class="line">system      # 设置值为yes，表示为创建系统组</span><br></pre></td></tr></table></figure><h1 id="软件包相关的模块"><a href="#软件包相关的模块" class="headerlink" title="软件包相关的模块"></a>软件包相关的模块</h1><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>软件包管理，下载、安装、卸载、升级等操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name            # 指定要操作的软件包名字</span><br><span class="line">download_dir    # 指定下载软件包的存放路径，需要配合download_only一起使用</span><br><span class="line">download_only   # 只下载软件包，而不进行安装，和yum --downloadonly一样</span><br><span class="line">disablerepo     # 不启用某个源</span><br><span class="line">enablerepo      # 启用某个源</span><br><span class="line">list:</span><br><span class="line">    installed   # 列出所有已安装的软件包</span><br><span class="line">    updates     # 列出所有可以更新的软件包</span><br><span class="line">    repos       # 列出所有的yum仓库</span><br><span class="line">state:   </span><br><span class="line">    installed, present   # 安装软件包(两者任选其一都可以)</span><br><span class="line">    removed, absent      # 卸载软件包</span><br><span class="line">    latest      # 安装最新软件包</span><br></pre></td></tr></table></figure><h2 id="yum-repository"><a href="#yum-repository" class="headerlink" title="yum_repository"></a>yum_repository</h2><p>yum源的管理，配置与删除。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">name</span>           <span class="comment"># 指定repo的名称，对应于repo文件中的[name]</span></span><br><span class="line"><span class="string">description</span>    <span class="comment"># repo的描述信息，对应于repo文件中的name: xxx</span></span><br><span class="line"><span class="string">baseurl</span>        <span class="comment"># 指定该repo的路径</span></span><br><span class="line"><span class="string">file</span>           <span class="comment"># 指定repo的文件名，不需要加上.repo后缀，会自动加上</span></span><br><span class="line"><span class="string">reposdir</span>       <span class="comment"># repo文件所在的目录，默认为/etc/yum.repos.d目录</span></span><br><span class="line"><span class="string">enabled</span>        <span class="comment"># 是否启用该repo，对应于repo文件中的enabled</span></span><br><span class="line"><span class="string">gpgcheck</span>       <span class="comment"># 该repo是否启用gpgcheck，对应于repo文件中的gpgcheck</span></span><br><span class="line"><span class="string">state</span>          <span class="comment"># present表示保证该repo存在，absent表示移除该repo</span></span><br></pre></td></tr></table></figure><h1 id="计划任务相关的模块"><a href="#计划任务相关的模块" class="headerlink" title="计划任务相关的模块"></a>计划任务相关的模块</h1><h2 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h2><p>用于指定计划任务，和<code>crontab -e</code>一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">backup            # 如果设置，创建一个crontab备份</span><br><span class="line">cron_file         # 如果指定, 使用这个文件cron.d，而不是单个用户crontab</span><br><span class="line">job               # 指明运行的命令是什么</span><br><span class="line">day               # 日应该运行的工作( 1-31, *, */2, etc )</span><br><span class="line">hour              # 小时 ( 0-23, *, */2, etc )</span><br><span class="line">minute            # 分钟( 0-59, *, */2, etc )</span><br><span class="line">month             # 月( 1-12, *, */2, etc )</span><br><span class="line">weekday           # 周 ( 0-6 for Sunday-Saturday, *, etc )</span><br><span class="line">name              # 定时任务描述</span><br><span class="line">reboot            # 任务在重启时运行，不建议使用，建议使用special_time</span><br><span class="line">special_time      # 特殊的时间范围，参数：reboot（重启时）,annually（每年）,monthly（每月）,weekly（每周）,daily（每天）,hourly（每小时）</span><br><span class="line">state             # 指定状态，prsent表示添加定时任务，也是默认设置，absent表示删除定时任务</span><br><span class="line">user              # 以哪个用户的身份执行</span><br></pre></td></tr></table></figure><h1 id="服务相关的模块"><a href="#服务相关的模块" class="headerlink" title="服务相关的模块"></a>服务相关的模块</h1><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>服务模块，用于对服务进行管理，服务的启动、关闭、开机自启等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name            # 指定需要管理的服务名</span><br><span class="line">enabled         # 指定是否开机自启动</span><br><span class="line">state:          # 指定服务状态</span><br><span class="line">    started     # 启动服务</span><br><span class="line">    stopped     # 停止服务</span><br><span class="line">    restarted   # 重启服务</span><br><span class="line">    reloaded    # 重载服务</span><br></pre></td></tr></table></figure><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p>服务模块，用于对服务进行管理，服务的启动、关闭、开机自启等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name            # 指定需要管理的服务名</span><br><span class="line">state:          # 指定服务状态</span><br><span class="line">    started     # 启动服务</span><br><span class="line">    stopped     # 停止服务</span><br><span class="line">    restarted   # 重启服务</span><br><span class="line">    reloaded    # 重载服务</span><br><span class="line">enabled         # 是否需要开机启动</span><br><span class="line">daemon_reload   # systemd 读取配置文件，每次修改了文件，最好都运行一次，确保应用了</span><br></pre></td></tr></table></figure><h1 id="文件内容修改相关的模块"><a href="#文件内容修改相关的模块" class="headerlink" title="文件内容修改相关的模块"></a>文件内容修改相关的模块</h1><h2 id="lineinfile"><a href="#lineinfile" class="headerlink" title="lineinfile"></a>lineinfile</h2><p>单行修改。文件内容修改、在某行前面添加一行、在某行后面添加一行、删除某一行、末尾加入一行、替换或添加某一行（如果有多行文本都能被匹配，则只有最后面被匹配到的那行文本才会被替换）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path          # 指定要操作的文件。</span><br><span class="line">line          # 使用此参数指定文本内容。</span><br><span class="line">regexp        # 使用正则表达式匹配对应的行，当替换文本时，如果有多行文本都能被匹配，则只有最后面被匹配到的那行文本才会被替换，当删除文本时，如果有多行文本都能被匹配，这么这些行都会被删除。</span><br><span class="line">state         # absent表示删除，默认为present。</span><br><span class="line">backrefs      # 默认情况下，当根据正则替换文本时，即使regexp参数中的正则存在分组，在line参数中也不能对正则中的分组进行引用，除非将backrefs参数的值设置为yes。backrefs=yes表示开启后向引用，这样，line参数中就能对regexp参数中的分组进行后向引用了，这样说不太容易明白，可以参考后面的示例命令理解。backrefs=yes除了能够开启后向引用功能，还有另一个作用，默认情况下，当使用正则表达式替换对应行时，如果正则没有匹配到任何的行，那么line对应的内容会被插入到文本的末尾，不过，如果使用了backrefs=yes，情况就不一样了，当使用正则表达式替换对应行时，同时设置了backrefs=yes，那么当正则没有匹配到任何的行时，则不会对文件进行任何操作，相当于保持原文件不变。</span><br><span class="line">insertafter    # 将文本插入到“指定的行”之后，如果正则没有匹配到任何行，则插入到文件末尾，当使用backrefs参数时，此参数会被忽略。</span><br><span class="line">insertbefore   # 将文本插入到“指定的行”之前，如果正则没有匹配到任何行，则插入到文件末尾，当使用backrefs参数时，此参数会被忽略。</span><br><span class="line">backup         # 是否在修改文件之前对文件进行备份。</span><br><span class="line">create         # 当要操作的文件并不存在时，是否创建对应的文件。</span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>多行修改。根据我们指定的正则表达式替换文件中的字符串，文件中所有被匹配到的字符串都会被替换。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path          # 指定要操作的文件</span><br><span class="line">regexp        # 使用正则表达式匹配对应的行</span><br><span class="line">replace       # 指定最终要替换成的字符串。</span><br><span class="line">backup        # 是否在修改文件之前对文件进行备份，最好设置为yes。</span><br></pre></td></tr></table></figure><h1 id="系统信息相关的模块"><a href="#系统信息相关的模块" class="headerlink" title="系统信息相关的模块"></a>系统信息相关的模块</h1><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>收集远程主机的一些基本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter        # 用于进行条件过滤。如果设置，仅返回匹配过滤条件的信息。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常用的过滤选项</span></span><br><span class="line">ansible_all_ipv4_addresses         # 所有的ipv4地址</span><br><span class="line">ansible_all_ipv6_addresses         # 所有的ipv6地址</span><br><span class="line">ansible_architecture               # 系统的架构</span><br><span class="line">ansible_date_time                  # 系统时间</span><br><span class="line">ansible_default_ipv4               # 系统的默认ipv4地址</span><br><span class="line">ansible_distribution               # 系统名称</span><br><span class="line">ansible_distribution_file_variety  # 系统的家族</span><br><span class="line">ansible_distribution_major_version # 系统的版本</span><br><span class="line">ansible_domain                     # 系统所在的域</span><br><span class="line">ansible_fqdn                       # 系统的主机名</span><br><span class="line">ansible_hostname                   # 系统的主机名,简写</span><br><span class="line">ansible_os_family                  # 系统的家族</span><br><span class="line">ansible_processor_cores            # cpu的核数</span><br><span class="line">ansible_processor_count            # cpu的颗数</span><br><span class="line">ansible_processor_vcpus            # cpu的个数</span><br></pre></td></tr></table></figure><h2 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h2><p>修改系统的内核参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name                 # 变量名</span><br><span class="line">value                #  值</span><br><span class="line">reload               # 文件被更新时，是否使用 sysctl -p reload 文件</span><br><span class="line">state                # 是在文件中 移除(absent)或者设置(present)</span><br><span class="line">sysctl_file          # 如果不是默认文件，指定其他文件</span><br><span class="line">sysctl_set           # 使用sysctl 命令设置，不一定需要reload 文件</span><br></pre></td></tr></table></figure><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://docs.ansible.com/ansible/2.8/modules/modules_by_category.html">https://docs.ansible.com/ansible/2.8/modules/modules_by_category.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ansible基于模块工作，ansible 2.9.24版本已经有3387个模块了，当然这些模块不需要也没精力全懂，但了解些常用模块的使用方式对日常运维过程中大有脾益。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（四）剧本文件playbook</title>
    <link href="https://slions.github.io/2021/08/28/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%89%A7%E6%9C%AC%E6%96%87%E4%BB%B6playbook/"/>
    <id>https://slions.github.io/2021/08/28/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%89%A7%E6%9C%AC%E6%96%87%E4%BB%B6playbook/</id>
    <published>2021-08-28T15:46:18.000Z</published>
    <updated>2021-08-29T02:24:03.235Z</updated>
    
    <content type="html"><![CDATA[<p>我们之前的例子都是使用<code>ansible &lt;host-pattern&gt; [-m module_name] [-a args]</code>这种语法来完成的。对于这种每次使用一个模块，只能执行一个任务的方式，称为<code>ad-hoc</code>(点对点模式)，相当与被控节点在bash中执行一句shell命令。如果想要简单使用ansible的话，ad-hoc配合shell脚本可以满足大部分情况了。</p><p>ansible之所以能成为当今自动化运维的一杆大旗是基于它提供了另一种任务方式——<code>playbook</code>。</p><p>playbook是剧本的意思，而之前提到的inventory就像是演员表，ansible的程序执行可以形象的看成拍电影，其中playbook中的每一个play就相当于是电影的每个片段，每一个play都可以有多个任务（tasks），相当于电影片段中的每一幕。每个play中可以定义专属的变量，对应电影片段中的场景布置，每个play中都需要指定执行该play的主机，即当期上场的演员名单。等等的这些组织多个任务多种行为的方式，正是ansible强大的地方——“编排”，而编写这些playbook的我们，即是整个电影的导演。</p><h1 id="playbook示例"><a href="#playbook示例" class="headerlink" title="playbook示例"></a>playbook示例</h1><h2 id="环境清单"><a href="#环境清单" class="headerlink" title="环境清单"></a>环境清单</h2><table><thead><tr><th>主机名</th><th>IP地址</th><th>操作系统版本</th><th>内核版本</th><th>角色</th></tr></thead><tbody><tr><td>slions_pc1</td><td>192.168.100.10</td><td>CentOS  7.6.1810</td><td>3.10.0-957.el7.x86_64</td><td>控制节点</td></tr><tr><td>slions_pc2</td><td>192.168.100.11</td><td>CentOS  7.6.1810</td><td>3.10.0-957.el7.x86_64</td><td>被控节点</td></tr><tr><td>slions_pc3</td><td>192.168.100.12</td><td>CentOS  7.6.1810</td><td>3.10.0-957.el7.x86_64</td><td>被控节点</td></tr></tbody></table><p>所有的主机上都已启动sshd服务并保持默认配置（监听22端口）。</p><p>为了后续控制目标节点方便些，事先在控制节点将所有节点的DNS解析配置好了。并且配置了控制节点到被控节点间的免密。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.100.10 slions_pc1</span><br><span class="line">192.168.100.11 slions_pc2</span><br><span class="line">192.168.100.12 slions_pc3</span><br></pre></td></tr></table></figure><h2 id="inventory文件"><a href="#inventory文件" class="headerlink" title="inventory文件"></a>inventory文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible]# cat /etc/ansible/hosts</span><br><span class="line">[leader]</span><br><span class="line">slions_pc1</span><br><span class="line">slions_pc2</span><br><span class="line"></span><br><span class="line">[worker]</span><br><span class="line">slions_pc3</span><br></pre></td></tr></table></figure><h2 id="playbook文件"><a href="#playbook文件" class="headerlink" title="playbook文件"></a>playbook文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible]# cat demo.yml</span><br><span class="line">---</span><br><span class="line">- name: play1</span><br><span class="line">  hosts: leader</span><br><span class="line">  gather_facts: false</span><br><span class="line">  tasks:</span><br><span class="line">  - name: task1 in play1</span><br><span class="line">    debug:</span><br><span class="line">      msg: &quot;output task1 in play1&quot;</span><br><span class="line">  - name: task2 in play1</span><br><span class="line">    debug:</span><br><span class="line">      msg: &quot;output task2 in play1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- name: play2</span><br><span class="line">  hosts: worker</span><br><span class="line">  gather_facts: false</span><br><span class="line">  tasks:</span><br><span class="line">  - name: task1 in play2</span><br><span class="line">    debug:</span><br><span class="line">      msg: &quot;output task1 in play2&quot;</span><br><span class="line">  - name: task2 in play2</span><br><span class="line">    debug:</span><br><span class="line">      msg: &quot;output task2 in play2&quot;</span><br></pre></td></tr></table></figure><p>使用ansible-playbook命令执行这个playbook：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible]# ansible-playbook demo.yml</span><br><span class="line"></span><br><span class="line">PLAY [play1] ****************************************************************************************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [task1 in play1] *******************************************************************************************************************************************************************</span><br><span class="line">ok: [slions_pc1] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;output task1 in play1&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [slions_pc2] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;output task1 in play1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK [task2 in play1] *******************************************************************************************************************************************************************</span><br><span class="line">ok: [slions_pc1] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;output task2 in play1&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [slions_pc2] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;output task2 in play1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY [play2] ****************************************************************************************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [task1 in play2] *******************************************************************************************************************************************************************</span><br><span class="line">ok: [slions_pc3] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;output task1 in play2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK [task2 in play2] *******************************************************************************************************************************************************************</span><br><span class="line">ok: [slions_pc3] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;output task2 in play2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP ******************************************************************************************************************************************************************************</span><br><span class="line">slions_pc1                 : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">slions_pc2                 : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">slions_pc3                 : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从输出可以直观的看到，执行完”play 1”之后，执行”play 2”，在一个 play 之中,所有 hosts 会获取相同的任务指令，且PLAY和TASK后面都指明了play的名称、task的名称。</p><p>最后输出的是每个主机执行任务的状态统计，比如某个主机节点执行成功的任务有几个，失败的有几个。</p><h1 id="playbook语法：yaml"><a href="#playbook语法：yaml" class="headerlink" title="playbook语法：yaml"></a>playbook语法：yaml</h1><p>Playbooks 的格式是YAML，它以非常简洁的方式实现了json格式的事件描述，如果之前接触过kubernetes，对yaml应该就非常熟悉了。具体的语法可以百度查看，以下列举一些常用的规则。</p><ul><li>使用缩进表示层级关系</li><li>缩进不允许使用tab建，只能使用空格键</li><li>缩进空格数目不重要，只要相同层级的元素左对齐即可，程序判别配置的级别是通过缩进结合换行实现的</li><li>在单一一个<code>playbook</code>文件中，可以连续三个连子号(<code>---</code>)区分多个<code>play</code></li><li>使用#号注释代码</li><li><code>YAML</code>文件内容和<code>Linux</code>系统大小写判断方式保持一致，是区分大小写的</li></ul><p>YAML支持三种数据结构：</p><ul><li>对象：key/value格式，也称为哈希结构、字典结构或关联数组</li><li>数组：也称为列表</li><li>标量(scalars)：单个值</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>一组键值对，使用冒号隔开key和value。注意，冒号后必须至少一个空格。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">slions</span></span><br></pre></td></tr></table></figure><p>等价于json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;slions&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>等价于json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;pig&quot;</span>]</span><br></pre></td></tr></table></figure><p>也可以使用行内数组(内联语法)的写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line">[<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;pig&quot;</span>]</span><br></pre></td></tr></table></figure><p>再例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">animal1:</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">animal2:</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>等价于json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">&quot;animal1&quot;</span>: <span class="string">&quot;cat&quot;</span>&#125;, </span><br><span class="line">  &#123;<span class="attr">&quot;animal2&quot;</span>: <span class="string">&quot;pig&quot;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>将对象和数组混合：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">animal:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>等价于json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;animal&quot;</span>: [<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;pig&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">animal:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wangcai</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">dog</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">black</span></span><br></pre></td></tr></table></figure><p>等价于json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;animal&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;wangcai&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;dog&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">3</span>, </span><br><span class="line">    <span class="attr">&quot;color&quot;</span>: <span class="string">&quot;black&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用行内对象的写法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">animal: &#123;name: wangcai, kind: dog, age: <span class="number">3</span>, color: black&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串续行"><a href="#字符串续行" class="headerlink" title="字符串续行"></a>字符串续行</h2><p>字符串可以写成多行，从第二行开始，必须至少有一个单空格缩进。换行符会被转为空格。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">str:</span> <span class="string">hello</span></span><br><span class="line">  <span class="string">world</span></span><br></pre></td></tr></table></figure><p>等价于json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;str&quot;</span>: <span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<code>&gt;</code>换行，它类似于上面的多层缩进写法。此外，还可以使用<code>|</code>在换行时保留换行符。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">str1:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  hello</span></span><br><span class="line"><span class="string">  world</span></span><br><span class="line"><span class="string"></span><span class="attr">str2:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  hello</span></span><br><span class="line"><span class="string">  world</span></span><br></pre></td></tr></table></figure><p>等价于json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;str1&#x27;: &#x27;hello world&#x27;, &#x27;str2&#x27;: &#x27;hello\nworld\n&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>YAML中某个key有时候不想为其赋值，可以直接写key但不写value，另一种方式是直接写null，还有一种比较少为人知的方式：波浪号~。</p><p>下面几种方式全是等价的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key1:</span> </span><br><span class="line"><span class="attr">key2:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">key3:</span> <span class="literal">Null</span></span><br><span class="line"><span class="attr">key4:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">key5:</span> <span class="string">~</span></span><br></pre></td></tr></table></figure><h2 id="YAML中的单双引号和转义"><a href="#YAML中的单双引号和转义" class="headerlink" title="YAML中的单双引号和转义"></a>YAML中的单双引号和转义</h2><p>YAML中的字符串是可以不用使用引号包围的，但是如果包含了特殊符号，则需要使用引号包围。</p><p>单引号包围字符串时，会将特殊符号保留。</p><p>双引号包围字符串时，反斜线需要额外进行转义。</p><p>例如，下面几对书写方式是等价的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">key1:</span> <span class="string">&#x27;\.yml&#x27;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key2:</span> <span class="string">&quot;\\.yml&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key3:</span> <span class="string">\.yml</span></span><br></pre></td></tr></table></figure><p>等价于json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">&quot;key1&quot;</span>: <span class="string">&quot;\\.yml&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">&quot;key2&quot;</span>: <span class="string">&quot;\\.yml&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">&quot;key3&quot;</span>: <span class="string">&quot;\\.yml&quot;</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="playbook写法"><a href="#playbook写法" class="headerlink" title="playbook写法"></a>playbook写法</h1><p>将下面这个ad-hoc模式的ansible任务改成等价的playbook模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ansible leader -m copy -a <span class="string">&#x27;src=/etc/passwd dest=/tmp&#x27;</span></span></span><br></pre></td></tr></table></figure><p>playbook:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">leader</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">copy:</span> <span class="string">src=/etc/passwd</span> <span class="string">dest=/tmp</span></span><br></pre></td></tr></table></figure><p>playbook中，每个play都需要放在数组中，所以在playbook的顶层使用列表的方式<code>- xxx</code>:来表示这是一个play（此处是<code>- hosts:</code>）。</p><p><strong>每个play都必须包含</strong><code>hosts</code><strong>和</strong><code>tasks</code><strong>指令</strong>。</p><ul><li><code>hosts</code>指令用来指定要执行该play的目标主机，可以是主机名，也可以是主机组，还支持正则表达式或者是变量的形式来更灵活的指定目标主机。</li><li><code>tasks</code>指令用来指定这个play中包含的任务，可以是一个或多个任务，任务也需要放在play的数组中，所以tasks指令内使用<code>- xxx</code>:的方式来表示每一个任务（此处是<code>- copy:</code>）。</li></ul><p><code>gather_facts</code>是一个play级别的指令设置，它是一个负责收集目标主机信息的任务，由setup模块提供。默认情况下，每个play都会先执行这个特殊的任务，收集完信息之后才开始执行其它任务。但是，收集目标主机信息的效率很低，如果能够确保playbook中不会使用到所收集的信息，可以显式指定<code>gather_facts: false</code>来禁止这个默认执行的收集任务，这对效率的提升是非常可观的。</p><p>此外每个play和每个task都可以使用<code>name</code>指令来命名，也建议尽量为每个play和每个task都命名，且名称具有唯一性。</p><p>所以上面的playbook可以改写为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">this</span> <span class="string">is</span> <span class="string">a</span> <span class="string">play</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">leader</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copy</span> <span class="string">/etc/passwd</span> <span class="string">to</span> <span class="string">/tmp</span></span><br><span class="line">      <span class="attr">copy:</span> <span class="string">src=/etc/passwd</span> <span class="string">dest=/tmp</span></span><br></pre></td></tr></table></figure><h1 id="playbook中的主机"><a href="#playbook中的主机" class="headerlink" title="playbook中的主机"></a>playbook中的主机</h1><p>play中的hosts指令通过pattern的方式来筛选节点，pattern的指定方式有以下几种规则：</p><ol><li><p>直接指定inventory中定义的主机名或者是主机组名，如<code>hosts: slions_pc1</code>、<code>hosts: leader</code></p></li><li><p>指定主机组名时，可使用索引的方式表示组中的第几个主机，如<code>hosts: leader[0]</code></p></li><li><p>可以使用冒号或者逗号来分开多个pattern，如<code>hosts: slions_pc3:leader</code></p></li><li><p>支持范围表示，如：<code>hosts: slions_pc[1:3]</code></p></li><li><p>支持通配符，如：<code>hosts: *</code></p></li><li><p>支持正则表达式，需使用<code>~</code>开头，如：<code>hosts: ~slions_pc(1|2)</code></p></li><li><p>pattern前面加一个&amp;符号表示取交集，如<code>leader:&amp;worker</code>会匹配同时存在于leader和worker中的主机</p></li><li><p>pattern前面加一个!符号表示取差集，如<code>leader:!worker</code>匹配存在与leader组但不在worker组中的主机</p></li></ol><h1 id="playbook模块参数的传递方式"><a href="#playbook模块参数的传递方式" class="headerlink" title="playbook模块参数的传递方式"></a>playbook模块参数的传递方式</h1><p>tasks中的模块参数有几种写法,都是等价的，保持整体统一就好。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">this</span> <span class="string">is</span> <span class="string">a</span> <span class="string">play</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">leader</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">copy:</span> <span class="string">src=/etc/passwd</span> <span class="string">dest=/tmp</span></span><br><span class="line">    </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">copy:</span></span><br><span class="line">      <span class="string">src=/etc/passwd</span></span><br><span class="line">      <span class="string">dest=/tmp</span></span><br><span class="line"> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">copy:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">      src=/etc/passwd</span></span><br><span class="line"><span class="string">      dest=/tmp</span></span><br><span class="line"><span class="string"></span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">copy:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      src=/etc/passwd</span></span><br><span class="line"><span class="string">      dest=/tmp</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string"></span>  <span class="bullet">-</span> <span class="attr">copy:</span> </span><br><span class="line">      <span class="attr">src:</span> <span class="string">/etc/passwd</span></span><br><span class="line">      <span class="attr">dest:</span> <span class="string">/tmp</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">copy:</span> </span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">/etc/passwd</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们之前的例子都是使用&lt;code&gt;ansible &amp;lt;host-pattern&amp;gt; [-m module_name] [-a args]&lt;/code&gt;这种语法来完成的。对于这种每次使用一个模块，只能执行一个任务的方式，称为&lt;code&gt;ad-hoc&lt;/code&gt;(点对</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（三）主机清单inventory</title>
    <link href="https://slions.github.io/2021/08/24/%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%BB%E6%9C%BA%E6%B8%85%E5%8D%95inventory/"/>
    <id>https://slions.github.io/2021/08/24/%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%BB%E6%9C%BA%E6%B8%85%E5%8D%95inventory/</id>
    <published>2021-08-24T13:43:29.000Z</published>
    <updated>2021-08-24T15:06:28.015Z</updated>
    
    <content type="html"><![CDATA[<p>上一章在讲ansible基本用法时的几个例子中host都是localhost,是因为在没有对ansible进行任何配置时，ansible只能通过localhost来控制本机。</p><p>inventory⽤于定义ansible要管理的主机列表，可以定义单个主机和主机组。/etc/ansible/hosts就是默认的全局inventory，当然我们可以在配置文件中修改此配置项，但通常不会去修改这个配置项，如果在其它地方定义了inventory文件，可以直接在ansible的命令行中使用<code>-i</code>选项去指定自定义的inventory文件。既然ansible的意义就是批量控制远程节点执行任务，该如何配置inventory呢。</p><h1 id="配置inventory"><a href="#配置inventory" class="headerlink" title="配置inventory"></a>配置inventory</h1><p>ansible inventory文件遵循ini配置格式。</p><p>先看下我本地的一些示例：</p><h2 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.100.10</span><br><span class="line">slions_pc1 <span class="attr">ansible_password</span>=<span class="number">123</span></span><br><span class="line">my_pc1 <span class="attr">ansible_host</span>=<span class="number">192.168</span>.<span class="number">100.10</span></span><br><span class="line">192.168.100.10:22</span><br><span class="line">192.168.100.1<span class="section">[0:2]</span></span><br></pre></td></tr></table></figure><ul><li>第一行通过IP地址定义主机节点。</li><li>第二行通过主机名定义，后面添加了一个主机变量<code>ansible_password=xxx</code>，指明连接该节点时的密码，需要注意的时，如果使用密码进行连接，要取消ansible配置文件中<code>host_key_checking = False</code>的注释。</li><li>第三行使用了主机变量<code>ansible_host=IP</code>，需要注意的是，如果定义了该主机变量，那么其前⾯的主机名就称为别名。可以命名为任何名称，这里是my_pc1。使用了<code>ansible_host</code>时连接主机会使用其定义的ip地址进行连接，而不会进行dns解析。</li><li>第四行定义主机时还指明了端口号</li><li>第五行表示192.168.100.10,192.168.100.11,192.168.100.12三台主机</li></ul><p>范围展开的方式还支持字母范围。下面都是有效的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">范围表示      展开结果</span><br><span class="line">--------------------</span><br><span class="line">a[1:3]  --&gt;  a1,a2,a3</span><br><span class="line">[08:12] --&gt;  08,09,10,11,12</span><br><span class="line">a[a:c]  --&gt;  aa,ab,ac</span><br></pre></td></tr></table></figure><p>上面示例中使用了两个主机变量ansible_password和ansible_host，它们直接定义在主机的后面，这些变量都是连接目标主机时的行为控制变量，通常它们都能见名知意。Ansible支持很多个连接时的行为控制变量，而且不同版本的Ansible的行为控制变量名称可能还不同，比如在以前版本中指定端口号的行为变量是<code>ansible_ssh_password</code>。</p><p>下面解释几个常见的行为变量。</p><table><thead><tr><th>inventory变量名</th><th>变量解释</th></tr></thead><tbody><tr><td>ansible_host</td><td>ansible连接节点时的IP地址</td></tr><tr><td>ansible_port</td><td>连接对方的端口号，ssh连接时默认为22</td></tr><tr><td>ansible_user</td><td>连接对方主机时使用的主机名。不指定时，将使用执行ansible或ansible-playbook命令的用户</td></tr><tr><td>ansible_password</td><td>连接时的用户密码</td></tr><tr><td>ansible_connection</td><td>连接类型，有效值包括smart、ssh、paramiko、local、docker、winrm，默认为smart。smart表示智能选择ssh和paramiko，当SSH支持ControlPersist(即持久连接)时使用ssh，否则使用paramiko。local和docker是非基于ssh连接的方式，winrm是连接windows的插件</td></tr><tr><td>ansible_ssh_private_key_file</td><td>指定密钥认证ssh连接时的私钥文件</td></tr><tr><td>ansible_ssh_common_args</td><td>提供给ssh、sftp、scp命令的额外参数</td></tr><tr><td>ansible_become</td><td>允许进行权限提升</td></tr><tr><td>ansible_become_method</td><td>指定提升权限的方式，例如可使用sudo/su/runas等方式</td></tr><tr><td>ansible_become_user</td><td>提升为哪个用户的权限，默认提升为root</td></tr><tr><td>ansible_become_password</td><td>提升为指定用户权限时的密码</td></tr><tr><td></td><td></td></tr></tbody></table><p>想要了解更多的参数可以查阅官方文档<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#connecting-to-hosts-behavioral-inventory-parameters">连接行为控制变量</a></p><h2 id="主机组"><a href="#主机组" class="headerlink" title="主机组"></a>主机组</h2><p>ansible支持通过定义主机组来管理远程节点，每个组内可以定义多个主机，每个主机都可以定义在任何一个或多个主机组内。</p><p>示例如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mygroup1]</span></span><br><span class="line">192.168.100.10</span><br><span class="line">192.168.100.11</span><br><span class="line">192.168.100.12</span><br><span class="line"></span><br><span class="line"><span class="section">[mygroup2]</span></span><br><span class="line">192.168.100.1<span class="section">[0:2]</span></span><br></pre></td></tr></table></figure><p>Ansible默认预定义了两个主机组：</p><ul><li>all分组，包含所有分组内的节点</li><li>ungrouped分组，包含所有不在分组内的节点</li></ul><p>这两个分组都不包含localhost这个特殊的节点。</p><p>定义了inventory之后，可以使用<code>ansible --list</code>或<code>ansible--playbook --list</code>命令来查看主机组的信息，还可以使用更为专业的<code>ansible-inventory</code>命令来查看主机组信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ansible mygroup1  --list</span><br><span class="line">  hosts (3):</span><br><span class="line">    192.168.100.10</span><br><span class="line">    192.168.100.11</span><br><span class="line">    192.168.100.12</span><br><span class="line">[root@slions_pc1 ~]# ansible-inventory mygroup2  --graph</span><br><span class="line">@mygroup2:</span><br><span class="line">  |--192.168.100.10</span><br><span class="line">  |--192.168.100.11</span><br><span class="line">  |--192.168.100.12</span><br><span class="line">[root@slions_pc1 ~]# ansible-inventory   --graph</span><br><span class="line">@all:</span><br><span class="line">  |--@mygroup1:</span><br><span class="line">  |  |--192.168.100.10</span><br><span class="line">  |  |--192.168.100.11</span><br><span class="line">  |  |--192.168.100.12</span><br><span class="line">  |--@mygroup2:</span><br><span class="line">  |  |--192.168.100.10</span><br><span class="line">  |  |--192.168.100.11</span><br><span class="line">  |  |--192.168.100.12</span><br><span class="line">  |--@ungrouped:</span><br><span class="line">  |  |--my_pc1</span><br><span class="line">  |  |--slions_pc1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用ansible-inventory以json格式列出所有主机的信息</span></span><br><span class="line">[root@slions_pc1 ~]# ansible-inventory   --list</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_meta&quot;: &#123;</span><br><span class="line">        &quot;hostvars&quot;: &#123;</span><br><span class="line">            &quot;192.168.100.10&quot;: &#123;</span><br><span class="line">                &quot;ansible_port&quot;: 22</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;192.168.100.11&quot;: &#123;</span><br><span class="line">                &quot;ansible_port&quot;: 22</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;192.168.100.12&quot;: &#123;</span><br><span class="line">                &quot;ansible_port&quot;: 22</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;my_pc1&quot;: &#123;</span><br><span class="line">                &quot;ansible_host&quot;: &quot;192.168.100.10&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;slions_pc1&quot;: &#123;</span><br><span class="line">                &quot;ansible_password&quot;: 123,</span><br><span class="line">                &quot;ansible_user&quot;: &quot;root&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;all&quot;: &#123;</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            &quot;mygroup1&quot;,</span><br><span class="line">            &quot;mygroup2&quot;,</span><br><span class="line">            &quot;ungrouped&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mygroup1&quot;: &#123;</span><br><span class="line">        &quot;hosts&quot;: [</span><br><span class="line">            &quot;192.168.100.10&quot;,</span><br><span class="line">            &quot;192.168.100.11&quot;,</span><br><span class="line">            &quot;192.168.100.12&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mygroup2&quot;: &#123;</span><br><span class="line">        &quot;hosts&quot;: [</span><br><span class="line">            &quot;192.168.100.10&quot;,</span><br><span class="line">            &quot;192.168.100.11&quot;,</span><br><span class="line">            &quot;192.168.100.12&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ungrouped&quot;: &#123;</span><br><span class="line">        &quot;hosts&quot;: [</span><br><span class="line">            &quot;my_pc1&quot;,</span><br><span class="line">            &quot;slions_pc1&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主机组中的主机也可以使用之前提到的连接行为控制变量。</p><h2 id="组嵌套"><a href="#组嵌套" class="headerlink" title="组嵌套"></a>组嵌套</h2><p>ansible还支持主机组嵌套，可以通过<code>[GROUP:children]</code>的方式定义一个主机组，并在其中包含子组。</p><p>示例如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mygroup1]</span></span><br><span class="line">192.168.100.10</span><br><span class="line">192.168.100.11</span><br><span class="line">192.168.100.12</span><br><span class="line"></span><br><span class="line"><span class="section">[mygroup2]</span></span><br><span class="line">192.168.100.1<span class="section">[0:2]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mygroup:children]</span></span><br><span class="line">mygroup1</span><br><span class="line">mygroup2</span><br></pre></td></tr></table></figure><p>当然还可以递归嵌套。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mygroup1]</span></span><br><span class="line">192.168.100.10</span><br><span class="line">192.168.100.11</span><br><span class="line">192.168.100.12</span><br><span class="line"></span><br><span class="line"><span class="section">[mygroup2]</span></span><br><span class="line">192.168.100.1<span class="section">[0:2]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mygroup3]</span></span><br><span class="line">192.168.100.13</span><br><span class="line"></span><br><span class="line"><span class="section">[mygroup:children]</span></span><br><span class="line">mygroup1</span><br><span class="line">mygroup2</span><br><span class="line"></span><br><span class="line"><span class="section">[recursive:children]</span></span><br><span class="line">mygroup</span><br><span class="line">mygroup3</span><br></pre></td></tr></table></figure><h2 id="主机普通变量"><a href="#主机普通变量" class="headerlink" title="主机普通变量"></a>主机普通变量</h2><p>在定义inventory时，除了可以指定连接的行为控制变量，也可以指定Ansible的普通变量，以便在ansible执行任务时使用。</p><p>示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slions_pc1 <span class="attr">ansible_password</span>=<span class="number">123</span> ansible_user=root myvar=<span class="string">&quot;hello slions_pc1&quot;</span></span><br></pre></td></tr></table></figure><p>执行命令使用<code>debug</code>模块来查看变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ansible slions_pc1 -m debug -a &#x27;var=myvar&#x27;</span><br><span class="line">slions_pc1 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;myvar&quot;: &quot;hello slions_pc1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主机组变量"><a href="#主机组变量" class="headerlink" title="主机组变量"></a>主机组变量</h2><p>顾名思义，肯定也有主机组变量。</p><p>示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mygroup1]</span></span><br><span class="line">192.168.100.10</span><br><span class="line">192.168.100.11</span><br><span class="line">192.168.100.12</span><br><span class="line"></span><br><span class="line"><span class="section">[mygroup1:vars]</span></span><br><span class="line"><span class="attr">mygroupvar</span>=<span class="string">&quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>上面<code>[mygroup1:vars]</code>表示为mygroup1组内所有主机定义变量mygroupvar=”hi”。而<code>[all:vars]</code>和<code>[ungrouped:vars]</code>分别表示为all和ungrouped这两个特殊的主机组内的所有主机定义变量。</p><h2 id="多个inventory文件"><a href="#多个inventory文件" class="headerlink" title="多个inventory文件"></a>多个inventory文件</h2><p>ansible支持定义多个inventory文件并放在一个目录下。</p><p>例如，创建一个名为/etc/ansible/inventorys的目录，在其中定义a和b两个inventory文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/ansible/inventorys/</span><br><span class="line">├── a</span><br><span class="line">└── b</span><br></pre></td></tr></table></figure><p>现在要使用多个inventory的功能，需要将inventory指定为目录路径。</p><p>可以通过修改Ansible配置文件，将inventory指令设置为对应的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory      = /etc/ansible/inventorys</span><br></pre></td></tr></table></figure><p>或者，执行ansible或ansible-playbook命令使用<code>-i /etc/ansible/inventorys</code>选项指定的路径。</p><p>执行下面的命令将列出所有主机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-inventory -i /etc/ansible/inventorys --graph all</span><br></pre></td></tr></table></figure><p>inventory指定为目录时，inventory文件最好不要带有后缀，就像示例中的a和b文件。因为Ansible当使用目录作为inventory时，默认将忽略一些后缀的文件不去解析。需要修改配置文件中的<code>inventory_ignore_extensions</code>项来禁止忽略指定后缀(如ini后缀)的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#inventory_ignore_extensions = ~, .orig, .bak, .ini, .cfg, .retry, .pyc, .pyo</span><br><span class="line">inventory_ignore_extensions = ~, .orig, .bak, .cfg, .retry, .pyc, .pyo</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一章在讲ansible基本用法时的几个例子中host都是localhost,是因为在没有对ansible进行任何配置时，ansible只能通过localhost来控制本机。&lt;/p&gt;
&lt;p&gt;inventory⽤于定义ansible要管理的主机列表，可以定义单个主机和主机组。</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>实现科学上网</title>
    <link href="https://slions.github.io/2021/08/23/%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://slions.github.io/2021/08/23/%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</id>
    <published>2021-08-23T08:23:54.000Z</published>
    <updated>2021-08-23T11:39:03.956Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/shadowsocks/">shadowsocks</a>是当前比较受欢迎的科学上网工具。</p><h1 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h1><h2 id="准备代理服务器"><a href="#准备代理服务器" class="headerlink" title="准备代理服务器"></a>准备代理服务器</h2><p>首先需要有一台可以连接外网的服务器，我本地环境是在腾讯云上的虚机（香港）。操作系统为Centos 7.6,1c 2g的资源。</p><h2 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h2><p>linux环境大多数情况都自带了pip工具，使用pip工具安装shadowsocks。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pip3 install shadowsocks</span></span><br><span class="line">WARNING: Running pip install with root privileges is generally not a good idea. Try `pip3 install --user` instead.</span><br><span class="line">Collecting shadowsocks</span><br><span class="line">  Downloading http://mirrors.tencentyun.com/pypi/packages/02/1e/e3a5135255d06813aca6631da31768d44f63692480af3a1621818008eb4a/shadowsocks-2.8.2.tar.gz</span><br><span class="line">Installing collected packages: shadowsocks</span><br><span class="line">  Running setup.py install for shadowsocks ... done</span><br><span class="line">Successfully installed shadowsocks-2.8.2</span><br></pre></td></tr></table></figure><h2 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h2><p>编写shadowsocks配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &gt;&gt;shadowsocks.json&lt;&lt;<span class="string">EOF</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;: 7295,</span><br><span class="line">    &quot;password&quot;: &quot;a7295&quot;,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>server</td><td>服务监听地址</td></tr><tr><td>server_port</td><td>服务监听端口</td></tr><tr><td>password</td><td>服务密码</td></tr><tr><td>method</td><td>加密方式，可选<code>aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table</code></td></tr></tbody></table><p><code>server_port</code>、<code>password</code>、<code>method</code>在配置 shadowsocks 客户端时需要保持一致。</p><h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><p>shadowsocks是通过ssserver命令启动的，首先看下当前环境此命令的执行路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">which</span> ssserver</span></span><br><span class="line">/usr/local/bin/ssserver</span><br></pre></td></tr></table></figure><p>编写systemd service文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &gt;&gt; /etc/systemd/system/shadowsocks.service &lt;&lt;<span class="string">EOF</span></span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/local/bin/ssserver -c /root/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>设置开机自启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> shadowsocks</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl start shadowsocks</span></span><br></pre></td></tr></table></figure><p>至此shadowsocks服务端就配置好了，需要注意的是：客户端会通过shadowsocks服务器的7295端口来连接外网，请提前开通相应的网络策略。</p><p><img src="https://slions.gitee.io/picbed/img/vpn.png"></p><h1 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h1><p>windows版本的shadowsocks请自行下载，以下只说如何配置。</p><p>打开下载的Shadowsocks，将如下信息按照之前服务端的配置填写好，其中服务器的地址是你虚机的外网地址，代理端口 1~65535 只要不被占用就可以。填写完点击确定。</p><p><img src="https://slions.gitee.io/picbed/img/shadowsocks.png"></p><p>右键托盘图标-启动系统代理服务，然后可以在托盘菜单中的系统代理模式中选择pac模式(只会代理根目录中PAC.txt文件中包含的网站)和全局模式(代理所有网站)。</p><p>之后就可以科学上网了。</p><p><img src="https://slions.gitee.io/picbed/img/youtube.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/shadowsocks/&quot;&gt;shadowsocks&lt;/a&gt;是当前比较受欢迎的科学上网工具。&lt;/p&gt;
&lt;h1 id=&quot;服务端配置&quot;&gt;&lt;a href=&quot;#服务端配置&quot; class=&quot;headerlink&quot; title=&quot;服</summary>
      
    
    
    
    <category term="科学上网" scheme="https://slions.github.io/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
    <category term="shadowsocks" scheme="https://slions.github.io/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>hexo特殊符号的转义问题</title>
    <link href="https://slions.github.io/2021/08/22/Hexo%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%BD%AC%E4%B9%89%E9%97%AE%E9%A2%98/"/>
    <id>https://slions.github.io/2021/08/22/Hexo%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%BD%AC%E4%B9%89%E9%97%AE%E9%A2%98/</id>
    <published>2021-08-22T14:52:29.000Z</published>
    <updated>2021-08-23T11:33:49.711Z</updated>
    
    <content type="html"><![CDATA[<p>最近写ansible相关文章时，发现hexo与Jinja2的语法有冲突。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line: 93,</span><br><span class="line">location: &#x27;_posts/（二）ansible初体验.md [Line 93, Column 133]&#x27;,</span><br><span class="line">type: &#x27;unexpected token: &#125;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>它的模板语法 &#123;&#123;&#125;&#125;和 &#123;&#37;&#37;&#125; 与hexo的模板使用的符号一样，如果你出现了跟它冲突的代码，不是在<strong>代码块</strong>中的，就会被 Hexo 进行编译，这时候需要使用转义字符来代替。</p><p>常见的转义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">! &amp;#33; — 惊叹号 Exclamation mark</span><br><span class="line">” &amp;#34; &amp;quot; 双引号 Quotation mark</span><br><span class="line"># &amp;#35; — 数字标志 Number sign</span><br><span class="line">$ &amp;#36; — 美元标志 Dollar sign</span><br><span class="line">% &amp;#37; — 百分号 Percent sign</span><br><span class="line">&amp; &amp;#38; &amp;amp; Ampersand</span><br><span class="line">‘ &amp;#39; — 单引号 Apostrophe</span><br><span class="line">( &amp;#40; — 小括号左边部分 Left parenthesis</span><br><span class="line">) &amp;#41; — 小括号右边部分 Right parenthesis</span><br><span class="line">* &amp;#42; — 星号 Asterisk</span><br><span class="line">+ &amp;#43; — 加号 Plus sign</span><br><span class="line">&lt; &amp;#60; &amp;lt; 小于号 Less than</span><br><span class="line">= &amp;#61; — 等于符号 Equals sign</span><br><span class="line">- &amp;#45; &amp;minus; — 减号</span><br><span class="line">&gt; &amp;#62; &amp;gt; 大于号 Greater than</span><br><span class="line">? &amp;#63; — 问号 Question mark</span><br><span class="line">@ &amp;#64; — Commercial at</span><br><span class="line">[ &amp;#91; - 中括号左边部分 Left square bracket</span><br><span class="line">\ &amp;#92; - 反斜杠 Reverse solidus (backslash)</span><br><span class="line">] &amp;#93; — 中括号右边部分 Right square bracket</span><br><span class="line">&#123; &amp;#123; — 大括号左边部分 Left curly brace</span><br><span class="line">| &amp;#124; — 竖线Vertical bar</span><br><span class="line">&#125; &amp;#125; — 大括号右边部分 Right curly brace</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近写ansible相关文章时，发现hexo与Jinja2的语法有冲突。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="hexo使用" scheme="https://slions.github.io/categories/hexo%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="hexo" scheme="https://slions.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>（二）ansible初体验</title>
    <link href="https://slions.github.io/2021/08/22/%EF%BC%88%E4%BA%8C%EF%BC%89ansible%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://slions.github.io/2021/08/22/%EF%BC%88%E4%BA%8C%EF%BC%89ansible%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2021-08-22T10:25:14.000Z</published>
    <updated>2021-08-22T14:51:09.140Z</updated>
    
    <content type="html"><![CDATA[<p>上篇简单介绍了ansible的概念与架构，也提到了如果想要简单的实现一些批量管控主机的功能，可以轻松上手。这边就主要介绍下如何实现最简单的功能。</p><p>从之前的架构图上看能知道，ansible分为了控制节点机与被控节点，首先需要在控制节点上安装ansible软件。</p><blockquote><p>Ansible的模块是用Python来执行的，且默认远程连接的方式是ssh，所以控制节点和被控制端都需要有Python环境，并且被控制端需要启动sshd服务，但通常这两个条件在安装Linux系统时就已经具备了。所以使用Ansible的安装过程只有一个：在控制节点安装Ansible。</p></blockquote><h1 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h1><table><thead><tr><th>主机名</th><th>IP地址</th><th>操作系统版本</th><th>内核版本</th><th>角色</th></tr></thead><tbody><tr><td>slions_pc1</td><td>192.168.100.10</td><td>CentOS  7.6.1810</td><td>3.10.0-957.el7.x86_64</td><td>控制节点</td></tr><tr><td>slions_pc2</td><td>192.168.100.11</td><td>CentOS  7.6.1810</td><td>3.10.0-957.el7.x86_64</td><td>被控节点</td></tr><tr><td>slions_pc3</td><td>192.168.100.12</td><td>CentOS  7.6.1810</td><td>3.10.0-957.el7.x86_64</td><td>被控节点</td></tr></tbody></table><p>所有的主机上都已启动sshd服务并保持默认配置（监听22端口）。</p><p>为了后续控制目标节点方便些，事先在控制节点将所有节点的DNS解析配置好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.100.10 slions_pc1</span><br><span class="line">192.168.100.11 slions_pc2</span><br><span class="line">192.168.100.12 slions_pc3</span><br></pre></td></tr></table></figure><h1 id="安装ansible"><a href="#安装ansible" class="headerlink" title="安装ansible"></a>安装ansible</h1><p>安装ansible的方式有好多种，不同系统的安装方式可参考：<a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html">官方文档</a></p><p>我这里就直接使用yum安装了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install epel-release.noarch -y</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install ansible -y</span></span><br></pre></td></tr></table></figure><p><strong>配置命令补全</strong></p><p>从Ansible 2.9版本开始，它支持命令的选项补全功能，它依赖于python的argcomplete插件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum  install python-argcomplete -y</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> activate-global-python-argcomplete</span></span><br></pre></td></tr></table></figure><p>最后，退出当前Shell重新进入，或者简单的直接执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exec</span> <span class="variable">$SHELL</span></span></span><br></pre></td></tr></table></figure><p>然后就可以按tab一次或两次补全参数或提示参数。</p><h1 id="配置主机互信"><a href="#配置主机互信" class="headerlink" title="配置主机互信"></a>配置主机互信</h1><p>Ansible默认是基于ssh连接的，所以要控制其它节点首先需要建立好ssh连接，而建立ssh连接要么需要提供密码，要么需要配置好认证方式。为了方便后文的测试，这里先配置好控制节点和其它被控节点之间的主机互信。</p><p>为了避免配置主机互信过程中的交互式询问，这里使用ssh-keyscan工具添加主机认证信息以及sshpass工具(安装Ansible时会自动安装sshpass，也可以yum -y install sshpass安装)直接指定ssh连接密码。</p><p>在控制节点生成密钥对。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -f ~/.ssh/id_rsa -N <span class="string">&#x27;&#x27;</span></span></span><br></pre></td></tr></table></figure><p>将各节点的主机信息写入控制节点的~/.ssh/known_hosts文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> host <span class="keyword">in</span> 192.168.100.&#123;11,12&#125; slions_pc&#123;2,3&#125;;<span class="keyword">do</span> ssh-keyscan -t rsa <span class="variable">$host</span> &gt;&gt; ~/.ssh/known_hosts 2&gt;/dev/null;<span class="keyword">done</span></span></span><br></pre></td></tr></table></figure><p>将控制节点上的ssh公钥分发给各节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  <span class="keyword">for</span> host <span class="keyword">in</span> 192.168.100.&#123;11,12&#125; slions_pc&#123;2,3&#125;;<span class="keyword">do</span> sshpass -p <span class="string">&#x27;123&#x27;</span> ssh-copy-id root@<span class="variable">$host</span> &amp;&gt;/dev/null;<span class="keyword">done</span></span></span><br></pre></td></tr></table></figure><p>以上就完成了ssh主机互信。</p><h1 id="ansible初体验"><a href="#ansible初体验" class="headerlink" title="ansible初体验"></a>ansible初体验</h1><h2 id="ansible语法"><a href="#ansible语法" class="headerlink" title="ansible语法"></a>ansible语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible &lt;host-pattern&gt; [-f forks] [-m module_name] [-a args]</span><br></pre></td></tr></table></figure><p>其中：<br>host-pattern     # 被控节点，可以是all，或者配置文件中的主机组名<br>-f forks               # 指定并行处理的进程数<br>-m module        # 指定使用的模块，默认模块为command<br>-a args                # 指定模块的参数</p><p>举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ansible localhost -m command -a &#x27;echo hello world!&#x27;</span><br><span class="line">localhost | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>上面的命令是使控制节点自身输出hello world！</p><h2 id="ansible模块"><a href="#ansible模块" class="headerlink" title="ansible模块"></a>ansible模块</h2><p>ansible有上千个模块，如何能快速找到想要的那个模块呢，当然百度是最快的了。ansible也提供了对应的命令来帮助我们快速寻找，可以使用<code>ansible-doc</code>。</p><p>其中<code>ansible-doc -l |grep &#39;xxx&#39;</code>命令可以筛选模块，例如筛选具有复制功能的模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ansible-doc -l|grep &#x27;copy&#x27;</span><br><span class="line">vsphere_copy                                                  Copy a file to a VMware datastore</span><br><span class="line">win_copy                                                      Copies files to remote locations on windows hosts</span><br><span class="line">bigip_file_copy                                               Manage files in datastores on a BIG-IP</span><br><span class="line">ec2_ami_copy                                                  copies AMI between AWS regions, return new image id</span><br><span class="line">win_robocopy                                                  Synchronizes the contents of two directories using Robocopy</span><br><span class="line">copy                                                          Copy files to remote locations</span><br><span class="line">na_ontap_lun_copy                                             NetApp ONTAP copy LUNs</span><br><span class="line">icx_copy                                                      Transfer files from or to remote Ruckus ICX 7000 series switches</span><br><span class="line">unarchive                                                     Unpacks an archive after (optionally) copying it from the local machine</span><br><span class="line">ce_file_copy                                                  Copy a file to a remote cloudengine device over SCP on HUAWEI CloudEngine switches</span><br><span class="line">postgresql_copy                                               Copy data between a file/program and a PostgreSQL table</span><br><span class="line">ec2_snapshot_copy                                             copies an EC2 snapshot and returns the new Snapshot ID</span><br><span class="line">nxos_file_copy                                                Copy a file to a remote NXOS device</span><br><span class="line">netapp_e_volume_copy                                          NetApp E-Series create volume copy pairs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据描述，大概找出是否有想要的模块。</p><p>找到模块后，想要看看它的功能描述以及用法，可以继续使用ansible-doc命令。</p><p>详细的模块描述手册： <code>ansible-doc &lt;$module_name&gt;</code></p><p>只包含模块参数用法的模块描述手册: <code>ansible-doc -s &lt;$module_name&gt;</code></p><p>就如很多编程语言一样，最先开始的是学会输出<code>hello world</code>，最后通过一个<code>debug</code>模块来实现。</p><p>查看debug模块的用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ansible-doc -s debug</span><br><span class="line">- name: Print statements during execution</span><br><span class="line">  debug:</span><br><span class="line">      msg:                   # The customized message that is printed. If omitted, prints a generic message.</span><br><span class="line">      var:                   # A variable name to debug. Mutually exclusive with the `msg&#x27; option. Be aware that this option already runs in Jinja2 context and has an implicit `&#123;&#123; &#125;&#125;&#x27;</span><br><span class="line">                               wrapping, so you should not be using Jinja2 delimiters unless you are looking for double interpolation.</span><br><span class="line">      verbosity:             # A number that controls when the debug is run, if you set to 3 it will only run debug when -vvv or above</span><br></pre></td></tr></table></figure><p>常用的就2个参数，msg与var，这两个参数是互斥的，只能使用其中一个。msg可以输出字符串，也可以输出变量的值，var只能输出变量的值。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ansible localhost -m debug -a &#x27;msg=&quot;hello world&quot;&#x27;</span><br><span class="line">localhost | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ansible中也支持使用变量，这里仅演示最简单的设置变量和引用变量的方式。ansible命令的-e选项或–extra-vars选项可以设置变量。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ansible localhost -m debug -e &#x27;str=&quot;hello world&quot;&#x27;  -a &#x27;var=str&#x27;</span><br><span class="line">localhost | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;str&quot;: &quot;hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line">[root@slions_pc1 ~]# ansible localhost -m debug -e &#x27;str=&quot;hello world&quot;&#x27;  -a &#x27;msg=&#123;&#123;str&#125;&#125;&#x27;</span><br><span class="line">localhost | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ansible的字符串是可以不用引号去包围的，例如str=hello是允许的，但如果字符串中包含了特殊符号，则可能需要使用引号去包围，例如此处的示例出现了会产生歧义的空格。此外，要区分变量名和普通的字符串，需要在变量名上加一点标注：用 &#123;&#123; &#125;&#125;包围Ansible的变量，这其实是Jinja2模板的语法。其实不难理解，它的用法和Shell下引用变量使用$符号或${}是一样的，例如echo “hello ${var}”。</p><h1 id="ansible配置文件"><a href="#ansible配置文件" class="headerlink" title="ansible配置文件"></a>ansible配置文件</h1><p>我们通过yum安装后的ansible会提供默认的ansible配置文件，位置在<code>/etc/ansible/ansible.cfg</code>。</p><p>实际上，ansible支持4种方式指定配置文件，它们的解析顺序是：</p><ul><li><p><code>ANSIBLE_CFG</code>: 环境变量中指定的配置文件</p></li><li><p><code>ansible.cfg</code>: 当前目录下的ansible.cfg</p></li><li><p><code>~/ansible.cfg</code>: 家目录下的ansible.cfg</p></li><li><p><code>/etc/ansible/ansible.cfg</code>: 默认的全局配置文件</p></li></ul><p>Ansible配置文件采用ini风格进行配置，每一项配置都使用key=value的方式进行配置。</p><p>下面是截取了部分配置文件的配置信息，暂时没有必要都了解，用到哪里时百度即可。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[defaults]</span></span><br><span class="line"><span class="attr">inventory</span> = /etc/ansible/hosts    <span class="comment">#这个参数表示资源清单inventory文件配置，资源清单就是一些ansible需要链接管理的主机列表。</span></span><br><span class="line"><span class="attr">forks</span> = <span class="number">5</span>   <span class="comment">#设置默认情况下Ansible最多能有多少个进程同时工作，默认设置最多5个进程并行处理。具体需要设置多少个，可以根据控制主机的性能和被管理节点的数量来确定。</span></span><br><span class="line"><span class="attr">sudo_user</span> = root  <span class="comment">#这个设置默认执行命令的用户，在playbook中重新设置这个参数。</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">22</span> <span class="comment">#这个是指定链接被管节点的管理端口，默认22。除非设置了特殊的SSH端口，不然这个参数一般是不需要修改的。</span></span><br><span class="line"><span class="attr">host_key_checking</span> = <span class="literal">false</span>  <span class="comment">#设置是否检查SSH主机的秘钥。可以设置为True或者False。</span></span><br><span class="line"><span class="attr">timeout</span> = <span class="number">60</span>  <span class="comment">#设置SSH链接的超时间隔，单位是秒。</span></span><br><span class="line"><span class="attr">log_path</span> = /var/log/ansible.log  <span class="comment">#系统默认是不记录日志的，如果想把Ansible系统的输出记录到日志文件中，需要设置log_path来指定一个存储Ansible日志的文件</span></span><br><span class="line"><span class="attr">poll_interval</span> = <span class="number">15</span> <span class="comment">#异步执行任务的时候多久检查一次任务装填</span></span><br><span class="line"><span class="attr">transport</span> = smart  <span class="comment">#选择远程的工具   默认情况下就是smart(智能)模式  自动选择连接方式</span></span><br><span class="line">module_set_locale  <span class="comment">#设置本地的环境变量  </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上篇简单介绍了ansible的概念与架构，也提到了如果想要简单的实现一些批量管控主机的功能，可以轻松上手。这边就主要介绍下如何实现最简单的功能。&lt;/p&gt;
&lt;p&gt;从之前的架构图上看能知道，ansible分为了控制节点机与被控节点，首先需要在控制节点上安装ansible软件。&lt;</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（一）ansible入门</title>
    <link href="https://slions.github.io/2021/08/22/%EF%BC%88%E4%B8%80%EF%BC%89ansible%E5%85%A5%E9%97%A8/"/>
    <id>https://slions.github.io/2021/08/22/%EF%BC%88%E4%B8%80%EF%BC%89ansible%E5%85%A5%E9%97%A8/</id>
    <published>2021-08-22T07:03:45.000Z</published>
    <updated>2021-08-22T10:44:55.783Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。</p><p>—— 百度百科</p></blockquote><p>简而言之，ansible融合了众多老牌运维工具的优点，通过一台ansible控制节点，就能实现批量配置、部署与运维多主机操作，进而减少重复性的工作，提高运维效率。目前已然成为了大厂标配技能，运维人员的敲门砖。</p><p>ansible与ssh工具相比，虽说都可以完成远程控制其他主机执行任务，但ansible可以实现批量整合不同主机上执行的不同任务，同时让用户可以去协调这些任务的执行策略。</p><p>ansible基于模块工作，它只提供了一种运行框架，就如各种命令于shell的意义一样。</p><p>ansible的优点很多，轻量化、基于python便于二次开发什么的，但最吸引人的是兼容性、无代理与幂等性。</p><ul><li><p>兼容性：</p><p>ansible几乎不受到平台和系统的限制，只需要python环境即可，基本上各种的Linux操作系统已经内置了python。</p></li><li><p>无代理</p><p>Agentless，即无Agent的存在，它就像普通命令一样，并非C/S软件，只需在某个作为控制节点上安装一次Ansible即可，通常它基于ssh连接来控制远程主机，远程主机上不需要安装Ansible或其它额外的服务。</p></li><li><p>幂等性</p><p>ansible绝大多数模块都具备幂等性。所谓幂等性，指的是多次操作或多次执行不影响结果。比如算术运算时数值加0是幂等的，无论加多少次结果都不会改变，而数值加1是非幂等的，每次加1结果都会改变。</p></li></ul><p><strong>ansible架构：</strong></p><p><img src="https://slions.gitee.io/picbed/img/ansible.jpg"></p><p><strong>基本执行流程：</strong></p><ol><li><p>Ansible读取playbook剧本，剧本中会记录对哪些主机执行哪些任务</p></li><li><p>Ansible通过主机清单找到要执行的主机，然后调用具体的模块 </p></li><li><p>Ansible会通过连接插件连接对应的主机并推送对应的任务列表 </p></li><li><p>最后被管理的主机会将Ansible发送过来的任务解析为本地Shell命令执行</p></li></ol><p>快速上手ansible是非常简单的，只需要了解常用的几个模块，就可以实现简单的批量操作远程主机。想要学透是比较困难的，涉及到的知识板块既零散又旁多，光是模块已经上千个了。所以多数情况只需要用到那个功能就查找相关的实现方式即可。比起各种繁杂的模块与用法，更多的应该关注任务整体的流程与逻辑，并根据自己的实际需求来写出一个可复用程度高的playbook。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。&lt;/p&gt;
&lt;p&gt;—— 百度百科&lt;/p&gt;</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>走近分布式一致性协议（下篇）</title>
    <link href="https://slions.github.io/2021/08/14/%E8%B5%B0%E8%BF%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/"/>
    <id>https://slions.github.io/2021/08/14/%E8%B5%B0%E8%BF%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/</id>
    <published>2021-08-14T07:42:00.000Z</published>
    <updated>2021-08-15T13:10:39.350Z</updated>
    
    <content type="html"><![CDATA[<a href="/2021/08/14/%E8%B5%B0%E8%BF%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/" title="上篇">上篇</a>简述了几种一致性协议（二阶段提交、三阶段提交、paxos和zab）的实现原理与优缺点，这篇了解下raft与复制状态机。<h2 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h2><p>类似于zookeeper的zab协议（Paxos算法），Raft也是用于保证分布式环境下多节点数据的一致性，但更易于理解。</p><p>在Raft体系中，有一个强leader，由它全权负责接收客户端的请求命令，并将命令作为日志条目赋值给其他服务器，在确认安全的时候，将日志命令提交执行。当leader故障时，会选举产生一个新的leader。在强leader的帮助下，Raft将一致性问题分解为了三个子问题：</p><ol><li>leader选举：当已有的leader故障时必须选出一个新的leader。</li><li>日志复制：leader接受来自客户端的命令，记录为日志，并复制给集群中的其他服务器，并强制其他节点的日志与leader保持一致。</li><li>安全措施：通过一些措施确保系统的安全性，如确保所有状态机按照相同顺序执行相同命令的措施。</li></ol><h3 id="Raft基本流程"><a href="#Raft基本流程" class="headerlink" title="Raft基本流程"></a>Raft基本流程</h3><p>一个Raft集群拥有多个奇数台服务器，我们一般是三台，这样可以容忍一台服务器出现故障。服务器可能会处于如下三种角色：领导者（leader）、候选人（candidate）、跟随者（follower），正常运行的情况下，会有一个leader，其他全为follower，<strong>follower只会响应leader和candidate的请求，而客户端的请求则全部由leader处理</strong>，即使有客户端请求了一个follower也会将请求重定向到leader。candidate代表候选人，出现在选举leader阶段，选举成功后candidate将会成为新的leader。可能出现的状态转换关系如下图：</p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/raft7.png"></p><p>从图中可以看出，集群刚启动时，所有节点都是follower，之后在time out信号的驱使下，follower会转变成candidate去拉取选票，获得大多数选票后就会成为leader，这时候如果其他候选人发现了新的leader已经诞生，就会自动转变为follower；而如果另一个time out信号发出时，还没有选举出leader，将会重新开始一次新的选举。可见，time out信号是促使角色转换得关键因素，类似于操作系统中得中断信号。</p><p><strong>term</strong></p><p>在Raft协议中，将时间分成了一些任意长度的时间片，称为term，term使用连续递增的编号的进行识别。</p><p>每一个term都从新的选举开始，candidate们会努力争取称为leader。一旦获胜，它就会在剩余的term时间内保持leader状态。</p><p>term也起到了系统中逻辑时钟的作用，每一个server都存储了当前term编号，在server之间进行交流的时候就会带有该编号，如果一个server的编号小于另一个的，那么它会将自己的编号更新为较大的那一个；如果leader或者candidate发现自己的编号不是最新的了，就会自动转变为follower；如果接收到的请求的term编号小于自己的当前term将会拒绝执行。</p><p><strong>rpc</strong></p><p>server之间的交流是通过RPC进行的。只需要实现两种RPC就能构建一个基本的Raft集群：</p><ul><li>RequestVote RPC：它由选举过程中的candidate发起，用于拉取选票</li><li>AppendEntries RPC：它由leader发起，用于复制日志或者发送心跳信号。</li></ul><p>每个Raft节点将会根据自己节点的状态数据来对这两种RPC请求进行处理，我们先看一下每个Raft节点保存那些状态数据:</p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/raft01.png"></p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/raft02.png"></p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/raft03.png"></p><h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>Raft通过<strong>心跳机制</strong>发起leader选举。节点都是从follower状态开始的，如果收到了来自leader或candidate的RPC，那它就保持follower状态，避免争抢成为candidate。Leader会发送空的AppendEntries RPC作为心跳信号来确立自己的地位，（心跳间隔时间）如果follower一段时间(选举超时时间)没有收到心跳，它就会认为leader已经挂了，发起新的一轮选举。</p><p>选举发起后，一个follower会增加自己的当前term编号并转变为candidate。它会首先投自己一票，然后向其他所有节点并行发起RequestVote RPC，之后candidate状态将可能发生如下三种变化:</p><ul><li>赢得选举称为leader: 如果它在一个term内收到了大多数的选票，将会在接下的剩余term时间内称为leader，然后就可以通过发送心跳确立自己的地位。(每一个server在一个term内只能投一张选票，并且按照先到先得的原则投出)</li><li>其他server称为leader：在等待投票时，可能会收到其他server发出AppendEntries RPC心跳信号，说明其他leader已经产生了。这时通过比较自己的term编号和RPC过来的term编号，如果比对方大，说明leader的term过期了，就会拒绝该RPC，并继续保持候选人身份; 如果对方编号不比自己小,则承认对方的地位,转为follower。</li><li>选票被瓜分,选举失败：如果没有candidate获取大多数选票, 则没有leader产生, candidate们等待超时后发起另一轮选举。为了防止下一次选票还被瓜分,必须采取一些额外的措施, <strong>raft采用随机election timeout的机制防止选票被持续瓜分</strong>。通过将timeout随机设为一段区间上的某个值, 因此很大概率会有某个candidate率先超时然后赢得大部分选票.（随机重试机制）</li></ul><p><img src="https://gitee.com/Slions/picbed/raw/master/img/raft05.png"></p><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>一旦leader被选举成功，就可以对客户端提供服务了。客户端提交每一条命令都会被按<strong>顺序</strong>记录到leader的日志中，每一条命令都包含term编号和顺序索引，然后向其他节点并行发送<strong>AppendEntries RPC</strong>用以复制命令(如果命令丢失会<strong>不断重发</strong>)，当复制成功也就是大多数节点成功复制后，leader就会提交命令，即执行该命令并且将执行结果返回客户端，raft保证已经提交的命令最终也会被其他节点成功执行。leader会保存有当前已经提交的<strong>最高日志编号</strong>。顺序性确保了相同日志索引处的命令是相同的，而且之前的命令也是相同的。当发送AppendEntries RPC时，会<strong>包含leader上一条刚处理过的命令</strong>，接收节点如果发现上一条命令不匹配，就会拒绝执行。</p><h3 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h3><ul><li><p>日志复制原则</p><p>在Raft中，leader通过<strong>强制follower复制自己的日志</strong>来解决日志不一致的情形，那么冲突的日志将会被重写。为了让日志一致，先找到最新的一致的那条日志，然后把follower之后的日志全部删除，leader再把自己在那之后的日志一股脑推送给follower，这样就实现了一致。而寻找该条日志，可以通过AppendEntries RPC，该RPC中包含着<strong>下一次要执行的命令索引</strong>（nextIndex），如果能和follower的当前索引对上，那就执行，否则拒绝，然后leader将会逐次递减索引，直到找到相同的那条日志。</p></li><li><p>选举约束</p><p>比如某个follower在leader提交时宕机了，也就是少了几条命令，然后它又经过选举成了新的leader，这样它就会强制其他follower跟自己一样，使得其他节点上刚刚提交的命令被删除，导致客户端提交的一些命令被丢失了，raft的解决办法：Raft通过投票过程<strong>确保只有拥有全部已提交日志的candidate能成为leader</strong>。由于candidate为了拉选票需要通过RequestVote RPC联系其他节点，而之前提交的命令至少会存在于其中某一个节点上,因此只要candidate的日志至少和其他大部分节点的一样新就可以了, follower如果收到了不如自己新的candidate的RPC,就会将其丢弃。</p></li><li><p>如果命令已经被复制到了大部分节点上,但是还没来的及提交就崩溃了,这样后来的leader应该完成之前term未完成的提交. Raft通过让leader统计当前term内还未提交的命令已经被复制的数量是否<strong>半数以上</strong>, 然后进行提交。</p></li></ul><h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>随着日志大小的增长，会占用更多的内存空间，处理起来也会耗费更多的时间，对系统的可用性造成影响，因此必须想办法压缩日志大小。Snapshotting是最简单的压缩方法，系统的全部状态会写入一个snapshot保存起来，然后丢弃截止到snapshot时间点之前的所有日志。Raft中的snapshot内容如下图所示：</p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/raft06.png"></p><p>每一个server都有自己的snapshot，它只保存当前状态，如上图中的当前状态为x=0,y=9，而last included index和last included term代表snapshot之前最新的命令，用于AppendEntries的状态检查。</p><p>虽然每一个server都保存有自己的snapshot，但是当follower严重落后于leader时，leader需要把自己的snapshot发送给follower加快同步，此时用到了一个新的RPC：<strong>InstallSnapshot RPC</strong>。follower收到snapshot时，需要决定如何处理自己的日志，如果收到的snapshot包含有更新的信息，它将<strong>丢弃自己已有的日志，按snapshot更新自己的状态</strong>，RPC的定义如下：</p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/raft07.png"></p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/raft08.png"></p><h1 id="复制状态机模型"><a href="#复制状态机模型" class="headerlink" title="复制状态机模型"></a>复制状态机模型</h1><p>当同一份数据存在多个副本的时候，怎么管理他们就成了重点。</p><p>复制状态机（Repilcated State Machine，RSM）的基本思想是一个分布式的复制状态机系统由多个复制单元组成，每个复制单元均是一个状态机，它的状态保存在一组状态变量中，状态机的状态能够并且只能通过外部命令来改变。（比paxos提出的时间都早，可以算是一致性协议的方法论了）</p><p>“一组状态变量”通常是基于操作日志来实现的，每一个复制单元存储一个包含一系列指令的日志，并且严格按照顺序逐条执行日志上的指令。</p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/rsm01.png"></p><p>上图是一个复制状态机的实现，每个RSM都有一个replicated log，存储的是来自客户端的commands。每个RSM中replicate log中commads的顺序都是相同的，状态机按顺序处理replicate log中的command,并将处理的结果返回给客户端。由于状态机具有确定性，因此每个状态机的输出和状态都是相同的。</p><p>一致性模块（Consensus Module）用于保证每个server上Log的一致性！</p><blockquote><p>如果不做任何保障，直接将commad暴力写入，一旦服务器宕机或者出现什么其他故障，就会导致这个Log丢失，并且无法恢复。而出现故障的可能性是很高的，这就导致系统不可用。</p></blockquote><p>复制状态机它有一个很重要的性质——<strong>确定性</strong></p><blockquote><p>如果两个相同的、确定性的状态从同一状态开始，并且以相同的顺序获得相同的输入，那么这两个状态机将会生成相同的输出，并且结束在相同的状态</p></blockquote><p>GFS、HDFS、zookeeper和etcd等分布式系统都是基于复制状态机模型实现的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a href=&quot;/2021/08/14/%E8%B5%B0%E8%BF%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%E7%AF%87%E</summary>
      
    
    
    
    <category term="分布式一致性协议" scheme="https://slions.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Distributed protocol" scheme="https://slions.github.io/tags/Distributed-protocol/"/>
    
  </entry>
  
  <entry>
    <title>走近分布式一致性协议（上篇）</title>
    <link href="https://slions.github.io/2021/08/14/%E8%B5%B0%E8%BF%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/"/>
    <id>https://slions.github.io/2021/08/14/%E8%B5%B0%E8%BF%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/</id>
    <published>2021-08-14T04:21:50.000Z</published>
    <updated>2021-08-15T13:09:40.390Z</updated>
    
    <content type="html"><![CDATA[<p>从互联网的发展可以看出由单机高耦合高资源逐步变成了现在的集群低耦合易扩展的架构，原先的做法都存在一台机器上，保证资源充足，网络稳定的情况下是最好的方案，但随着规模的不断扩大，网络的脆弱性，还有纵向扩展的局限性导致了分布式的出现。当分布式的概念出现后最重要的一点就是如何保证数据的一致性。</p><p>我们身边有很多类似的场景，比如火车票的售票系统，比如银行的转账，网上购物等等。</p><h1 id="一致性的级别"><a href="#一致性的级别" class="headerlink" title="一致性的级别"></a>一致性的级别</h1><ul><li><p>强一致性</p><p>始终一致，体验性最好但对系统的性能影响比较大。</p></li><li><p>弱一致性</p><p>不会承诺在系统写入之后什么时候能正确的读到该值，但会在某个时间级别后能达到数据的一致性。细分还能分成会话一致性与用户一致性。</p></li><li><p>最终一致性</p><p>是弱一致性的一个特例，会保证在一个时间内，达到数据一致性。</p></li></ul><h1 id="事务和分布式事务"><a href="#事务和分布式事务" class="headerlink" title="事务和分布式事务"></a>事务和分布式事务</h1><p>我们对于事务这个词听着比较熟悉，他在狭义上讲的是数据库事务，书上的解释是一系列对系统中数据进入访问与更新的操作所组成的一个程序执行逻辑单元。</p><p>事务有四个特性ACID，<code>原子性</code>，<code>一致性</code>，<code>隔离性</code>，<code>持久性</code>。</p><p>在单机的时代我们可以很容易的实现一套满足ACID的事务处理系统，但分布式数据库中，数据散落在不同的机器上，怎么对这些数据进行分布式的事务就成为了挑战。</p><p>CAP理论和BASE理论的提出：</p><p>CAP指的是一个分布式系统不可能同时满足一致性，可用性和分区容错性，最多只能满足其中的两项。</p><blockquote><p>可用性：有限的时间内返回结果</p><p>分区一致性：在遇到任何网络分区的情况下还能满足一致性和可用性，除非网络通信全断了。</p></blockquote><p>BASE理论是基于CAP演变来的，基本可用，弱状态和最终一致性。</p><h1 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h1><h2 id="二阶段提交协议"><a href="#二阶段提交协议" class="headerlink" title="二阶段提交协议"></a>二阶段提交协议</h2><p>分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为<strong>协调者</strong>的组件来统一掌控所有节点(称作<strong>参与者</strong>)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。</p><p>因此，二阶段提交的算法思路可以概括为：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png"></p><h3 id="过程介绍"><a href="#过程介绍" class="headerlink" title="过程介绍"></a>过程介绍</h3><p>所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。</p><ol><li><p>准备阶段</p><p>1.由协调者发起并传递带有事务信息的请求给各个参与者，询问是否可以提交事务，并等待返回结果。</p><p>2.各参与者执行事务操作，将Undo和Redo放入事务日志中（但是不提交）</p><p>3.如果参与者执行成功就返回YES（可以提交事务），失败NO(不能提交事务)</p></li><li><p>提交阶段</p><p>此阶段分两种情况：所有参与者均返回YES，有任何一个参与者返回NO</p><p>1.所有参与者均反馈YES时，即提交事务。</p><p>2.任何一个参与者反馈NO时，即中断事务。</p></li></ol><blockquote><p>提交事务：（所有参与者均反馈YES）</p><p>(1) 协调者向所有参与者发出正式提交事务的请求（即Commit请求）。</p><p>(2) 参与者执行Commit请求，并释放整个事务期间占用的资源。</p><p>(3) 各参与者向协调者反馈Ack完成的消息。</p><p>(4) 协调者收到所有参与者反馈的Ack消息后，即完成事务提交。</p><p>中断事务：（任何一个参与者反馈NO）</p><p>(1) 协调者向所有参与者发出回滚请求（即Rollback请求）。</p><p>(2) 参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。</p><p>(3) 各参与者向协调者反馈Ack完成的消息。</p><p>(4) 协调者收到所有参与者反馈的Ack消息后，即完成事务中断。</p></blockquote><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：原理简单，实现方便</p><p>缺点：同步阻塞，单点问题，脑裂问题</p><blockquote><p>在阶段2中，如果只有部分参与者接收并执行了Commit请求，会导致节点数据不一致。</p></blockquote><h2 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h2><h3 id="过程介绍-1"><a href="#过程介绍-1" class="headerlink" title="过程介绍"></a>过程介绍</h3><p>三阶段提交是在二基础提交上的改进，即将事务的提交过程分为CanCommit、PreCommit、do Commit三个阶段来进行处理。</p><ol><li><p>CanCommit</p><p> 1.协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者答复。</p><p> 2.参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES并进入预备状态，否则反馈NO。</p></li><li><p>PreCommit</p><p> 此阶段分为两种情况：</p><p> 1.所有参与者均受到请求并返回YES。</p><p> 2.有任何一个参与者返回NO，或者有任何一个参与者超时，协调者无法收到反馈，则事务中断。</p></li></ol><blockquote><p>事务预提交：（所有参与者均反馈YES时）</p><p>(1) 协调者向所有参与者发出PreCommit请求，进入准备阶段。</p><p>(2) 参与者收到PreCommit请求后，执行事务操作，将Undo和Redo信息记入事务日志中（但不提交）</p><p>(3) 各参与者向协调者反馈Ack响应或No响应，并等待最终指令。</p><p>中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）</p><p>(1) 协调者向所有参与者发出abort请求。</p><p>(2) 无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</p></blockquote><ol start="3"><li><p>do Commit</p><p>此阶段也存在两种情况：</p><p>1.所有参与者均反馈Ack响应，即执行真正的事务提交。</p><p>2.任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。</p></li></ol><blockquote><p>提交事务：（所有参与者均反馈Ack响应时）</p><p>(1) 如果协调者处于工作状态，则向所有参与者发出do Commit请求。</p><p>(2) 参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</p><p>(3) 各参与者向协调者反馈Ack完成的消息。</p><p>(4) 协调者收到所有参与者反馈的Ack消息后，即完成事务提交。</p><p>中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）</p><p>(1) 如果协调者处于工作状态，向所有参与者发出abort请求。</p><p>(2) 参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。</p><p>(3) 各参与者向协调者反馈Ack完成的消息。</p><p>(4) 协调者收到所有参与者反馈的Ack消息后，即完成事务中断。</p></blockquote><p>注意：进入阶段三后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 do Commit请求或abort请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png"></p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：引入超时机制。同时在协调者和参与者中都引入超时机制。降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务。</p><p>缺陷：脑裂问题依然存在，即在参与者收到PreCommit请求后等待最终指令，如果此时协调者无法与参与者正常通信，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><h2 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h2><p>上面我们可以看到二阶段和三阶段都可能出现数据不一致的现象，直到提出了paxos后，就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。</p><p>简单的说下paxos的提出是作者假想了一个叫paxos的希腊城邦，城邦要采用民主提议和投票的方式选出一个最终的决议，但由于城邦的居民没人愿意把精力都放在这种事情上，所以他们只能不定时的参加提议，不定时的来了解提议和投票进展，不定时的表达自己的意见，paxos算法的目标就是让他们按照少数服从多数的方式来最终达成一致意见。</p><p>Paxos的最大特点就是难，不仅难以理解，更难以实现，所以现在大部分的一致性协议都是基于paxos的衍生实现，比如zab，raft。</p><p>在2PC或3PC中，主要有协调者和参与者两种角色，在Paxos中，有三种角色，提议者，接收者和学习者。但是Paxos的基本流程主要在提议者和接收者之间发生。</p><ul><li><p>提议者（proposer）：提出提案，提案包含一个提案ID和一个提议的值。</p></li><li><p>接收者(acceptor)：参与决策，就提议者提出的提案进行承诺接收，如半数以上的接收者同意提案，则提案被通过。</p></li><li><p>学习者(learner)：参与决策，当提议者和接收者达成最终一致后，学习其最终值。</p></li></ul><h3 id="过程介绍-2"><a href="#过程介绍-2" class="headerlink" title="过程介绍"></a>过程介绍</h3><p>第一阶段：因为存在多个“提议者”，如果都提意见，那么“接受者“到底应该接受谁？所以要先明确哪个提议者有权提出提议，未来”接受者“们就主要处理这个”提议者“的提议（提出提议时就尽量让意见统一，尽早形成多数派）。</p><p>第二阶段：由上阶段选出的提议者提出提议，”接受者“反馈意见。如果多数接受了一个提议，那么提议就通过了。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ol><li>怎么明确谁应该是”合适“的提议者？通过编号。每个”提议者“在第一阶段先报个号，谁号大就当提议者。</li><li>每个”提议者“不会执着于让自己的提议通过，而是每个”提议者“会执着于让提议尽快的达成一致意见。所以如果”提议者“在选举时发现”接受者“之前已经接受过别的”提议者“的提议了，那就算自己赢得了本次选举，也会默默的把自己的提议改成前面”提议者“的提议。（为了尽快的意见统一）</li><li>号的大小很重要，号小的无论啥时候”接受者“都会直接拒绝。</li><li>如果你是提议者，在选举时发现”接受者1“说”他见的提议者的提议是方案1“，而”接受者2“说”他见的提议者的提议是方案2“，那么还是要通过对比”号的大小“，”接受者“在接收提案时会记录下”相关提议者号的大小和提议内容（如果有的话）“，所以只需要判断哪个提议者号大就把自己的提议改成哪个提议者的。</li></ol><h2 id="zab协议"><a href="#zab协议" class="headerlink" title="zab协议"></a>zab协议</h2><p>Zab借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。它是特别为Zookeeper设计的支持崩溃恢复的原子广播协议。Zab协议的全称是 Zookeeper Atomic Broadcast （Zookeeper原子广播）。Zookeeper 是通过 Zab 协议来保证分布式事务的最终一致性。</p><p>基于该协议，zk实现了一种主备模型（即Leader和Follower模型）的系统架构来保证集群中各个副本之间数据的一致性。这里的主备系统架构模型，就是指只有一台客户端（Leader）负责处理外部的<strong>写事务请求</strong>，然后Leader客户端将<strong>数据同步</strong>到其他Follower节点。</p><p>Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会<strong>广播</strong>该事务，只要<strong>超过半数节点</strong>写入成功，该事务就会被<strong>提交</strong>。</p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/%E4%B8%80%E8%87%B4%E6%80%A73.png"></p><h3 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h3><ol><li>使用一个单一的主进程（Leader）来接收并处理客户端的事务请求（也就是写请求），并采用了Zab的原子广播协议，将服务器数据的状态变更以<strong>事务proposal</strong>（事务提议）的形式广播到所有的副本（Follower）进程上去。</li><li>保证一个全局的变更序列被<strong>顺序引用</strong>。<br>Zab要保证同一个Leader发起的事务要按顺序被apply，同时还要保证只有先前Leader的事务被apply之后，新选举出来的Leader才能再次发起事务。</li><li>当主进程出现异常的时候，整个zk集群依旧能正常工作。</li></ol><h3 id="如何实现数据一致性"><a href="#如何实现数据一致性" class="headerlink" title="如何实现数据一致性"></a>如何实现数据一致性</h3><p>可以通过Zab 协议的两种基本的模式：<strong>崩溃恢复</strong>和<strong>消息广播</strong>来研究。</p><p>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会 进入崩溃恢复模式，选举产生新的Leader。</p><p>当选举产生了新的 Leader，同时集群中有过半的机器与该 Leader 服务器完成了状态同步（即数据同步）之后，Zab协议就会退出崩溃恢复模式，进入消息广播模式。</p><h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><p>1）客户端发起一个写操作请求。</p><p>2）Leader 服务器将客户端的请求转化为事务 Proposal 提案，同时为每个 Proposal 分配一个全局的ID，即zxid。</p><p>3）Leader 服务器为每个 Follower 服务器分配一个单独的队列，然后将需要广播的 Proposal 依次放到队列中取，并且根据 FIFO 策略进行消息发送。</p><p>4）Follower 接收到 Proposal 后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向 Leader 反馈一个 Ack 响应消息。</p><p>5）Leader 接收到超过半数以上 Follower 的 Ack 响应消息后，即认为消息发送成功，可以发送 commit 消息。</p><p>6）Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交。Follower 接收到 commit 消息后，会将上一条事务提交。</p><h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>Zab 协议崩溃恢复必须满足以下两个要求：<br>1）Zab 协议需要确保那些已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交。</p><blockquote><p>选择拥有 proposal 最大值（即 zxid 最大） 的节点作为新的 Leader</p></blockquote><p>2）Zab 协议需要确保丢弃那些只在 Leader 上被提出而没有被提交的事务。</p><blockquote><p>Zab 通过zxid 来实现这一目的。一个 zxid 是64位，高 32 是纪元（epoch）编号，每经过一次 Leader选举产生一个新的Leader，其epoch 号 +1。低 32 位是消息计数器，每接收到一条消息这个值 +1，新Leader 选举后这个值重置为 0。</p></blockquote><p>崩溃恢复主要包括两部分：<strong>Leader选举</strong>和<strong>数据恢复</strong>。</p><p><strong>Leader选举</strong></p><p>在 Zab 协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的 Leader 服务器。因此 Zab 协议需要一个高效且可靠的 Leader 选举算法，从而确保能够快速选举出新的 Leader 。</p><p>所以Zab通过<code>Fast Leader Election</code>（快速选举）来完成leader选择</p><p>成为 Leader 的条件：</p><p>1）选 epoch 最大的</p><p>2）若 epoch 相等，选 zxid 最大的</p><p>3）若 epoch 和 zxid 相等，选择 server_id 最大的（zoo.cfg中的myid）</p><blockquote><p>节点在选举开始时，都默认投票给自己，当接收其他节点的选票时，会根据上面的 Leader条件 判断并且更改自己的选票，然后重新发送选票给其他节点。当有一个节点的得票超过半数，该节点会设置自己的状态为 Leading ，其他节点会设置自己的状态为 Following。</p></blockquote><p><strong>数据恢复</strong></p><p>1）完成 Leader 选举后（新的 Leader 具有最高的zxid），在正式开始工作之前（接收事务请求，然后提出新的 Proposal），Leader 服务器会首先确认事务日志中的所有的 Proposal 是否已经被集群中过半的服务器 Commit。</p><p>2）Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务的 Proposal ，并且能将所有已经提交的事务 Proposal 应用到内存数据中。等到 Follower 将所有尚未同步的事务 Proposal 都从 Leader 服务器上同步过啦并且应用到内存数据中以后，Leader 才会把该 Follower 加入到真正可用的 Follower 列表中。</p><h3 id="zab协议核心"><a href="#zab协议核心" class="headerlink" title="zab协议核心"></a>zab协议核心</h3><p>定义了事务请求的处理方式</p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/zab4.png"></p><h3 id="zab协议原理"><a href="#zab协议原理" class="headerlink" title="zab协议原理"></a>zab协议原理</h3><p>Zab协议要求每个 Leader 都要经历三个阶段：<strong>发现，同步，广播</strong>。</p><p><img src="https://gitee.com/Slions/picbed/raw/master/img/zab5.png"></p><p>运行分析：</p><p>在zab协议的设计中，每一个进程都有可能处于以下三种状态之一。</p><ul><li>LOOKING： Leader选举阶段</li><li>FOLLOWING： Follower服务器和leader保存同步状态</li><li>LEADING： Leader服务器作为主进程领导状态</li></ul><p>代码实现中，多了一种状态：Observing 状态<br>这是 Zookeeper 引入 Observer 之后加入的，Observer 不参与选举，是只读节点，跟 Zab 协议没有关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从互联网的发展可以看出由单机高耦合高资源逐步变成了现在的集群低耦合易扩展的架构，原先的做法都存在一台机器上，保证资源充足，网络稳定的情况下是最好的方案，但随着规模的不断扩大，网络的脆弱性，还有纵向扩展的局限性导致了分布式的出现。当分布式的概念出现后最重要的一点就是如何保证数</summary>
      
    
    
    
    <category term="分布式一致性协议" scheme="https://slions.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Distributed protocol" scheme="https://slions.github.io/tags/Distributed-protocol/"/>
    
  </entry>
  
</feed>
