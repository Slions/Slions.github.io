<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://slions.github.io/atom.xml" rel="self"/>
  
  <link href="https://slions.github.io/"/>
  <updated>2021-12-18T13:37:23.017Z</updated>
  <id>https://slions.github.io/</id>
  
  <author>
    <name>Jingyu Shi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日志系统之Filebeat</title>
    <link href="https://slions.github.io/2021/12/18/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B9%8BFilebeat/"/>
    <id>https://slions.github.io/2021/12/18/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B9%8BFilebeat/</id>
    <published>2021-12-18T08:36:46.000Z</published>
    <updated>2021-12-18T13:37:23.017Z</updated>
    
    <content type="html"><![CDATA[<p>日志系统架构上可分为收集、纳管、展示三个层级，业界常说的ELK架构是指elasticsearch（纳管）、Logstash（收集）、Kibana（展示）的日志系统解决方案，但是logstash对内存、CPU、io等资源消耗比较高，与同类产品Beats比，性能有较大的开销。</p><p>Beats是一个轻量级日志采集器，目前Beats家族有7个成员：</p><ul><li>Packetbeat：网络数据（收集网络流量数据）</li><li>Metricbeat：指标（收集系统、进程和文件系统级别的CPU和内存使用情况等数据）</li><li>Filebeat：日志文件（收集文件数据）</li><li>Winlogbeat：Windows事件日志（收集Windows事件日志数据）</li><li>Auditbeat：审计数据（收集审计日志）</li><li>Heartbeat：运行时间监控（收集系统运行时的数据）</li><li>Functionbeat： 面向云端数据的无服务器采集器</li></ul><p>了解更多可查看<a href="https://www.elastic.co/cn/beats/">官方文档</a></p><h1 id="Filebeat"><a href="#Filebeat" class="headerlink" title="Filebeat"></a>Filebeat</h1><p><code>Filebeat</code>是用于转发和集中日志数据的轻量级传送工具。<code>Filebeat</code>监视服务器上指定的日志文件或位置，收集日志事件，并将它们转发到<code>Elasticsearch</code>或<code> Logstash</code>进行索引。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>启动<code>Filebeat</code>时，它将启动一个或多个<code>input</code>（输入），这些<code>input</code>会在指定的日志数据目录中查找。对于<code>Filebeat</code>所找到的每个日志，<code>Filebeat</code>都会启动<code>harvester</code>（收集器）。每个<code>harvester</code>都读取单个日志以获取新内容，并将新日志数据发送到<code>libbeat</code>，<code>libbeat</code>将聚集事件，并将聚集的数据发送到为Filebeat配置的<code>output</code>（输出）。</p><p><img src="https://slions.gitee.io/picbed/img/filebear1.png"></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="组件构成"><a href="#组件构成" class="headerlink" title="组件构成"></a>组件构成</h3><p><code>Filebeat</code>由<code>inputs</code>（输入）和<code>harvesters</code>（收集器）这两个组件组成，这些组件一起工作来跟踪文件并将事件数据发送到指定的output（输出）。</p><p>harvester负责读取单个文件的内容。harvester逐行读取每个文件，并将内容发送到输出。为每个文件启动一个harvester。harvester负责打开和关闭文件，这意味着文件描述符在harvester运行时保持打开状态。如果在收集文件时删除或重命名文件，Filebeat将继续读取该文件。</p><p>一个input负责管理harvesters和寻找所有来源读取。如果input类型是log，则input将查找驱动器上与定义的路径匹配的所有文件，并为每个文件启动一个harvester。每个input在它自己的Go协程中运行，Filebeat当前支持多种输入类型。每个输入类型可以定义多次。日志输入检查每个文件，以查看是否需要启动一个harvester，是否已经在运行，或者是否可以忽略该文件(参见ignore_older)。只有在harvesters（收集器）关闭后文件的大小发生变化时，才会提取新行。</p><h3 id="如何保存文件的状态"><a href="#如何保存文件的状态" class="headerlink" title="如何保存文件的状态"></a>如何保存文件的状态</h3><p>Filebeat保留每个文件的状态，并经常将状态刷新到磁盘中的注册表文件中。该状态用于记住harvester读取的最后一个偏移量，并确保发送所有日志行。如果无法访问输出（如Elasticsearch或Logstash），Filebeat将跟踪最后发送的行，并在输出再次可用时继续读取文件。当Filebeat运行时，每个输入的状态信息也保存在内存中。当Filebeat重新启动时，将使用来自注册表文件的数据重新构建状态，Filebeat在最后一个已知位置继续每个harvester。</p><p>对于每个输入，Filebeat都会保留它找到的每个文件的状态。由于文件可以重命名或移动，文件名和路径不足以标识文件。对于每个文件，Filebeat存储唯一的标识符，以检测文件是否以前被捕获。</p><h3 id="如何保证至少一次数据消费"><a href="#如何保证至少一次数据消费" class="headerlink" title="如何保证至少一次数据消费"></a>如何保证至少一次数据消费</h3><p>因为它将每个事件的传递状态存储在注册表文件中。在已定义的输出被阻止且未确认所有事件的情况下，Filebeat将继续尝试发送事件，直到输出确认已接收到事件为止。如果Filebeat在发送事件的过程中关闭，它不会等待输出确认所有事件后再关闭。当Filebeat重新启动时，将再次将Filebeat关闭前未确认的所有事件发送到输出。这样可以确保每个事件至少发送一次，但最终可能会有重复的事件发送到输出。通过设置<code>shutdown_timeout</code>选项，可以将Filebeat配置为在关机前等待特定时间。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>filebeat提供多种部署模式：</p><ul><li>rpm包</li><li>docker</li><li>kubernetes</li></ul><p>本次实验采用rpm包的方式进行。</p><h2 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h2><table><thead><tr><th><strong>主机名</strong></th><th>ip地址</th><th><strong>系统环境</strong></th><th>系统版本</th><th>内核版本</th></tr></thead><tbody><tr><td>test1</td><td>192.168.100.10</td><td>cpu:x4  mem:8GB  filesystem:50GB</td><td>CentOS  7.9.2009</td><td>3.10.0-1160.el7.x86_64</td></tr></tbody></table><p>本地之前已经安装了nginx服务，后面拿该服务作为用例测试。</p><p>因本次使用6.8.x版本filebeat进行实验，涉及到的配置可能与高版本有差异。</p><h2 id="下载软件包"><a href="#下载软件包" class="headerlink" title="下载软件包"></a>下载软件包</h2><p>登录<a href="https://www.elastic.co/cn/downloads/past-releases#filebeat]">官网地址</a>下载对应版本软件包</p><p><img src="https://slions.gitee.io/picbed/img/filebeat2.png"></p><h2 id="本地解压并安装"><a href="#本地解压并安装" class="headerlink" title="本地解压并安装"></a>本地解压并安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@test1 ~]# ls</span><br><span class="line">anaconda-ks.cfg    filebeat-6.8.8-x86_64.rpm</span><br><span class="line">[root@test1 ~]# rpm -iv filebeat-6.8.8-x86_64.rpm</span><br><span class="line">警告：filebeat-6.8.8-x86_64.rpm: 头V4 RSA/SHA512 Signature, 密钥 ID d88e42b4: NOKEY</span><br><span class="line">软件包准备中...</span><br><span class="line">filebeat-6.8.8-1.x86_64</span><br></pre></td></tr></table></figure><h2 id="配置filebeat"><a href="#配置filebeat" class="headerlink" title="配置filebeat"></a>配置filebeat</h2><p>默认的配置文件在<code>/etc/filebeat/filebeat.yml</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@test1 ~]# rpm -qc filebeat</span><br><span class="line">/etc/filebeat/filebeat.yml</span><br><span class="line">/etc/filebeat/modules.d/apache2.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/auditd.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/elasticsearch.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/haproxy.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/icinga.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/iis.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/iptables.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/kafka.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/kibana.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/logstash.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/mongodb.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/mysql.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/nginx.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/osquery.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/postgresql.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/redis.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/suricata.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/system.yml.disabled</span><br><span class="line">/etc/filebeat/modules.d/traefik.yml.disabled</span><br></pre></td></tr></table></figure><p>配置示例文件：<code>/etc/filebeat/filebeat.reference.yml</code>（包含所有未过时的配置项）</p><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/configuring-howto-filebeat.html">官方的配置介绍</a></p><h3 id="输入与输出配置"><a href="#输入与输出配置" class="headerlink" title="输入与输出配置"></a>输入与输出配置</h3><p>filebeat 支持的input（输出）有以下几种：</p><ul><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/filebeat-input-log.html">Log</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/filebeat-input-stdin.html">Stdin</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/filebeat-input-redis.html">Redis</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/filebeat-input-udp.html">UDP</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/filebeat-input-docker.html">Docker</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/filebeat-input-tcp.html">TCP</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/filebeat-input-syslog.html">Syslog</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/filebeat-input-netflow.html">NetFlow</a></li></ul><p>filebeat 支持的output（输出）有以下几种：</p><ul><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/elasticsearch-output.html">Elasticsearch</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/logstash-output.html">Logstash</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/kafka-output.html">Kafka</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/redis-output.html">Redis</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/file-output.html">File</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/console-output.html">Console</a></li><li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.8/configure-cloud-id.html">Cloud</a></li></ul><p>其中常用的输入是log，输出是es，本次不搭建es了，输出类型选择file。</p><p>下面是对log组件的官方配置项介绍进行简要解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">paths：                      #指定要监控的日志，目前按照Go语言的glob函数处理。没有对配置目录做递归处理，比如配置的如果是：</span><br><span class="line">- /var/log/* /*.log，则只会去/var/log目录的所有子目录中寻找以&quot;.log&quot;结尾的文件，而不会寻找/var/log目录下以&quot;.log&quot;结尾的文件。</span><br><span class="line">recursive_glob.enabled:      #启用全局递归模式，默认是开启的，例如/foo/**包括/foo, /foo/*, /foo/*/*，如果启用，它将单个**扩展为一个8级深度*模式。</span><br><span class="line">encoding：                   #指定被监控的文件的编码类型，使用plain和utf-8都是可以处理中文日志的</span><br><span class="line">exclude_lines: [&#x27;^DBG&#x27;]      #不包含匹配正则的行,如果还指定了multiline，则每个多行消息在被exclude_lines过滤之前被合并成一行。</span><br><span class="line">include_lines: [&#x27;^ERR&#x27;, &#x27;^WARN&#x27;]  #包含匹配正则的行，如果还指定了multiline，则每个多行消息在被include_lines过滤之前被合并成一行。</span><br><span class="line">harvester_buffer_size: 16384      #每个harvester在获取文件时使用的缓冲区的字节大小</span><br><span class="line">max_bytes: 10485760          #单个日志消息可以拥有的最大字节数。max_bytes之后的所有字节都被丢弃而不发送。默认值为10MB (10485760)</span><br><span class="line">exclude_files: [&#x27;\.gz$&#x27;]     #用于匹配希望Filebeat忽略的文件的正则表达式列表</span><br><span class="line">ingore_older: 0              #默认为0，表示禁用，可以配置2h，2m等，注意ignore_older必须大于close_inactive的值.表示忽略超过设置值未更新的文件或者文件从来没有被harvester收集</span><br><span class="line">close_*                      #close_ *配置选项用于在特定标准或时间之后关闭harvester。 关闭harvester意味着关闭文件处理程序。如果在harvester关闭后文件被更新，则在scan_frequency过后，文件将被重新拾取。 但是，如果在harvester关闭时移动或删除文件，Filebeat将无法再次接收文件，并且harvester未读取的任何数据都将丢失。</span><br><span class="line">close_inactive               #启动选项时，如果在指定时间没有被读取，将关闭文件句柄，读取的最后一条日志定义为下一次读取的起始点，而不是基于文件的修改时间，如果关闭的文件发生变化，一个新的harverster将在scan_frequency运行后被启动，建议至少设置一个大于读取日志频率的值，配置多个prospector来实现针对不同更新速度的日志文件，使用内部时间戳机制，来反映记录日志的读取，每次读取到最后一行日志时开始倒计时使用，2h 5m 来表示。</span><br><span class="line">close_rename                 #当选项启动，如果文件被重命名和移动，filebeat关闭文件的处理读取</span><br><span class="line">close_removed                #该选项默认是启动的，Filebeat会在文件被移除时关闭harvester。通常，只有在close_inactive指定的时间段内，文件才应该被删除。然而，如果一个文件被提前删除，而没有启用close_removed, Filebeat会保持文件打开，以确保收割器已经完成。</span><br><span class="line">close_eof                    #适合只写一次日志的文件，然后filebeat关闭文件的处理读取</span><br><span class="line">close_timeout                #当选项启动时，filebeat会给每个harvester设置预定义时间，不管这个文件是否被读取，达到设定时间后，将被关闭，close_timeout不能等于ignore_older,会导致文件更新时，不会被读取，如果output一直没有输出日志事件，这个timeout是不会被启动的，至少要要有一个事件发送，然后haverter将被关闭，设置0，表示不启动</span><br><span class="line">clean_inactived              #从注册表文件中删除先前收获的文件的状态，设置必须大于ignore_older+scan_frequency，以确保在文件仍在收集时没有删除任何状态，配置选项有助于减小注册表文件的大小，特别是如果每天都生成大量的新文件，此配置选项也可用于防止在Linux上重用inode的Filebeat问题</span><br><span class="line">clean_removed                #启动选项后，如果文件在磁盘上找不到，Filebeat将从注册表中清除这些文件。</span><br><span class="line">scan_frequency               #prospector检查指定用于收集的路径中的新文件的频率,默认10s</span><br><span class="line">tail_files：                 #如果设置为true，Filebeat从文件尾开始监控文件新增内容，把新增的每一行文件作为一个事件依次发送，而不是从文件开始处重新发送所有内容。</span><br><span class="line">symlinks：                   #符号链接选项允许Filebeat除常规文件外,可以收集符号链接。收集符号链接时，即使报告了符号链接的路径，Filebeat也会打开并读取原始文件。</span><br><span class="line">backoff：                    #backoff选项指定Filebeat如何积极地抓取新文件进行更新。默认1s，backoff选项定义Filebeat在达到EOF之后再次检查文件之间等待的时间。</span><br><span class="line">max_backoff：                #在达到EOF之后再次检查文件之前Filebeat等待的最长时间</span><br><span class="line">backoff_factor：             #指定backoff尝试等待时间几次，默认是2</span><br><span class="line">harvester_limit：            #harvester_limit选项限制一个prospector并行启动的harvester数量，直接影响文件打开数</span><br><span class="line">multiline.pattern            #必须匹配的regexp模式</span><br><span class="line">multiline.negate             #定义上面的模式匹配条件的动作是否定的，默认是false，假如模式匹配条件&#x27;^b&#x27;，默认是false模式，表示讲按照模式匹配进行匹配 将不是以b开头的日志行进行合并，如果是true，表示将不以b开头的日志行进行合并</span><br><span class="line">multiline.match              #指定Filebeat如何将匹配行组合成事件,在之前或者之后，取决于上面所指定的negate</span><br><span class="line">multiline.max_lines          #可以组合成一个事件的最大行数，超过将丢弃，默认500</span><br><span class="line">multiline.timeout            #定义超时时间，如果开始一个新的事件在超时时间内没有发现匹配，也将发送日志，默认是5s</span><br><span class="line"></span><br><span class="line">所有输入都支持以下配置选项：</span><br><span class="line">enable: true          #表示是该类型配置生效</span><br><span class="line">max_procs                    #设置可以同时执行的最大CPU数。默认值为系统中可用的逻辑CPU的数量。</span><br><span class="line">name                         #为该filebeat指定名字，默认为主机的hostname</span><br><span class="line">tags                         #列表中添加标签，用于过滤，例如：tags: [&quot;json&quot;]</span><br><span class="line">fields                       #可选字段，选择额外的字段进行输出可以是标量值，元组，字典等嵌套类型</span><br><span class="line">默认在sub-dictionary位置</span><br><span class="line">filebeat.inputs:</span><br><span class="line">fields:</span><br><span class="line">  log_type: trace</span><br><span class="line">  namespace: default</span><br><span class="line">fields_under_root            #如果值为ture，那么fields存储在输出文档的顶级位置</span><br></pre></td></tr></table></figure><p>file组件的配置项如下进行简要解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output.file:</span><br><span class="line">  enabled: true                      #启用输出</span><br><span class="line">  path: &quot;tmp/filebeat&quot;               #生成文件的路径</span><br><span class="line">  filename: slions_nginx_fb          #生成文件的名称</span><br><span class="line">  rotate_every_kb: 1000              #每个文件的最大大小，达到这个大小时，将轮转文件。</span><br><span class="line">  number_of_files: 3                 #保留的文件个数</span><br><span class="line">  permissions: 0600                  #创建文件时使用的权限。默认值是0600</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>export          #导出<br>run               #执行（默认执行）<br>test               #测试配置<br>keystore     #秘钥存储<br>modules     #模块配置管理<br>setup          #设置初始环境</p><p><a href="https://www.elastic.co/guide/en/beats/filebeat/current/command-line-options.html">https://www.elastic.co/guide/en/beats/filebeat/current/command-line-options.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日志系统架构上可分为收集、纳管、展示三个层级，业界常说的ELK架构是指elasticsearch（纳管）、Logstash（收集）、Kibana（展示）的日志系统解决方案，但是logstash对内存、CPU、io等资源消耗比较高，与同类产品Beats比，性能有较大的开销。&lt;</summary>
      
    
    
    
    <category term="云原生" scheme="https://slions.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="logging" scheme="https://slions.github.io/tags/logging/"/>
    
  </entry>
  
  <entry>
    <title>k8s替换容器运行时为containerd</title>
    <link href="https://slions.github.io/2021/12/16/k8s%E6%9B%BF%E6%8D%A2%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%BAcontainerd/"/>
    <id>https://slions.github.io/2021/12/16/k8s%E6%9B%BF%E6%8D%A2%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%BAcontainerd/</id>
    <published>2021-12-16T11:37:22.000Z</published>
    <updated>2021-12-16T12:51:30.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h1><table><thead><tr><th><strong>主机名</strong></th><th>ip地址</th><th><strong>系统环境</strong></th><th>系统版本</th><th>集群角色</th></tr></thead><tbody><tr><td>slions_pc1</td><td>192.168.100.10</td><td>cpu:x4  mem:8GB  filesystem:40GB</td><td>CentOS  7.6.1810</td><td>k8s master &amp; node</td></tr></tbody></table><p>我本地之前已经安装过kubernetes v1.19.0，使用的运行时是docker，本次测试下如何将k8s的容器运行时换为containerd。</p><h1 id="变更前的工作"><a href="#变更前的工作" class="headerlink" title="变更前的工作"></a>变更前的工作</h1><p>因为这是我的本地测试环境，如果是真实环境需要考虑如何将业务影响最小化，以下是整体的一个思路。</p><h2 id="维护节点"><a href="#维护节点" class="headerlink" title="维护节点"></a>维护节点</h2><p>首先标记需要切换的节点为维护模式，强制驱逐节点上正在运行的 Pod，这样可以最大程度降低切换过程中影响应用的正常运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon  $&lt;NODE_NAME&gt; </span><br></pre></td></tr></table></figure><p>执行完上面的命令后，slions_pc1节点变成了一个 <code>SchedulingDisabled</code> 状态，表示不可调度，这样新创建的 Pod 就不会调度到当前节点上来了。</p><p>接下来维护 slions_pc1节点，使用 <code>kubectl drain</code> 命令来维护节点并驱逐节点上的 Pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain  $&lt;NODE_NAME&gt;  --ignore-daemonsets</span><br></pre></td></tr></table></figure><p>上面的命令会强制将 node1 节点上的 Pod 进行驱逐，加了一个 <code>--ignore-daemonsets</code> 的参数可以用来忽略 DaemonSet 控制器管理的 Pods，因为这些 Pods 不用驱逐到其他节点去，当节点驱逐完成后接下来我们就可以来对节点进行维护操作了，除了切换容器运行时可以这样操作，比如我们需要变更节点配置、升级内核等操作的时候都可以先将节点进行驱逐，然后再进行维护。</p><h2 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h2><p>为了减小后期产生问题时的干扰因素，将docker、containerd 和 kubelet手动停止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl stop containerd</span><br><span class="line">systemctl stop kubelet</span><br></pre></td></tr></table></figure><h1 id="安装containerd"><a href="#安装containerd" class="headerlink" title="安装containerd"></a>安装containerd</h1><p>以下是官方文档中指出的安装和配置的先决条件，之前已经在安装k8s环境时完成了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf</span><br><span class="line">overlay</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Setup required sysctl params, these persist across reboots.</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Apply sysctl params without reboot</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><p>之前环境安装过docker，docker 默认使用了 containerd 作为后端的容器运行时，所以不需要单独安装 containerd 了。</p><h1 id="配置containerd"><a href="#配置containerd" class="headerlink" title="配置containerd"></a>配置containerd</h1><p>因为 containerd 中默认已经实现了 CRI，但是是以 plugin 的形式配置的，以前 Docker 中自带的 containerd 默认是将 CRI 这个插件禁用掉了的（使用配置 <code>disabled_plugins = [&quot;cri&quot;]</code>），所以这里我们重新生成默认的配置文件来覆盖掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@slions-pc1 ~]# containerd config default &gt; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><p>配置文件内容为：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">root</span> = <span class="string">&quot;/var/lib/containerd&quot;</span></span><br><span class="line"><span class="attr">state</span> = <span class="string">&quot;/run/containerd&quot;</span></span><br><span class="line"><span class="attr">plugin_dir</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">disabled_plugins</span> = []</span><br><span class="line"><span class="attr">required_plugins</span> = []</span><br><span class="line"><span class="attr">oom_score</span> = -<span class="number">999</span></span><br><span class="line"></span><br><span class="line"><span class="section">[grpc]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;/run/containerd/containerd.sock&quot;</span></span><br><span class="line">  <span class="attr">tcp_address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">tcp_tls_cert</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">tcp_tls_key</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">uid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">gid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">max_recv_message_size</span> = <span class="number">16777216</span></span><br><span class="line">  <span class="attr">max_send_message_size</span> = <span class="number">16777216</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ttrpc]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">uid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">gid</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[debug]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">uid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">gid</span> = <span class="number">0</span></span><br><span class="line">  <span class="attr">level</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[metrics]</span></span><br><span class="line">  <span class="attr">address</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">grpc_histogram</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[cgroup]</span></span><br><span class="line">  <span class="attr">path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[timeouts]</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.shim.cleanup&quot;</span> = <span class="string">&quot;5s&quot;</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.shim.load&quot;</span> = <span class="string">&quot;5s&quot;</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.shim.shutdown&quot;</span> = <span class="string">&quot;3s&quot;</span></span><br><span class="line">  <span class="attr">&quot;io.containerd.timeout.task.state&quot;</span> = <span class="string">&quot;2s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[plugins]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.gc.v1.scheduler&quot;]</span></span><br><span class="line">    <span class="attr">pause_threshold</span> = <span class="number">0.02</span></span><br><span class="line">    <span class="attr">deletion_threshold</span> = <span class="number">0</span></span><br><span class="line">    <span class="attr">mutation_threshold</span> = <span class="number">100</span></span><br><span class="line">    <span class="attr">schedule_delay</span> = <span class="string">&quot;0s&quot;</span></span><br><span class="line">    <span class="attr">startup_delay</span> = <span class="string">&quot;100ms&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span></span><br><span class="line">    <span class="attr">disable_tcp_service</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">stream_server_address</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    <span class="attr">stream_server_port</span> = <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="attr">stream_idle_timeout</span> = <span class="string">&quot;4h0m0s&quot;</span></span><br><span class="line">    <span class="attr">enable_selinux</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">selinux_category_range</span> = <span class="number">1024</span></span><br><span class="line">    <span class="attr">sandbox_image</span> = <span class="string">&quot;registry.aliyuncs.com/google_containers/pause:3.2&quot;</span></span><br><span class="line">    <span class="attr">stats_collect_period</span> = <span class="number">10</span></span><br><span class="line">    <span class="attr">systemd_cgroup</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">enable_tls_streaming</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">max_container_log_line_size</span> = <span class="number">16384</span></span><br><span class="line">    <span class="attr">disable_cgroup</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable_apparmor</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">restrict_oom_score_adj</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">max_concurrent_downloads</span> = <span class="number">3</span></span><br><span class="line">    <span class="attr">disable_proc_mount</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">unset_seccomp_profile</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">tolerate_missing_hugetlb_controller</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">disable_hugetlb_controller</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">ignore_image_defined_volumes</span> = <span class="literal">false</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span></span><br><span class="line">      <span class="attr">snapshotter</span> = <span class="string">&quot;overlayfs&quot;</span></span><br><span class="line">      <span class="attr">default_runtime_name</span> = <span class="string">&quot;runc&quot;</span></span><br><span class="line">      <span class="attr">no_pivot</span> = <span class="literal">false</span></span><br><span class="line">      <span class="attr">disable_snapshot_annotations</span> = <span class="literal">true</span></span><br><span class="line">      <span class="attr">discard_unpacked_layers</span> = <span class="literal">false</span></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime]</span></span><br><span class="line">        <span class="attr">runtime_type</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">runtime_engine</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">runtime_root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">privileged_without_host_devices</span> = <span class="literal">false</span></span><br><span class="line">        <span class="attr">base_runtime_spec</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime]</span></span><br><span class="line">        <span class="attr">runtime_type</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">runtime_engine</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">runtime_root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">privileged_without_host_devices</span> = <span class="literal">false</span></span><br><span class="line">        <span class="attr">base_runtime_spec</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span></span><br><span class="line">        <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span></span><br><span class="line">          <span class="attr">runtime_type</span> = <span class="string">&quot;io.containerd.runc.v2&quot;</span></span><br><span class="line">          <span class="attr">runtime_engine</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="attr">runtime_root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="attr">privileged_without_host_devices</span> = <span class="literal">false</span></span><br><span class="line">          <span class="attr">base_runtime_spec</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span></span><br><span class="line">            <span class="attr">SystemdCgroup</span> = <span class="literal">true</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]</span></span><br><span class="line">      <span class="attr">bin_dir</span> = <span class="string">&quot;/opt/cni/bin&quot;</span></span><br><span class="line">      <span class="attr">conf_dir</span> = <span class="string">&quot;/etc/cni/net.d&quot;</span></span><br><span class="line">      <span class="attr">max_conf_num</span> = <span class="number">1</span></span><br><span class="line">      <span class="attr">conf_template</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span></span><br><span class="line">        <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]</span></span><br><span class="line">          <span class="attr">endpoint</span> = [<span class="string">&quot;https://registry-1.docker.io&quot;</span>]</span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.image_decryption]</span></span><br><span class="line">      <span class="attr">key_model</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.x509_key_pair_streaming]</span></span><br><span class="line">      <span class="attr">tls_cert_file</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">tls_key_file</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.internal.v1.opt&quot;]</span></span><br><span class="line">    <span class="attr">path</span> = <span class="string">&quot;/opt/containerd&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.internal.v1.restart&quot;]</span></span><br><span class="line">    <span class="attr">interval</span> = <span class="string">&quot;10s&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.metadata.v1.bolt&quot;]</span></span><br><span class="line">    <span class="attr">content_sharing_policy</span> = <span class="string">&quot;shared&quot;</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.monitor.v1.cgroups&quot;]</span></span><br><span class="line">    <span class="attr">no_prometheus</span> = <span class="literal">false</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.runtime.v1.linux&quot;]</span></span><br><span class="line">    <span class="attr">shim</span> = <span class="string">&quot;containerd-shim&quot;</span></span><br><span class="line">    <span class="attr">runtime</span> = <span class="string">&quot;runc&quot;</span></span><br><span class="line">    <span class="attr">runtime_root</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">no_shim</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">shim_debug</span> = <span class="literal">false</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.runtime.v2.task&quot;]</span></span><br><span class="line">    <span class="attr">platforms</span> = [<span class="string">&quot;linux/amd64&quot;</span>]</span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.service.v1.diff-service&quot;]</span></span><br><span class="line">    <span class="attr">default</span> = [<span class="string">&quot;walking&quot;</span>]</span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.devmapper&quot;]</span></span><br><span class="line">    <span class="attr">root_path</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">pool_name</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">base_image_size</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">async_remove</span> = <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的有几点：</p><ol><li>修改默认的 pause 镜像为我之前所用的地址。</li></ol><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[plugins]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span></span><br><span class="line">    <span class="attr">sandbox_image</span> = <span class="string">&quot;registry.aliyuncs.com/google_containers/pause:3.2&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如果使用<code>systemd</code> 作为<code>cgroup driver</code>的话，需要修改下面字段。</li></ol><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[plugins]</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span></span><br><span class="line">      <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span></span><br><span class="line">        <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span></span><br><span class="line">          <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span></span><br><span class="line">            <span class="attr">SystemdCgroup</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="修改-kubelet-配置"><a href="#修改-kubelet-配置" class="headerlink" title="修改 kubelet 配置"></a>修改 kubelet 配置</h1><p>将容器运行时配置为 <code>containerd</code>，打开 <code>/etc/sysconfig/kubelet</code> 文件，在该文件中可以添加一些额外的 kubelet 启动参数，配置如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=&#x27;--container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock&#x27;</span><br></pre></td></tr></table></figure><ul><li><code>--container-runtime</code> 参数是用来指定使用的容器运行时的，可选值为 <code>docker</code> 或者 <code>remote</code>，默认是 <code>docker</code>，由于这里使用的是 containerd 这种容器运行时，所以配置为 <code>remote</code> 值（也就是除 <code>docker</code> 之外的容器运行时都应该指定为 <code>remote</code>）</li><li><code>--container-runtime-endpoint</code> 是用来指定远程的运行时服务的 endpiont 地址的，这里指定连接 containerd 的套接字地址 <code>unix:///run/containerd/containerd.sock</code>。</li></ul><h1 id="恢复服务"><a href="#恢复服务" class="headerlink" title="恢复服务"></a>恢复服务</h1><p>配置完成后重启 containerd 和 kubelet 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart containerd</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><p>查看节点状态是否正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@slions-pc1 ~]# kubectl get node -o wide</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION          CONTAINER-RUNTIME</span><br><span class="line">slions-pc1   Ready    master   2d    v1.19.0   192.168.100.10   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-957.el7.x86_64   containerd://1.4.12</span><br></pre></td></tr></table></figure><p>slions_pc1节点的容器运行时已经切换到 <code>containerd://1.4.12</code> 了。</p><h1 id="恢复调度"><a href="#恢复调度" class="headerlink" title="恢复调度"></a>恢复调度</h1><p>最后把节点重新加回到集群中来允许调度 Pod。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl uncordon $&lt;NODE_NAME&gt; </span><br></pre></td></tr></table></figure><h1 id="crictl"><a href="#crictl" class="headerlink" title="crictl"></a>crictl</h1><p>可以使用 <code>ctr</code> 命令来管理 containerd，查看多了一个名为 <code>k8s.io</code> 的命名空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@slions-pc1 ~]# ctr ns ls</span><br><span class="line">NAME   LABELS</span><br><span class="line">k8s.io</span><br><span class="line">moby</span><br></pre></td></tr></table></figure><p> kubernetes集群对接的 containerd 所有资源都在 <code>k8s.io</code> 的命名空间下面，而 docker 的则默认在 <code>moby</code> 下面，当然现在 <code>moby</code> 下面没有任何的数据了，但是在 <code>k8s.io</code> 命名空间下面就有很多镜像和容器资源了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@slions-pc1 ~]# ctr -n k8s.io t ls</span><br><span class="line">TASK                                                                PID      STATUS</span><br><span class="line">17ae102739d906d0accba9c1e585084b85f8ce663373f15784d6ba68ace74b1d    35543    RUNNING</span><br><span class="line">71da443d2b4005a37e879ed1c6d563ed775ae0d2291d10ea41f82b9ec9fa593d    51711    RUNNING</span><br><span class="line">9545145b2d9854fc80ee15a3bfe1f0b57fd8a0bd4630b571947c350adfe897b0    53337    RUNNING</span><br><span class="line">3fb571cc7679101e630b9fabc7159346fcf2004110844bf74850710bd182cd36    53459    RUNNING</span><br><span class="line">71890ef89c6b61f3a5d118c050d37bd796b01700d3449735ad6ca14fa3c9b40f    35169    RUNNING</span><br><span class="line">6e688d8e857237919e7a81c186502d10b9dc8bb15bfbfbd8e400419039d2cacb    35447    RUNNING</span><br><span class="line">cad990849d28051b75df2fd855d12ffad81065a49091c19f20480ecbc72f7c56    35116    RUNNING</span><br><span class="line">b5869243675c19aade230142e7a15e564e9b031b5cd32a901475291b2f1f59c2    53685    RUNNING</span><br><span class="line">51e15fd5f4961283c32fc63bfa7a166ee3e6289aef19f14ffd3a95410640ea12    35351    RUNNING</span><br><span class="line">484541d3b39bbe199b7c16a5049b53a6f0950435b1123dca23064b7a72901917    35604    RUNNING</span><br><span class="line">2f5c0484bb866d79bfdd1d2f3a6100a4559404bdb903b71a4af879468fc5bc7a    35393    RUNNING</span><br><span class="line">31e6e8d32619247f01b21f76c73a5ab1a3b72da12142f6280dfca1824b3c051d    53743    RUNNING</span><br><span class="line">d6fe5b981c93ab1b9870adaa14599710d26a58d2eb8604d5b08c2a30eb3aa11e    53846    RUNNING</span><br><span class="line">ec086f05f1063ab3197e5d1342b5febeaa978535baae0f5533616b79b78023fa    53878    RUNNING</span><br><span class="line">ea80243d5a9e662b141dda43d229b8e68e95d1a6077d7837f0a88bb2d1e4dbbd    51743    RUNNING</span><br><span class="line">468ae24960d0cc200573b8609c03944e45d202ed37fe9148e678f178e8112f05    35015    RUNNING</span><br><span class="line">[root@slions-pc1 ~]# ctr -n moby t ls</span><br><span class="line">TASK    PID    STATUS</span><br><span class="line">[root@slions-pc1 ~]# ctr -n k8s.io i ls -q</span><br><span class="line">docker.io/rancher/mirrored-flannelcni-flannel-cni-plugin:v1.0.0</span><br><span class="line">docker.io/rancher/mirrored-flannelcni-flannel-cni-plugin@sha256:bfe8f30c74bc6f31eba0cc6659e396dbdd5ab171314ed542cc238ae046660ede</span><br><span class="line">quay.io/coreos/flannel:v0.15.1</span><br><span class="line">quay.io/coreos/flannel@sha256:9a296fbb67790659adc3701e287adde3c59803b7fcefe354f1fc482840cdb3d9</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns:1.7.0</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns@sha256:73ca82b4ce829766d4f1f10947c3a338888f876fbed0540dc849c89ff256e90c</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd:3.4.9-1</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd@sha256:735f090b15d5efc576da1602d8c678bf39a7605c0718ed915daec8f2297db2ff</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver:v1.19.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver@sha256:522d17d35a8994637d27d1232bebd35cfae8e3e21ab359431403f2b8023e332c</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager:v1.19.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager@sha256:6c11a3d4d06385f7547a5ea0c3f0d5e7b12baa558111d01406ac1f778cb3f00b</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy:v1.19.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy@sha256:c752ecbd04bc4517168a19323bb60fb45324eee1e480b2b97d3fd6ea0a54f42d</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler:v1.19.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler@sha256:529a1566960a5b3024f2c94128e1cbd882ca1804f222ec5de99b25567858ecb9</span><br><span class="line">registry.aliyuncs.com/google_containers/pause:3.2</span><br><span class="line">registry.aliyuncs.com/google_containers/pause@sha256:927d98197ec1141a368550822d18fa1c60bdae27b78b0c004f705f548c07814f</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ctr</code>工具比起docker cli工具太难用了，<code>crictl</code> 为 CRI 兼容的容器运行时提供 CLI，后续可以使用<code>crictl</code>工具来进行运维。</p><p>安装K8s时默认是装了cri-tools软件包的，所以可以直接上手。</p><p>需要修改下默认的配置文件，默认为 <code>/etc/crictl.yaml</code>，在文件中指定容器运行时和镜像的 endpoint 地址，内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runtime-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: true</span><br></pre></td></tr></table></figure><p>配置完成后就可以使用 <code>crictl</code> 命令了。</p><h2 id="获取-Pod-列表"><a href="#获取-Pod-列表" class="headerlink" title="获取 Pod 列表"></a>获取 Pod 列表</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@slions-pc1 home]# crictl pods</span><br><span class="line">POD ID              CREATED             STATE               NAME                                 NAMESPACE           ATTEMPT             RUNTIME</span><br><span class="line">d6fe5b981c93a       About an hour ago   Ready               coredns-6d56c8448f-mlj4r             kube-system         0                   (default)</span><br><span class="line">b5869243675c1       About an hour ago   Ready               coredns-6d56c8448f-vtx97             kube-system         0                   (default)</span><br><span class="line">9545145b2d985       About an hour ago   Ready               kube-flannel-ds-4qwnd                kube-system         0                   (default)</span><br><span class="line">71da443d2b400       About an hour ago   Ready               kube-controller-manager-slions-pc1   kube-system         0                   (default)</span><br><span class="line">17ae102739d90       3 hours ago         Ready               kube-proxy-dd4dg                     kube-system         0                   (default)</span><br><span class="line">71890ef89c6b6       3 hours ago         Ready               kube-apiserver-slions-pc1            kube-system         0                   (default)</span><br><span class="line">cad990849d280       3 hours ago         Ready               etcd-slions-pc1                      kube-system         0                   (default)</span><br><span class="line">468ae24960d0c       3 hours ago         Ready               kube-scheduler-slions-pc1            kube-system         0                   (default)</span><br><span class="line">[root@slions-pc1 home]# crictl pods --name kube-apiserver-slions-pc1</span><br><span class="line">POD ID              CREATED             STATE               NAME                        NAMESPACE           ATTEMPT             RUNTIME</span><br><span class="line">71890ef89c6b6       3 hours ago         Ready               kube-apiserver-slions-pc1   kube-system         0                   (default)</span><br><span class="line">[root@slions-pc1 home]# crictl pods --label app=flannel</span><br><span class="line">POD ID              CREATED             STATE               NAME                    NAMESPACE           ATTEMPT             RUNTIME</span><br><span class="line">9545145b2d985       About an hour ago   Ready               kube-flannel-ds-4qwnd   kube-system         0                   (default)</span><br></pre></td></tr></table></figure><h2 id="获取镜像列表"><a href="#获取镜像列表" class="headerlink" title="获取镜像列表"></a>获取镜像列表</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions-pc1 home]# crictl images</span><br><span class="line">IMAGE                                                             TAG                 IMAGE ID            SIZE</span><br><span class="line">docker.io/rancher/mirrored-flannelcni-flannel-cni-plugin          v1.0.0              cd5235cd7dc26       4.68MB</span><br><span class="line">quay.io/coreos/flannel                                            v0.15.1             e6ea68648f0cd       21.7MB</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns                   1.7.0               bfe3a36ebd252       14MB</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd                      3.4.9-1             d4ca8726196cb       86.7MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver            v1.19.0             1b74e93ece2f5       29.7MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager   v1.19.0             09d665d529d07       28MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy                v1.19.0             bc9c328f379ce       49.3MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler            v1.19.0             cbdc8369d8b15       13.8MB</span><br><span class="line">registry.aliyuncs.com/google_containers/pause                     3.2                 80d28bedfe5de       300kB</span><br></pre></td></tr></table></figure><h2 id="获取容器列表"><a href="#获取容器列表" class="headerlink" title="获取容器列表"></a>获取容器列表</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@slions-pc1 home]# crictl ps</span><br><span class="line">CONTAINER           IMAGE               CREATED             STATE               NAME                      ATTEMPT             POD ID</span><br><span class="line">ec086f05f1063       bfe3a36ebd252       About an hour ago   Running             coredns                   0                   d6fe5b981c93a</span><br><span class="line">31e6e8d326192       bfe3a36ebd252       About an hour ago   Running             coredns                   0                   b5869243675c1</span><br><span class="line">3fb571cc76791       e6ea68648f0cd       About an hour ago   Running             kube-flannel              0                   9545145b2d985</span><br><span class="line">ea80243d5a9e6       09d665d529d07       About an hour ago   Running             kube-controller-manager   0                   71da443d2b400</span><br><span class="line">484541d3b39bb       bc9c328f379ce       3 hours ago         Running             kube-proxy                0                   17ae102739d90</span><br><span class="line">6e688d8e85723       1b74e93ece2f5       3 hours ago         Running             kube-apiserver            0                   71890ef89c6b6</span><br><span class="line">2f5c0484bb866       d4ca8726196cb       3 hours ago         Running             etcd                      0                   cad990849d280</span><br><span class="line">51e15fd5f4961       cbdc8369d8b15       3 hours ago         Running             kube-scheduler            0                   468ae24960d0c</span><br><span class="line"></span><br><span class="line">[root@slions-pc1 home]# crictl ps -s Running</span><br><span class="line">CONTAINER           IMAGE               CREATED             STATE               NAME                      ATTEMPT             POD ID</span><br><span class="line">ec086f05f1063       bfe3a36ebd252       About an hour ago   Running             coredns                   0                   d6fe5b981c93a</span><br><span class="line">31e6e8d326192       bfe3a36ebd252       About an hour ago   Running             coredns                   0                   b5869243675c1</span><br><span class="line">3fb571cc76791       e6ea68648f0cd       About an hour ago   Running             kube-flannel              0                   9545145b2d985</span><br><span class="line">ea80243d5a9e6       09d665d529d07       About an hour ago   Running             kube-controller-manager   0                   71da443d2b400</span><br><span class="line">484541d3b39bb       bc9c328f379ce       3 hours ago         Running             kube-proxy                0                   17ae102739d90</span><br><span class="line">6e688d8e85723       1b74e93ece2f5       3 hours ago         Running             kube-apiserver            0                   71890ef89c6b6</span><br><span class="line">2f5c0484bb866       d4ca8726196cb       3 hours ago         Running             etcd                      0                   cad990849d280</span><br><span class="line">51e15fd5f4961       cbdc8369d8b15       3 hours ago         Running             kube-scheduler            0                   468ae24960d0c</span><br><span class="line"></span><br><span class="line">[root@slions-pc1 home]# crictl exec -it 3fb571cc76791 date</span><br><span class="line">Thu Dec 16 12:45:35 UTC 2021</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="CLI对比"><a href="#CLI对比" class="headerlink" title="CLI对比"></a>CLI对比</h1><table><thead><tr><th align="left">命令</th><th align="left">Docker</th><th align="left">Containerd</th><th></th></tr></thead><tbody><tr><td align="left">docker</td><td align="left">crictl（推荐）</td><td align="left">ctr</td><td></td></tr><tr><td align="left">查看容器列表</td><td align="left"><code>docker ps</code></td><td align="left"><code>crictl ps</code></td><td><code>ctr -n k8s.io c ls</code></td></tr><tr><td align="left">查看容器详情</td><td align="left"><code>docker inspect</code></td><td align="left"><code>crictl inspect</code></td><td><code>ctr -n k8s.io c info</code></td></tr><tr><td align="left">查看容器日志</td><td align="left"><code>docker logs</code></td><td align="left"><code>crictl logs</code></td><td>无</td></tr><tr><td align="left">容器内执行命令</td><td align="left"><code>docker exec</code></td><td align="left"><code>crictl exec</code></td><td>无</td></tr><tr><td align="left">挂载容器</td><td align="left"><code>docker attach</code></td><td align="left"><code>crictl attach</code></td><td>无</td></tr><tr><td align="left">显示容器资源使用情况</td><td align="left"><code>docker stats</code></td><td align="left"><code>crictl stats</code></td><td>无</td></tr><tr><td align="left">创建容器</td><td align="left"><code>docker create</code></td><td align="left"><code>crictl create</code></td><td><code>ctr -n k8s.io c create</code></td></tr><tr><td align="left">启动容器</td><td align="left"><code>docker start</code></td><td align="left"><code>crictl start</code></td><td><code>ctr -n k8s.io run</code></td></tr><tr><td align="left">停止容器</td><td align="left"><code>docker stop</code></td><td align="left"><code>crictl stop</code></td><td>无</td></tr><tr><td align="left">删除容器</td><td align="left"><code>docker rm</code></td><td align="left"><code>crictl rm</code></td><td><code>ctr -n k8s.io c del</code></td></tr><tr><td align="left">查看镜像列表</td><td align="left"><code>docker images</code></td><td align="left"><code>crictl images</code></td><td><code>ctr -n k8s.io i ls</code></td></tr><tr><td align="left">查看镜像详情</td><td align="left"><code>docker inspect</code></td><td align="left"><code>crictl inspecti</code></td><td>无</td></tr><tr><td align="left">拉取镜像</td><td align="left"><code>docker pull</code></td><td align="left"><code>crictl pull</code></td><td><code>ctr -n k8s.io i pull</code></td></tr><tr><td align="left">推送镜像</td><td align="left"><code>docker push</code></td><td align="left">无</td><td><code>ctr -n k8s.io i push</code></td></tr><tr><td align="left">删除镜像</td><td align="left"><code>docker rmi</code></td><td align="left"><code>crictl rmi</code></td><td><code>ctr -n k8s.io i rm</code></td></tr><tr><td align="left">查看Pod列表</td><td align="left">无</td><td align="left"><code>crictl pods</code></td><td>无</td></tr><tr><td align="left">查看Pod详情</td><td align="left">无</td><td align="left"><code>crictl inspectp</code></td><td>无</td></tr><tr><td align="left">启动Pod</td><td align="left">无</td><td align="left"><code>crictl runp</code></td><td>无</td></tr><tr><td align="left">停止Pod</td><td align="left">无</td><td align="left"><code>crictl stopp</code></td><td>无</td></tr></tbody></table><p> <code>crictl pods</code> 列出的是 Pod 的信息，包括 Pod 所在的命名空间以及状态。<code>crictl ps</code> 列出的是应用容器的信息，而 <code>docker ps</code> 列出的是初始化容器（pause 容器）和应用容器的信息，初始化容器在每个 Pod 启动时都会创建，通常不会关注，所以 <code>crictl</code> 使用起来更简洁明了一些。</p><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><p>docker 和 containerd 除了在常用命令上有些区别外，在容器日志及相关参数配置方面也存在一些差异。</p><p>当使用 Docker 作为 Kubernetes 容器运行时的时候，容器日志的落盘是由 Docker 来完成的，日志被保存在类似 <code>/var/lib/docker/containers/&lt;CONTAINER&gt;</code> 的目录下面，kubelet 会在 <code>/var/log/pods</code> 和 <code>/var/log/containers</code> 下面创建软链接，指向容器日志目录下的容器日志文件。对应的日志相关配置可以通过配置文件进行指定，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# cat /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;50m&quot;,</span><br><span class="line">    &quot;max-file&quot;: &quot;3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而当使用 containerd 作为 Kubernetes 容器运行时的时候，容器日志的落盘则由 kubelet 来完成了，被直接保存在 <code>/var/log/pods/&lt;CONTAINER&gt;</code> 目录下面，同时在 <code>/var/log/containers</code> 目录下创建软链接指向日志文件。同样日志配置则是通过 kubelet 参数中进行指定的，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--container-log-max-files=10 --container-log-max-size=&quot;100Mi&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境描述&quot;&gt;&lt;a href=&quot;#环境描述&quot; class=&quot;headerlink&quot; title=&quot;环境描述&quot;&gt;&lt;/a&gt;环境描述&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;主机名&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;ip地址&lt;/th&gt;
</summary>
      
    
    
    
    <category term="云原生" scheme="https://slions.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="kubernetes" scheme="https://slions.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>CRI之containerd</title>
    <link href="https://slions.github.io/2021/12/15/CRI%E4%B9%8Bcontainerd/"/>
    <id>https://slions.github.io/2021/12/15/CRI%E4%B9%8Bcontainerd/</id>
    <published>2021-12-15T07:18:52.000Z</published>
    <updated>2021-12-15T13:43:28.617Z</updated>
    
    <content type="html"><![CDATA[<p>从<a href="/2021/12/07/K8S-Runtime-CRI-OCI-contained-dockershim-%E7%90%86%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/" title="这篇文章">这篇文章</a>可以了解云原生领域CRI与OCI的由来，为了制约docker在容器运行时的垄断地位，Google与IBM、Redhat等公司成立了CNCF，形成以kubernetes服务编排为基础，建设其周边云原生产品的生态，并陆续提出了CRI（容器运行时接口）、CSI（容器存储接口）、CNI（容器网络接口）的规范。</p><p>上篇文章开篇的图上可知，当前docker并没有实现CRI的规范，需要通过kubelet中集成了dokcershim（垫片）来进行“翻译”，并且对比后面直接使用containerd或者cri-o的方案来说，docker的这种实现太冗余了，性能会有较大的开销。但对于当前来说，docker依旧是主要的企业级容器运行时。</p><p>kubernetes在1.20版本之后废弃docker作为容器运行时，这也符合其产品理念，后续去除掉dockershim支持，还能实现kubernetes与docker的解耦，减少kubernetes社区的负担，也能够使得kubernetes的运行时支持上可以有更好的演进和发展。</p><p>类似的事情就如之前kubernetes支持的持久化存储，厂商会将存储插件代码到kubernetes核心代码中，后续改为统一的基于CSI的实现，而kubernetes就专注于CSI就行了，不用再跟很多厂商的代码耦合了。</p><h1 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h1><p><img src="https://slions.gitee.io/picbed/img/containerd1.png"></p><blockquote><p>Containerd是一个工业标准的容器运行时，重点是它简洁，健壮，便携，在Linux和window上可以作为一个守护进程运行，它可以管理主机系统上容器的完整的生命周期：镜像传输和存储，容器的执行和监控，低级别的存储和网络。</p><p>摘自<a href="https://hub.fastgit.org/containerd/containerd">《containerd官方文档》</a></p></blockquote><h2 id="Containerd-的架构"><a href="#Containerd-的架构" class="headerlink" title="Containerd 的架构"></a>Containerd 的架构</h2><p><img src="https://slions.gitee.io/picbed/img/containerd3.png"></p><p>可以看到 Containerd 仍然采用标准的 C/S 架构，服务端通过 <code>GRPC</code> 协议提供稳定的 API，客户端通过调用服务端的 API 进行高级的操作。</p><p>为了解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个<strong>子系统</strong>（subsystem）。连接不同子系统的组件被称为模块。</p><p>下图是官方文档中的架构图：</p><p><img src="https://slions.gitee.io/picbed/img/containerd2.png"></p><p>具体的实现细节还需要经过一段时间的研究才能了解。</p><h2 id="CRI性能对比图"><a href="#CRI性能对比图" class="headerlink" title="CRI性能对比图"></a>CRI性能对比图</h2><p>在安装使用前，看一张别人使用bucketbench对 <code>Docker</code>、<code>crio</code> 和 <code>Containerd</code> 的性能测试结果，包括启动、停止和删除容器，以比较它们所耗的时间：</p><p><img src="https://slions.gitee.io/picbed/img/containerd4.png"></p><p>可以看到，containerd在其中属于佼佼者。</p><h1 id="containerd安装"><a href="#containerd安装" class="headerlink" title="containerd安装"></a>containerd安装</h1><h2 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h2><table><thead><tr><th><strong>主机名</strong></th><th>ip地址</th><th><strong>系统环境</strong></th><th>系统版本</th><th>内核版本</th></tr></thead><tbody><tr><td>slions_pc2</td><td>192.168.100.11</td><td>cpu:x2  mem:4GB  filesystem:20GB</td><td>CentOS Linux release 7.6.1810</td><td>3.10.0-957.el7.x86_64</td></tr></tbody></table><h2 id="下载与解压资源包"><a href="#下载与解压资源包" class="headerlink" title="下载与解压资源包"></a>下载与解压资源包</h2><p>主要有两种方式安装，可以使用yum安装，也可以下载离线包进行安装，另外如果是之前安装过docker的话，containerd也会自动安装的。</p><p>首先从官网找到对应的<a href="https://hub.fastgit.org/containerd/containerd/releases/tag/v1.5.8">压缩包</a>,我这里是使用的1.5.8版本来进行后续实验。</p><p><img src="https://slions.gitee.io/picbed/img/containerd5.png"></p><p>Containerd 提供了两个压缩包，一个叫 <code>containerd-$&#123;VERSION&#125;.$&#123;OS&#125;-$&#123;ARCH&#125;.tar.gz</code>，另一个叫 <code>cri-containerd-$&#123;VERSION&#125;.$&#123;OS&#125;-$&#123;ARCH&#125;.tar.gz</code>。其中 <code>cri-containerd-$&#123;VERSION&#125;.$&#123;OS&#125;-$&#123;ARCH&#125;.tar.gz</code> 包含了所有 Kubernetes 需要的二进制文件。Containerd 是需要调用 <code>runc</code> 的，而第一个压缩包是不包含 <code>runc</code> 二进制文件的，如果选择第一个压缩包，还需要提前安装 runc。这里我本地环境是完全干净的，就直接使用 <code>cri-containerd</code> 压缩包。</p><p>下载到服务器解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ls</span><br><span class="line">anaconda-ks.cfg  cri-containerd-cni-1.5.8-linux-amd64.tar.gz</span><br><span class="line">[root@slions_pc2 ~]# tar -C / -zxf cri-containerd-cni-1.5.8-linux-amd64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">会生成如下文件</span></span><br><span class="line">etc/</span><br><span class="line">etc/systemd/</span><br><span class="line">etc/systemd/system/</span><br><span class="line">etc/systemd/system/containerd.service</span><br><span class="line">etc/crictl.yaml</span><br><span class="line">etc/cni/</span><br><span class="line">etc/cni/net.d/</span><br><span class="line">etc/cni/net.d/10-containerd-net.conflist</span><br><span class="line">usr/</span><br><span class="line">usr/local/</span><br><span class="line">usr/local/sbin/</span><br><span class="line">usr/local/sbin/runc</span><br><span class="line">usr/local/bin/</span><br><span class="line">usr/local/bin/containerd</span><br><span class="line">usr/local/bin/crictl</span><br><span class="line">usr/local/bin/ctd-decoder</span><br><span class="line">usr/local/bin/critest</span><br><span class="line">usr/local/bin/containerd-shim-runc-v1</span><br><span class="line">usr/local/bin/containerd-shim-runc-v2</span><br><span class="line">usr/local/bin/containerd-stress</span><br><span class="line">usr/local/bin/ctr</span><br><span class="line">usr/local/bin/containerd-shim</span><br><span class="line">opt/</span><br><span class="line">opt/containerd/</span><br><span class="line">opt/containerd/cluster/</span><br><span class="line">opt/containerd/cluster/version</span><br><span class="line">opt/containerd/cluster/gce/</span><br><span class="line">opt/containerd/cluster/gce/configure.sh</span><br><span class="line">opt/containerd/cluster/gce/cni.template</span><br><span class="line">opt/containerd/cluster/gce/cloud-init/</span><br><span class="line">opt/containerd/cluster/gce/cloud-init/node.yaml</span><br><span class="line">opt/containerd/cluster/gce/cloud-init/master.yaml</span><br><span class="line">opt/containerd/cluster/gce/env</span><br><span class="line">opt/cni/</span><br><span class="line">opt/cni/bin/</span><br><span class="line">opt/cni/bin/dhcp</span><br><span class="line">opt/cni/bin/firewall</span><br><span class="line">opt/cni/bin/host-local</span><br><span class="line">opt/cni/bin/ipvlan</span><br><span class="line">opt/cni/bin/sbr</span><br><span class="line">opt/cni/bin/vlan</span><br><span class="line">opt/cni/bin/vrf</span><br><span class="line">opt/cni/bin/tuning</span><br><span class="line">opt/cni/bin/bridge</span><br><span class="line">opt/cni/bin/macvlan</span><br><span class="line">opt/cni/bin/bandwidth</span><br><span class="line">opt/cni/bin/portmap</span><br><span class="line">opt/cni/bin/host-device</span><br><span class="line">opt/cni/bin/ptp</span><br><span class="line">opt/cni/bin/flannel</span><br><span class="line">opt/cni/bin/static</span><br><span class="line">opt/cni/bin/loopback</span><br></pre></td></tr></table></figure><h2 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h2><p>Containerd 的默认配置文件为 <code>/etc/containerd/config.toml</code>，需要通过命令来生成一个默认的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# mkdir /etc/containerd</span><br><span class="line">[root@slions_pc2 ~]# containerd config default &gt; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><p>配置参数含义参照<a href="https://github.com/containerd/containerd/blob/master/docs/man/containerd-config.toml.5.md">https://github.com/containerd/containerd/blob/master/docs/man/containerd-config.toml.5.md</a></p><h3 id="存储配置"><a href="#存储配置" class="headerlink" title="存储配置"></a>存储配置</h3><p>Containerd 有两个不同的存储路径，一个用来保存持久化数据，一个用来保存运行时状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root = &quot;/var/lib/containerd&quot;</span><br><span class="line">state = &quot;/run/containerd&quot;</span><br></pre></td></tr></table></figure><p><code>root</code>用来保存持久化数据，包括 <code>Snapshots</code>, <code>Content</code>, <code>Metadata</code> 以及各种插件的数据。每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。</p><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>私有仓库字段位置：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;192.168.100.10&quot;]</span></span><br><span class="line">    <span class="attr">endpoint</span> = [<span class="string">&quot;https://192.168.100.10&quot;</span>]            <span class="comment">#镜像仓库加速地址</span></span><br><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs.&quot;192.168.100.10&quot;.tls]</span></span><br><span class="line">    <span class="attr">insecure_skip_verify</span> = <span class="literal">true</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs.&quot;192.168.100.10&quot;.auth]</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;Harbor12345&quot;</span></span><br></pre></td></tr></table></figure><p>这里我就不修改了，默认是<code>docker.io</code></p><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>有一项配置需要留意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oom_score = 0</span><br></pre></td></tr></table></figure><p>Containerd 是容器的守护者，一旦发生内存不足的情况，理想的情况应该是先杀死容器，而不是杀死 Containerd。所以需要调整 Containerd 的 <code>OOM</code> 权重，减少其被 <strong>OOM Kill</strong> 的几率。最好是将 <code>oom_score</code> 的值调整为比其他守护进程略低的值。这里的 oom_socre 其实对应的是 <code>/proc/&lt;pid&gt;/oom_socre_adj</code>，在早期的 Linux 内核版本里使用 <code>oom_adj</code> 来调整权重, 后来改用 <code>oom_socre_adj</code> 了。</p><p>建议 Containerd 将该值设置为 <code>-999</code> 到 <code>0</code> 之间。如果作为 Kubernetes 的 Worker 节点，可以考虑设置为 <code>-999</code>。</p><h2 id="Systemd-配置"><a href="#Systemd-配置" class="headerlink" title="Systemd 配置"></a>Systemd 配置</h2><p>之前解压资源包时已经将containerd的systemd service配置文件放置在了<code>etc/systemd/system/containerd.service</code>，可以通过 systemd 配置 Containerd 作为守护进程运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# systemctl enable containerd &amp;&amp; systemctl start containerd</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/containerd.service to /etc/systemd/system/containerd.service.</span><br><span class="line">[root@slions_pc2 ~]# systemctl status containerd</span><br><span class="line">● containerd.service - containerd container runtime</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/containerd.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 三 2021-12-15 19:32:15 CST; 11s ago</span><br><span class="line">     Docs: https://containerd.io</span><br><span class="line">  Process: 10475 ExecStartPre=/sbin/modprobe overlay (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 10483 (containerd)</span><br><span class="line">    Tasks: 9</span><br><span class="line">   Memory: 19.2M</span><br><span class="line">   CGroup: /system.slice/containerd.service</span><br><span class="line">           └─10483 /usr/local/bin/containerd</span><br><span class="line"></span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.628370353+08:00&quot; level=info msg=&quot;loading plugin \&quot;io.containerd.grpc.v1.introspection\&quot;...&quot; type=io.containerd.grpc.v1</span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.629850993+08:00&quot; level=info msg=&quot;Start subscribing containerd event&quot;</span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.629895514+08:00&quot; level=info msg=&quot;Start recovering state&quot;</span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.630058843+08:00&quot; level=info msg=&quot;Start event monitor&quot;</span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.630072189+08:00&quot; level=info msg=&quot;Start snapshots syncer&quot;</span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.630079486+08:00&quot; level=info msg=&quot;Start cni network conf syncer&quot;</span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.630084202+08:00&quot; level=info msg=&quot;Start streaming server&quot;</span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.632856124+08:00&quot; level=info msg=serving... address=/run/containerd/containerd.sock.ttrpc</span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.633175755+08:00&quot; level=info msg=serving... address=/run/containerd/containerd.sock</span><br><span class="line">12月 15 19:32:15 slions_pc2 containerd[10483]: time=&quot;2021-12-15T19:32:15.633729234+08:00&quot; level=info msg=&quot;containerd successfully booted in 0.055757s&quot;</span><br></pre></td></tr></table></figure><h1 id="ctr-使用"><a href="#ctr-使用" class="headerlink" title="ctr 使用"></a>ctr 使用</h1><p>ctr命令是containerd的客户端工具，下面是一些常见的用法：</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>containerd有namespaces的概念，不同命名空间下的container是互相隔离的，如果不指定，<code>ctr</code> 默认是 <code>default</code> 空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ctr ns -h</span><br><span class="line">NAME:</span><br><span class="line">   ctr namespaces - manage namespaces</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr namespaces command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   create, c   create a new namespace</span><br><span class="line">   list, ls    list namespaces</span><br><span class="line">   remove, rm  remove one or more namespaces</span><br><span class="line">   label       set and clear labels for a namespace</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br><span class="line"></span><br><span class="line">[root@slions_pc2 ~]# ctr ns create mytest1</span><br><span class="line">[root@slions_pc2 ~]# ctr ns create mytest2</span><br><span class="line">[root@slions_pc2 ~]# ctr ns ls</span><br><span class="line">NAME    LABELS</span><br><span class="line">mytest1</span><br><span class="line">mytest2</span><br></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h3><p>测试时发现需要写全镜像的名称,无法想docker一样省略默认的仓库名与项目名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ctr -n mytest1 images pull docker.io/library/nginx:latest</span><br><span class="line">ctr: failed to resolve reference &quot;nginx&quot;: object required</span><br><span class="line">docker.io/library/nginx:latest:                                                   resolved       |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">index-sha256:9522864dd661dcadfd9958f9e0de192a1fdda2c162a35668ab6ac42b465f0603:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">manifest-sha256:4424e31f2c366108433ecca7890ad527b243361577180dfd9a5bb36e828abf47: done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:44be98c0fab60b6cef9887dbad59e69139cab789304964a197c27e2574d37304:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">config-sha256:f652ca386ed135a4cbe356333e08ef0816f81b2ac8d0619af01e2b256837ed3e:   done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:e5ae68f740265288a4888db98d2999a638fdcb6d725f427678814538d253aa4d:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:21e0df283cd68384e5e8dff7e6be1774c86ea3110c1b1e9326014d34c29c0657:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:ed835de16acd8f5821cf3f3ef77a66922510ee6349730d89a8dd4fd6da8437ef:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:881ff011f1c9c14982afc6e95ae70c25e38809843bb7d42abbb24eb540c93ce7:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:77700c52c9695053293be96f9cbcf42c91c5e097daa3829339333f1fe6f9d353:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">elapsed: 99.8s                                                                    total:  53.2 M (545.7 KiB/s)</span><br><span class="line">unpacking linux/amd64 sha256:9522864dd661dcadfd9958f9e0de192a1fdda2c162a35668ab6ac42b465f0603...</span><br><span class="line">done: 7.663355797s</span><br></pre></td></tr></table></figure><p>查看该镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ctr -n mytest1 image ls</span><br><span class="line">REF                            TYPE                                                      DIGEST                                                                  SIZE     PLATFORMS                                                                                               LABELS</span><br><span class="line">docker.io/library/nginx:latest application/vnd.docker.distribution.manifest.list.v2+json sha256:9522864dd661dcadfd9958f9e0de192a1fdda2c162a35668ab6ac42b465f0603 54.1 MiB linux/386,linux/amd64,linux/arm/v5,linux/arm/v7,linux/arm64/v8,linux/mips64le,linux/ppc64le,linux/s390x -</span><br></pre></td></tr></table></figure><p>此时mytest2中是没有这个镜像的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ctr -n mytest2 image ls</span><br><span class="line">REF TYPE DIGEST SIZE PLATFORMS LABELS</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ctr -n mytest1 container create docker.io/library/nginx:latest mynginx</span><br><span class="line">[root@slions_pc2 ~]# ctr -n mytest1 c ls</span><br><span class="line">CONTAINER    IMAGE                             RUNTIME</span><br><span class="line">mynginx      docker.io/library/nginx:latest    io.containerd.runc.v2</span><br><span class="line">[root@slions_pc2 ~]# ps -elf|grep nginx</span><br><span class="line">0 S root      10680   9878  0  80   0 - 28181 pipe_w 20:10 pts/0    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>上面 <code>create</code> 的命令创建了容器后，并没有处于运行状态，只是一个静态的容器。一个 container 对象只是包含了运行一个容器所需的资源及配置的数据结构，这意味着 namespaces、rootfs 和容器的配置都已经初始化成功了，只是用户进程(这里是 <code>nginx</code>)还没有启动。</p><p>然而一个容器真正的运行起来是由 task 对象实现的，<code>task</code> 代表任务的意思，可以为容器设置网卡，还可以配置工具来对容器进行监控等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ctr -n mytest1 task start -d mynginx</span><br><span class="line">[root@slions_pc2 ~]# ctr -n mytest1 task ls</span><br><span class="line">TASK       PID      STATUS</span><br><span class="line">mynginx    11330    RUNNING</span><br><span class="line">[root@slions_pc2 ~]# ps -elf|grep nginx</span><br><span class="line">0 S root      11305      1  0  80   0 - 177741 futex_ 21:03 ?       00:00:00 /usr/local/bin/containerd-shim-runc-v2 -namespace mytest1 -id mynginx -address /run/containerd/containerd.sock</span><br><span class="line">4 S root      11330  11305  0  80   0 -  2169 sigsus 21:03 ?        00:00:00 nginx: master process nginx -g daemon off;</span><br><span class="line">5 S 101       11367  11330  0  80   0 -  2270 ep_pol 21:03 ?        00:00:00 nginx: worker process</span><br><span class="line">5 S 101       11368  11330  0  80   0 -  2270 ep_pol 21:03 ?        00:00:00 nginx: worker process</span><br><span class="line">0 S root      11376   9878  0  80   0 - 28182 pipe_w 21:04 pts/0    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure><p>当然，也可以一步到位直接创建并运行容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ctr -n mytest2 images pull  docker.io/library/nginx:latest</span><br><span class="line">docker.io/library/nginx:latest:                                                   resolved       |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">index-sha256:9522864dd661dcadfd9958f9e0de192a1fdda2c162a35668ab6ac42b465f0603:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">manifest-sha256:4424e31f2c366108433ecca7890ad527b243361577180dfd9a5bb36e828abf47: done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:44be98c0fab60b6cef9887dbad59e69139cab789304964a197c27e2574d37304:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">config-sha256:f652ca386ed135a4cbe356333e08ef0816f81b2ac8d0619af01e2b256837ed3e:   done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:e5ae68f740265288a4888db98d2999a638fdcb6d725f427678814538d253aa4d:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:21e0df283cd68384e5e8dff7e6be1774c86ea3110c1b1e9326014d34c29c0657:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:ed835de16acd8f5821cf3f3ef77a66922510ee6349730d89a8dd4fd6da8437ef:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:881ff011f1c9c14982afc6e95ae70c25e38809843bb7d42abbb24eb540c93ce7:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">layer-sha256:77700c52c9695053293be96f9cbcf42c91c5e097daa3829339333f1fe6f9d353:    done           |++++++++++++++++++++++++++++++++++++++|</span><br><span class="line">elapsed: 5.8 s                                                                    total:   0.0 B (0.0 B/s)</span><br><span class="line">unpacking linux/amd64 sha256:9522864dd661dcadfd9958f9e0de192a1fdda2c162a35668ab6ac42b465f0603...</span><br><span class="line">done: 2.327616113s</span><br><span class="line">[root@slions_pc2 ~]# ctr -n mytest2 run -d docker.io/library/nginx:latest mynginx</span><br><span class="line">[root@slions_pc2 ~]# ctr -n mytest2 t ls</span><br><span class="line">TASK       PID      STATUS</span><br><span class="line">mynginx    11472    RUNNING</span><br><span class="line">[root@slions_pc2 ~]# ps -elf|grep nginx</span><br><span class="line">0 S root      11305      1  0  80   0 - 177901 futex_ 21:03 ?       00:00:00 /usr/local/bin/containerd-shim-runc-v2 -namespace mytest1 -id mynginx -address /run/containerd/containerd.sock</span><br><span class="line">4 S root      11330  11305  0  80   0 -  2169 sigsus 21:03 ?        00:00:00 nginx: master process nginx -g daemon off;</span><br><span class="line">5 S 101       11367  11330  0  80   0 -  2270 ep_pol 21:03 ?        00:00:00 nginx: worker process</span><br><span class="line">5 S 101       11368  11330  0  80   0 -  2270 ep_pol 21:03 ?        00:00:00 nginx: worker process</span><br><span class="line">0 S root      11450      1  0  80   0 - 178173 futex_ 21:09 ?       00:00:00 /usr/local/bin/containerd-shim-runc-v2 -namespace mytest2 -id mynginx -address /run/containerd/containerd.sock</span><br><span class="line">4 S root      11472  11450  0  80   0 -  2169 sigsus 21:09 ?        00:00:00 nginx: master process nginx -g daemon off;</span><br><span class="line">5 S 101       11514  11472  0  80   0 -  2270 ep_pol 21:09 ?        00:00:00 nginx: worker process</span><br><span class="line">5 S 101       11515  11472  0  80   0 -  2270 ep_pol 21:09 ?        00:00:00 nginx: worker process</span><br><span class="line">0 S root      11533   9878  0  80   0 - 28182 pipe_w 21:10 pts/0    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>和 docker 的操作类似，但必须要指定 –exec-id ，这个 id 可以随便写，只要唯一就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ctr -n mytest1 task exec --exec-id 0 -t mynginx bash</span><br></pre></td></tr></table></figure><h2 id="杀死容器"><a href="#杀死容器" class="headerlink" title="杀死容器"></a>杀死容器</h2><p>ctr 没有 stop 容器的功能，只能暂停或者杀死容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# ctr -n mytest1 task kill mynginx</span><br></pre></td></tr></table></figure><h1 id="nerdctl使用"><a href="#nerdctl使用" class="headerlink" title="nerdctl使用"></a>nerdctl使用</h1><p>可以看到原生的ctr工具对用户不是很友好，如果是用惯docker命令再用这个体会的更加明显，好在containerd也发现了这个问题，后面出来了<a href="https://hub.fastgit.org/containerd/nerdctl">nerdctl</a>工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# mkdir nerdctl &amp;&amp; tar xvf nerdctl-0.15.0-linux-amd64.tar.gz -C nerdctl</span><br><span class="line">nerdctl</span><br><span class="line">containerd-rootless-setuptool.sh</span><br><span class="line">containerd-rootless.sh</span><br><span class="line">[root@slions_pc2 ~]# cp -rp nerdctl/* /usr/local/bin/</span><br><span class="line">[root@slions_pc2 ~]# nerdctl ps --namespace  mytest1</span><br><span class="line">CONTAINER ID    IMAGE                             COMMAND                   CREATED              STATUS    PORTS    NAMES</span><br><span class="line">mynginx         docker.io/library/nginx:latest    &quot;/docker-entrypoint.…&quot;    About an hour ago    Up</span><br><span class="line">[root@slions_pc2 ~]# nerdctl images --namespace  mytest1</span><br><span class="line">REPOSITORY    TAG       IMAGE ID        CREATED        PLATFORM       SIZE</span><br><span class="line">nginx         latest    9522864dd661    2 hours ago    linux/amd64    146.2 MiB</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从&lt;a href=&quot;/2021/12/07/K8S-Runtime-CRI-OCI-contained-dockershim-%E7%90%86%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/&quot; title=&quot;这篇文章&quot;&gt;这篇文章</summary>
      
    
    
    
    <category term="云原生" scheme="https://slions.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="kubernetes" scheme="https://slions.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>K8S Runtime CRI OCI contained dockershim（转载）</title>
    <link href="https://slions.github.io/2021/12/07/K8S-Runtime-CRI-OCI-contained-dockershim-%E7%90%86%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://slions.github.io/2021/12/07/K8S-Runtime-CRI-OCI-contained-dockershim-%E7%90%86%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</id>
    <published>2021-12-07T05:32:17.000Z</published>
    <updated>2021-12-15T07:49:35.918Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自CSDN “Frank范”</p></blockquote><h1 id="典型的K8S-Runtime架构"><a href="#典型的K8S-Runtime架构" class="headerlink" title="典型的K8S Runtime架构"></a>典型的K8S Runtime架构</h1><p>从最常见的Docker说起，kubelet和Docker的集成方案图如下：</p><p><img src="https://slions.gitee.io/picbed/img/cri1.png"></p><p>当kubelet要创建一个容器时，需要以下几步：</p><ol><li>Kubelet 通过 CRI 接口（gRPC）调用 dockershim，请求创建一个容器。CRI 即容器运行时接口（Container Runtime Interface），这一步中，Kubelet 可以视作一个简单的 CRI Client，而 dockershim 就是接收请求的 Server。目前 dockershim 的代码其实是内嵌在 Kubelet 中的，所以接收调用的凑巧就是 Kubelet 进程；</li><li>dockershim 收到请求后，转化成 Docker Daemon 能听懂的请求，发到 Docker Daemon 上请求创建一个容器。</li><li>Docker Daemon 早在 1.12 版本中就已经将针对容器的操作移到另一个守护进程——containerd 中了，因此 Docker Daemon 仍然不能帮我们创建容器，而是要请求 containerd 创建一个容器；</li><li>containerd 收到请求后，并不会自己直接去操作容器，而是创建一个叫做 containerd-shim 的进程，让 containerd-shim 去操作容器。这是因为容器进程需要一个父进程来做诸如收集状态，维持 stdin 等 fd 打开等工作。而假如这个父进程就是 containerd，那每次 containerd 挂掉或升级，整个宿主机上所有的容器都得退出了。而引入了 containerd-shim 就规避了这个问题（containerd 和 shim 并不是父子进程关系）；</li><li>我们知道创建容器需要做一些设置 namespaces 和 cgroups，挂载 root filesystem 等等操作，而这些事该怎么做已经有了公开的规范了，那就是 OCI（Open Container Initiative，开放容器标准）。它的一个参考实现叫做 runC。于是，containerd-shim 在这一步需要调用 runC 这个命令行工具，来启动容器；</li><li>runC 启动完容器后本身会直接退出，containerd-shim 则会成为容器进程的父进程，负责收集容器进程的状态，上报给 containerd，并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理，确保不会出现僵尸进程。</li></ol><p>这个过程乍一看像是在搞我们：Docker Daemon 和 dockershim 看上去就是两个不干活躺在中间划水的啊，Kubelet 为啥不直接调用 containerd 呢？<br>当然可以，先看下现在的架构为什么如此繁杂。</p><h1 id="容器历史小叙"><a href="#容器历史小叙" class="headerlink" title="容器历史小叙"></a>容器历史小叙</h1><p>早期的k8s runtime架构，远没这么复杂，kubelet创建容器，直接调用docker daemon，docker daemon自己调用libcontainer就把容器运行起来。</p><p>但往往，事情不会如此简单，一系列政治斗争开始了，先是大佬们认为运行时标准不能被 Docker 一家公司控制，于是就撺掇着搞了开放容器标准 OCI。Docker 则把 libcontainer 封装了一下，变成 runC 捐献出来作为 OCI 的参考实现。</p><p>再接下来就是 rkt(coreos推出的，类似docker) 想从 Docker 那边分一杯羹，希望 Kubernetes 原生支持 rkt 作为运行时，而且 PR 还真的合进去了。维护过一块业务同时接两个需求方的读者老爷应该都知道类似的事情有多坑，Kubernetes 中负责维护 kubelet 的小组 sig-node 也是被狠狠坑了一把。</p><p>大家一看这么搞可不行，今天能有 rkt，明天就能有更多幺蛾子出来，这么搞下去我们小组也不用干活了，整天搞兼容性的 bug 就够呛。于是乎，Kubernetes 1.5 推出了 CRI 机制，即容器运行时接口（Container Runtime Interface），Kubernetes 告诉大家，你们想做 Runtime 可以啊，我们也资瓷欢迎，实现这个接口就成，成功反客为主。</p><p>不过 CRI 本身只是 Kubernetes 推的一个标准，当时的 Kubernetes 尚未达到如今这般武林盟主的地位，容器运行时当然不能说我跟 Kubernetes 绑死了只提供 CRI 接口，于是就有了 shim（垫片）这个说法，一个 shim 的职责就是作为 Adapter 将各种容器运行时本身的接口适配到 Kubernetes 的 CRI 接口上。</p><p>接下来就是 Docker 要搞 Swarm 进军 PaaS 市场，于是做了个架构切分，把容器操作都移动到一个单独的 Daemon 进程 containerd 中去，让 Docker Daemon 专门负责上层的封装编排。可惜 Swarm 在 Kubernetes 面前实在是不够打，惨败之后 Docker 公司就把 containerd 项目捐给 CNCF 缩回去安心搞 Docker 企业版了。</p><p>最后就是我们在上一张图里看到的这一坨东西了，尽管现在已经有 CRI-O，containerd-plugin 这样更精简轻量的 Runtime 架构，dockershim 这一套作为经受了最多生产环境考验的方案，迄今为止仍是 Kubernetes 默认的 Runtime 实现。</p><h1 id="OCI-CRI"><a href="#OCI-CRI" class="headerlink" title="OCI, CRI"></a>OCI, CRI</h1><p>OCI（开放容器标准），规定了2点：</p><ol><li>容器镜像要长啥样，即 ImageSpec。里面的大致规定就是你这个东西需要是一个压缩了的文件夹，文件夹里以 xxx 结构放 xxx 文件；</li><li>容器要需要能接收哪些指令，这些指令的行为是什么，即 RuntimeSpec。这里面的大致内容就是“容器”要能够执行 “create”，“start”，“stop”，“delete” 这些命令，并且行为要规范。</li></ol><p>runC 为啥叫参考实现呢，就是它能按照标准将符合标准的容器镜像运行起来，标准的好处就是方便搞创新，反正只要我符合标准，生态圈里的其它工具都能和我一起愉快地工作（……当然 OCI 这个标准本身制定得不怎么样，真正工程上还是要做一些 adapter 的），那我的镜像就可以用任意的工具去构建，我的“容器”就不一定非要用 namespace 和 cgroups 来做隔离。这就让各种虚拟化容器可以更好地参与到游戏当中，我们暂且不表。</p><p>而 CRI 更简单，单纯是一组 gRPC 接口，扫一眼 kubelet/apis/cri/services.go 就能归纳出几套核心接口：</p><ul><li>一套针对容器操作的接口，包括创建，启停容器等等；</li><li>一套针对镜像操作的接口，包括拉取镜像删除镜像等；</li><li>一套针对 PodSandbox（容器沙箱环境）的操作接口，我们之后再说。</li></ul><p>现在我们可以找到很多符合 OCI 标准或兼容了 CRI 接口的项目，而这些项目就大体构成了整个 Kuberentes 的 Runtime 生态：</p><ul><li>OCI Compatible：runC，Kata（以及它的前身 runV 和 Clear Containers），gVisor。其它比较偏门的还有 Rust 写的 railcar</li><li>CRI Compatible：Docker（借助 dockershim），containerd（借助 CRI-containerd），CRI-O，Frakti，etc</li></ul><p>OCI, CRI 确实不是一个好名字，在这篇文章的语境中更准确的说法：cri-runtime 和 oci-runtime。通过这个粗略的分类，我们其实可以总结出整个 Runtime 架构万变不离其宗的三层抽象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Orchestration API -&gt; Container API(cri-runtime) -&gt; kernel API(oci-runtime)</span><br></pre></td></tr></table></figure><h1 id="Containerd和CRI-O"><a href="#Containerd和CRI-O" class="headerlink" title="Containerd和CRI-O"></a>Containerd和CRI-O</h1><p>上一节看到现在的 Runtime 实在是有点复杂了，而复杂是万恶之源（其实本质上就是想干掉 Docker），于是就有了直接拿 containerd 做 oci-runtime 的方案。当然，除了 Kubernetes 之外，containerd 还要接诸如 Swarm 等调度系统，因此它不会去直接实现 CRI，这个适配工作当然就要交给一个 shim 了。</p><p>containerd 1.0 中，对 CRI 的适配通过一个单独的进程 CRI-containerd 来完成：<br><img src="https://slions.gitee.io/picbed/img/cri02.png"></p><p>containerd 1.1 中做的又更漂亮一点，砍掉了 CRI-containerd 这个进程，直接把适配逻辑作为插件放进了 containerd 主进程中：</p><p><img src="https://slions.gitee.io/picbed/img/cri03.png"></p><p>但在 containerd 做这些事情之情，社区就已经有了一个更为专注的 cri-runtime：CRI-O，它非常纯粹，就是兼容 CRI 和 OCI，做一个 Kubernetes 专用的运行时：</p><p><img src="https://slions.gitee.io/picbed/img/cri04.png"></p><p>其中 conmon 就对应 containerd-shim，大体意图是一样的。<br>CRI-O 和（直接调用）containerd 的方案比起默认的 dockershim 确实简洁很多，但没啥生产环境的验证案例，我所知道的仅仅是 containerd 在 GKE 上是 beta 状态。因此假如你对 Docker 没有特殊的政治恨意，大可不必把 dockershim 这套换掉。</p><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="https://blog.csdn.net/u011563903/article/details/90743853">https://blog.csdn.net/u011563903/article/details/90743853</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自CSDN “Frank范”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;典型的K8S-Runtime架构&quot;&gt;&lt;a href=&quot;#典型的K8S-Runtime架构&quot; class=&quot;headerlink&quot; title=&quot;典型的K8S </summary>
      
    
    
    
    <category term="云原生" scheme="https://slions.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="kubernetes" scheme="https://slions.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>（十一）Jinja2模板</title>
    <link href="https://slions.github.io/2021/12/02/%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89Jinja2%E6%A8%A1%E6%9D%BF/"/>
    <id>https://slions.github.io/2021/12/02/%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89Jinja2%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-12-02T10:43:04.000Z</published>
    <updated>2021-12-02T15:27:43.131Z</updated>
    
    <content type="html"><![CDATA[<p>日常ansible playbook编写过程中，会涉及到很多变量的解析与替换，解析并替换模板表达式的过程称为渲染。</p><p>ansibles使用<code>Jinja2</code>来完成渲染工作，它是Python的一种模板引擎。</p><p>Jinja2模板引擎提供了三种特殊符号来包围模板表达式：</p><ol><li>&#123;&#123;xxx&#125;&#125;：双大括号包围变量或表达式(Ansible中的变量就是它包围的)</li><li>&#123;#xxx#&#125;：Jinja2的注释符号</li><li>&#123;%xxx%&#125;：Jinja2的一些特殊关键字标签，比如if语句、for循环语句等等</li></ol><h1 id="Jinja2条件判断"><a href="#Jinja2条件判断" class="headerlink" title="Jinja2条件判断"></a>Jinja2条件判断</h1><p>Jinja2中可以使用if语句进行条件判断。</p><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if CONDITION1 %&#125;</span><br><span class="line">  string_or_expression1</span><br><span class="line">&#123;% elif CONDITION2 %&#125;</span><br><span class="line">  string_or_expression2</span><br><span class="line">&#123;% elif CONDITION3 %&#125;</span><br><span class="line">  string_or_expression3</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">  string_or_expression4</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>其中elif和else分支都是可省略的。CONDITION部分是条件表达式</p><p>例如：</p><p>当前结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# tree</span><br><span class="line">.</span><br><span class="line">├── test.yml</span><br><span class="line">├── ansible.cfg</span><br><span class="line">├── ansible.log</span><br><span class="line">├── facts</span><br><span class="line">│   ├── 192.168.100.10</span><br><span class="line">│   └── 192.168.100.11</span><br><span class="line">├── inventory</span><br><span class="line">│   └── hosts</span><br><span class="line">└── roles</span><br><span class="line">    └── first</span><br><span class="line">        ├── tasks</span><br><span class="line">        │   └── main.yml</span><br><span class="line">        └── templates</span><br><span class="line">            └── my.j2</span><br></pre></td></tr></table></figure><p>其中模板文件my.j2内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if whatday == &quot;0&quot; %&#125;</span><br><span class="line">周日</span><br><span class="line">&#123;% elif whatday == &quot;1&quot; %&#125;</span><br><span class="line">周一</span><br><span class="line">&#123;% elif whatday == &quot;2&quot; %&#125;</span><br><span class="line">周二</span><br><span class="line">&#123;% elif whatday == &quot;3&quot; %&#125;</span><br><span class="line">周三</span><br><span class="line">&#123;% elif whatday == &quot;4&quot; %&#125;</span><br><span class="line">周四</span><br><span class="line">&#123;% elif whatday == &quot;5&quot; %&#125;</span><br><span class="line">周五</span><br><span class="line">&#123;% elif whatday == &quot;6&quot; %&#125;</span><br><span class="line">周六</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">输入错误</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>上面判断变量whatday的值，然后输出对应的星期几。因为whatday变量的值是字符串，所以让它和字符串形式的数值进行等值比较。当然，也可以使用筛选器将字符串转换为数值后进行数值比较：whatday|int == 0。</p><p>roles/first/tasks中的main.yml内容为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">template:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">my.j2</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">/tmp/dayfile</span></span><br></pre></td></tr></table></figure><p>任务入口文件test.yml内容为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars_prompt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whatday</span></span><br><span class="line">      <span class="attr">default:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">prompt:</span> <span class="string">&quot;输入今天星期几（0:星期日，1:星期一，...，6:星期六）&quot;</span></span><br><span class="line">      <span class="attr">privat:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">first</span></span><br></pre></td></tr></table></figure><p>执行后可以在/tmp/dayfile中查看到替换后的对应字符。</p><p>如果if语句的分支比较简单(没有elif逻辑)，那么可以使用行内if表达式。</p><p>其语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string_or_expr1 if CONDITION else string_or_expr2</span><br></pre></td></tr></table></figure><p>因为行内if是表达式而不是语句块，所以不使用 &#123;%%&#125; 符号，而使用&#123;&#123;&#125;&#125; 。</p><p>例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;&#x27;周末&#x27; if whatday|int &gt; 5 else &#x27;工作日&#x27;&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h1 id="for循环迭代"><a href="#for循环迭代" class="headerlink" title="for循环迭代"></a>for循环迭代</h1><h2 id="for迭代列表"><a href="#for迭代列表" class="headerlink" title="for迭代列表"></a>for迭代列表</h2><p>for循环的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for i in LIST %&#125;</span><br><span class="line">    string_or_expression</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>还支持直接条件判断筛选要参与迭代的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for i in LIST if CONDITION %&#125;</span><br><span class="line">    string_or_expression</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>此外，Jinja2的for语句还允许使用else分支，如果for所迭代的列表LIST是空列表(或没有元素可迭代)，则会执行else分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for i in LIST %&#125;</span><br><span class="line">    string_or_expression</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    string_or_expression</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>例如，在模板文件a.txt.j2中有如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for file in files %&#125;</span><br><span class="line">&lt;&#123;&#123;file&#125;&#125;&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">no file in files</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>playbook文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: localhost</span><br><span class="line">  gather_facts: no</span><br><span class="line">  tasks: </span><br><span class="line">    - template:</span><br><span class="line">        src: a.txt.j2</span><br><span class="line">        dest: /tmp/a.txt</span><br><span class="line">      vars: </span><br><span class="line">        files:</span><br><span class="line">          - /tmp/a1</span><br><span class="line">          - /tmp/a2</span><br><span class="line">          - /tmp/a3</span><br></pre></td></tr></table></figure><p>执行playbook之后，将生成包含如下内容的/tmp/a.txt文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;/tmp/a1&gt;</span><br><span class="line">&lt;/tmp/a2&gt;</span><br><span class="line">&lt;/tmp/a3&gt;</span><br></pre></td></tr></table></figure><p>如果将playbook中的files变量设置为空列表，则会执行else分支，所以生成的/tmp/a.txt的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no file in files</span><br></pre></td></tr></table></figure><p>如果files变量未定义或变量类型不是list，则默认会报错。针对未定义变量，可采用如下策略提供默认空列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for file in (files|default([])) %&#125;</span><br><span class="line">&lt;&#123;&#123;file&#125;&#125;&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">no file in files</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>如果不想迭代文件列表中的/tmp/a3，则可以加上条件判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for file in (files|default([])) if file != &quot;/tmp/a3&quot; %&#125;</span><br><span class="line">&lt;&#123;&#123;file&#125;&#125;&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">no file in files</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>Jinja2的for循环没有提供break和continue的功能，所以只能通过&#123;% for…if…%&#125;来间接实现类似功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日常ansible playbook编写过程中，会涉及到很多变量的解析与替换，解析并替换模板表达式的过程称为渲染。&lt;/p&gt;
&lt;p&gt;ansibles使用&lt;code&gt;Jinja2&lt;/code&gt;来完成渲染工作，它是Python的一种模板引擎。&lt;/p&gt;
&lt;p&gt;Jinja2模板引擎提</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（十）ansible异常处理</title>
    <link href="https://slions.github.io/2021/12/02/%EF%BC%88%E5%8D%81%EF%BC%89ansible%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://slions.github.io/2021/12/02/%EF%BC%88%E5%8D%81%EF%BC%89ansible%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2021-12-02T04:50:53.000Z</published>
    <updated>2021-12-02T07:23:35.285Z</updated>
    
    <content type="html"><![CDATA[<p>在日常使用ansible的过程中会发现，执行shell或command模块时，Ansible只认为0退出状态码是正确的，其它所有退出状态码都是失败的，但我们自己知道非0退出状态码并非一定代表着失败。</p><p>比如下例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">        ls /home/aa</span></span><br><span class="line"><span class="string"></span>      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">res.stdout</span></span><br></pre></td></tr></table></figure><p>执行结果会直接报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TASK [shell] *****************************************************************************************************</span><br><span class="line">fatal: [localhost]: FAILED! =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;ls /home/aa\n&quot;, &quot;delta&quot;: &quot;0:00:00.034093&quot;, &quot;end&quot;: &quot;2021-12-02 14:16:45.029276&quot;, &quot;msg&quot;: &quot;non-zero return code&quot;, &quot;rc&quot;: 2, &quot;start&quot;: &quot;2021-12-02 14:16:44.995183&quot;, &quot;stderr&quot;: &quot;ls: 无法访问/home/aa: 没有那个文件或目录&quot;, &quot;stderr_lines&quot;: [&quot;ls: 无法访问/home/aa: 没有那个文件或目录&quot;], &quot;stdout&quot;: &quot;&quot;, &quot;stdout_lines&quot;: []&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">localhost                  : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p>默认情况下，Ansible端无法连接某个节点时、某节点执行某个任务失败时，Ansible都会将这个节点从活动节点列表中(即<code>play_hosts</code>变量中)移除，以避免该节点继续执行之后的任务。用户可以去修改Ansible对这种异常现象的默认处理方式，比如遇到错误也不让该节点退出舞台，而是继续执行后续任务，又或者某节点执行任务失败并让整个play都失败。</p><h1 id="fail模块"><a href="#fail模块" class="headerlink" title="fail模块"></a>fail模块</h1><p>使用<code>fail</code>模块，可以人为制造一个失败的任务。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">fail:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;已手动设置失败&quot;</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">inventory_hostname</span> <span class="string">==</span> <span class="string">&#x27;192.168.100.10&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;成功了&quot;</span></span><br></pre></td></tr></table></figure><p>上面的fail会任务失败，并使得此节点不会执行后续任务，但其它节点会继续执行任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PLAY [test] ******************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [fail] ******************************************************************************************************</span><br><span class="line">fatal: [192.168.100.10]: FAILED! =&gt; &#123;&quot;changed&quot;: false, &quot;msg&quot;: &quot;已手动设置失败&quot;&#125;</span><br><span class="line">skipping: [192.168.100.11]</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [192.168.100.11] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;成功了&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">192.168.100.10             : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.168.100.11             : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><h1 id="assert模块"><a href="#assert模块" class="headerlink" title="assert模块"></a>assert模块</h1><p><code>assert</code>与其他编程语言中的功能一致，断言功能，对于当满足某某条件时就失败的逻辑，可直接使用<code>assert</code>模块实现。</p><p>例如上面的例子可改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">assert:</span></span><br><span class="line">        <span class="attr">that:</span></span><br><span class="line">          <span class="bullet">-</span>  <span class="string">inventory_hostname</span> <span class="type">!=</span> <span class="string">&#x27;192.168.100.10&#x27;</span></span><br><span class="line">        <span class="attr">fail_msg:</span> <span class="string">&quot;失败了&quot;</span></span><br><span class="line">        <span class="attr">success_msg:</span> <span class="string">&quot;成功了&quot;</span></span><br></pre></td></tr></table></figure><p>其中<code>that</code>参数接收一个列表，用于定义一个或多个条件，如果条件全为true，则任务成功，只要有一个条件为false，则任务失败。<code>fail_msg</code>(或其别名参数<code>msg</code>)定义任务失败时的信息，<code>success_msg</code>定义任务成功时的信息。</p><h1 id="ignore-errors"><a href="#ignore-errors" class="headerlink" title="ignore_errors"></a>ignore_errors</h1><p>当某个任务执行失败(或被Ansible认为失败，比如通过返回值判断)时，如果不想让这个失败的任务导致节点退出，可以使用<code>ignore_errors</code>指令来忽略失败。</p><p>例如开头的那个例子，加上<code>ignore_errors</code>指令：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">        ls /home/aa</span></span><br><span class="line"><span class="string"></span>      <span class="attr">ignore_errors:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">res.stdout</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [shell] *****************************************************************************************************</span><br><span class="line">fatal: [localhost]: FAILED! =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;ls /home/aa\n&quot;, &quot;delta&quot;: &quot;0:00:00.034821&quot;, &quot;end&quot;: &quot;2021-12-02 14:41:13.638790&quot;, &quot;msg&quot;: &quot;non-zero return code&quot;, &quot;rc&quot;: 2, &quot;start&quot;: &quot;2021-12-02 14:41:13.603969&quot;, &quot;stderr&quot;: &quot;ls: 无法访问/home/aa: 没有那个文件或目录&quot;, &quot;stderr_lines&quot;: [&quot;ls: 无法访问/home/aa: 没有那个文件或目录&quot;], &quot;stdout&quot;: &quot;&quot;, &quot;stdout_lines&quot;: []&#125;</span><br><span class="line">...ignoring</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;res.stdout&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=1</span><br></pre></td></tr></table></figure><p>可以看到，加上<code>ignore_errors</code>后成功执行了debug任务，最后的任务汇总处的ignored=1证明忽略了一个错误。但是从结果中可以看到，虽然确实忽略了错误，但红红报错信息仍然提醒在终端上，让不了解此机制的人感觉很慌。这时可以使用<code>failed_when</code>解决。</p><h1 id="failed-when"><a href="#failed-when" class="headerlink" title="failed_when"></a>failed_when</h1><p><code>failed_when</code>指令可以让用户自己定义任务何时失败：当条件表达式为true时任务强制失败，当条件表达式为false时，任务强制不失败。</p><p>接着改下上面的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">        ls /home/aa</span></span><br><span class="line"><span class="string"></span>      <span class="attr">failed_when:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">res.stdout</span></span><br></pre></td></tr></table></figure><p>此时查看输出，已经没有相关报错了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [shell] *****************************************************************************************************</span><br><span class="line">changed: [localhost]</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;res.stdout&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p><code>failed_when</code>经常会和shell或command模块以及register指令一起使用，用来手动定义失败的退出状态码。比如，退出状态码为<code>0 1 2</code>都认为任务成功执行，其它状态码都认为认为执行失败。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">        ls /home/aa</span></span><br><span class="line"><span class="string"></span>      <span class="attr">failed_when:</span> <span class="string">res.rc</span> <span class="string">not</span> <span class="string">in</span> <span class="string">(0,1,2)</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">res.stdout</span></span><br></pre></td></tr></table></figure><p><code>failed_when</code>和<code>when</code>一样都可以将多个条件表达式写成列表的形式来表示逻辑与。</p><h1 id="rescue和always"><a href="#rescue和always" class="headerlink" title="rescue和always"></a>rescue和always</h1><p>Ansible允许在任务失败的时候，去执行某些任务，还允许不管任务失败与否，都执行某些任务。</p><ol><li>rescue和always都是block级别的指令</li><li>rescue表示block中任意任务失败后，都执行rescue中定义的任务，但如果block中没有任务失败，则不执行rescue中的任务</li><li>always表示block中任务无论失败与否，都执行always中定义的任务</li></ol><p>例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">block:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">fail:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;hello</span> <span class="string">world&quot;</span></span><br><span class="line">      <span class="attr">rescue:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;rescue1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;rescue2&quot;</span></span><br><span class="line">      <span class="attr">always:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;always1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span> <span class="string">msg=&quot;always2&quot;</span></span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [fail] ******************************************************************************************************</span><br><span class="line">fatal: [localhost]: FAILED! =&gt; &#123;&quot;changed&quot;: false, &quot;msg&quot;: &quot;Failed as requested from task&quot;&#125;</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;rescue1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;rescue2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;always1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;always2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP *******************************************************************************************************</span><br><span class="line">localhost                  : ok=4    changed=0    unreachable=0    failed=0    skipped=0    rescued=1    ignored=0</span><br></pre></td></tr></table></figure><p>block中的fail任务会失败，于是跳转到rescue中开始执行任务，然后再跳转到always中执行任务。</p><p>如果注释掉block中的fail模块任务，则block中没有任务失败，于是rescue中的任务不会执行，但是在执行完block中所有任务后会跳转到always中继续执行任务。</p><h1 id="处理连接失败-unreachable-的异常"><a href="#处理连接失败-unreachable-的异常" class="headerlink" title="处理连接失败(unreachable)的异常"></a>处理连接失败(unreachable)的异常</h1><p>如果Ansible突然和某个节点无法连接上，会将此节点设置为UNREACHABLE状态，并从活动节点列表(<code>play_hosts</code>)中删除。</p><p>如果想要忽略连接失败的节点，可设置<code>ignore_unreachable: true</code>指令，该指令是Ansible 2.7添加的，可设置在play、Role、block、task级别上。</p><p>当Ansible遇到UNREACHABLE时，会进行连接重试。重试次数可在Ansible配置文件中配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# cat /etc/ansible/ansible.cfg |grep -w retries</span><br><span class="line"><span class="meta">#</span><span class="bash">retries = 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常使用ansible的过程中会发现，执行shell或command模块时，Ansible只认为0退出状态码是正确的，其它所有退出状态码都是失败的，但我们自己知道非0退出状态码并非一定代表着失败。&lt;/p&gt;
&lt;p&gt;比如下例：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（九）ansible流程控制</title>
    <link href="https://slions.github.io/2021/12/01/%EF%BC%88%E4%B9%9D%EF%BC%89ansible%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://slions.github.io/2021/12/01/%EF%BC%88%E4%B9%9D%EF%BC%89ansible%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2021-12-01T12:27:28.000Z</published>
    <updated>2021-12-02T07:44:56.420Z</updated>
    
    <content type="html"><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>ansible提供的条件判断只有when指令，因为可以写Jinja2条件判断表达式，所以判断方式比较灵活。</p><h2 id="同时满足多个条件"><a href="#同时满足多个条件" class="headerlink" title="同时满足多个条件"></a>同时满足多个条件</h2><p>常见的编程语言在多条件判断时要么使用逻辑与（<code>and</code>或<code>&amp;&amp;</code>）,要么使用逻辑或（<code>or</code>或<code>||</code>）。ansible同样支持这种写法。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">when:</span> <span class="string">age</span> <span class="string">&gt;</span> <span class="number">18</span> <span class="string">and</span> <span class="string">age</span> <span class="string">&lt;</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>也可以将这些条件以列表的方式提供。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">item</span></span><br><span class="line">      <span class="attr">when:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">item</span> <span class="string">&gt;</span> <span class="number">3</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">item</span> <span class="string">&lt;</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">loop:</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><h2 id="按条件导入文件"><a href="#按条件导入文件" class="headerlink" title="按条件导入文件"></a>按条件导入文件</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">include_tasks:</span> <span class="string">RedHat.yml</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_os_family</span> <span class="string">==</span> <span class="string">&quot;RedHat&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">include_tasks:</span> <span class="string">Centos.yml</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_os_family</span> <span class="string">==</span> <span class="string">&quot;Centos&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更加精炼的写法可以参考</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">include_tasks:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;ansible_os_family&#125;&#125;</span>.yml&quot;</span></span><br></pre></td></tr></table></figure><h2 id="when和循环"><a href="#when和循环" class="headerlink" title="when和循环"></a>when和循环</h2><p>当when指令和循环指令一起使用时，when的判断操作在每轮循环内执行。详细内容下文中描述。</p><h1 id="循环迭代"><a href="#循环迭代" class="headerlink" title="循环迭代"></a>循环迭代</h1><blockquote><p>ansible 2.5之前的循环迭代都使用<code>with_xxx</code>来完成，比如<code>with_items</code>,后面加入了<code>loop</code>指令，<code>loop</code>指令与<code>with_list</code>指令等价。</p><p><code>with_xxx</code>语法都使用对应的lookup插件来实现（比如<code>with_list</code>使用的是lookup的list插件），如果存在某lookup插件xxx，就可以使用<code>with_xxx</code>来迭代。</p></blockquote><h2 id="with-list"><a href="#with-list" class="headerlink" title="with_list"></a>with_list</h2><p>直接上例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">touch</span></span><br><span class="line">      <span class="attr">with_list:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">aaa</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">bbb</span></span><br></pre></td></tr></table></figure><p>与上面<code>with_list</code>等价的loop语法：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">touch</span></span><br><span class="line">  <span class="attr">loop:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">aaa</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bbb</span></span><br></pre></td></tr></table></figure><h2 id="with-items和with-flattened"><a href="#with-items和with-flattened" class="headerlink" title="with_items和with_flattened"></a>with_items和with_flattened</h2><p>with_list用于迭代简单列表，有时候列表中会嵌套列表。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">name:</span> [<span class="string">a</span>,[<span class="string">b1</span>,<span class="string">b2</span>],<span class="string">c</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_items:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;name&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>注意，<code>with_items</code>只压平嵌套列表的第一层，不会递归压平第二层、第三层…</p><p>与with_items等价的loop指令的写法为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nested_list | flatten(levels=1) &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>筛选器函数flatten()默认会递归压平所有嵌套列表，如果只是压平第一层，需指定参数levels=1。</p><p>此外，还存在lookup插件：items、flattened，前者只压第一层，后者递归压平所有嵌套层次。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">name:</span> [<span class="string">a</span>,[<span class="string">b1</span>,<span class="string">b2</span>],<span class="string">c</span>,[<span class="string">d1</span>,<span class="string">d2</span>,[<span class="string">e1</span>,<span class="string">e2</span>,<span class="string">e3</span>]]]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_flattened:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;name&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="with-dict"><a href="#with-dict" class="headerlink" title="with_dict"></a>with_dict</h2><p><code>with_dict</code>用于迭代一个字典结构，迭代时可以使用<code>item.key</code>表示每个字典元素的key，<code>item.value</code>表示每个字典元素的value。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">users:</span></span><br><span class="line">      <span class="attr">slions:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">slions</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">29</span></span><br><span class="line">      <span class="attr">zhangsan:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;who: <span class="template-variable">&#123;&#123;item.key&#125;&#125;</span></span></span><br><span class="line"><span class="string">              name: <span class="template-variable">&#123;&#123;item.value.name&#125;&#125;</span></span></span><br><span class="line"><span class="string">              age: <span class="template-variable">&#123;&#123;item.value.age&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_dict:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;users&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>与<code>with_dict</code>等价的loop指令有两种写法：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;lookup(&#x27;dict&#x27;, users)&#125;&#125;</span>&quot;</span></span><br><span class="line"><span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;users | dict2items&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>另外，在Ansible 2.8中可以自定义<code>dict2items</code>筛选器函数得到的key和value的名称。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">users:</span></span><br><span class="line">      <span class="attr">slions:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">slions</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">29</span></span><br><span class="line">      <span class="attr">zhangsan:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;who: <span class="template-variable">&#123;&#123;item.k&#125;&#125;</span></span></span><br><span class="line"><span class="string">              name: <span class="template-variable">&#123;&#123;item.v.name&#125;&#125;</span></span></span><br><span class="line"><span class="string">              age: <span class="template-variable">&#123;&#123;item.v.age&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;users|dict2items(key_name=&#x27;k&#x27;,value_name=&#x27;v&#x27;)&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="with-sequence"><a href="#with-sequence" class="headerlink" title="with_sequence"></a>with_sequence</h2><p>Ansible的lookup插件sequence也可以用来生成连续数(Jinja2的range也可以生成连续数)。其中：</p><ul><li>start参数指定序列的起始数，不指定该参数时默认从1开始</li><li>end参数指定序列的终止数</li><li>stride参数指定序列的步进值。不指定该参数时，步进为1</li><li>format参数指定序列的输出格式，遵循printf风格</li><li>count参数指定生成序列数的个数，不能和end参数共存</li></ul><p>此外，sequence插件的各个参数可以简写为如下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[start-]end[/stride][:format]</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;_<span class="template-variable">&#123;&#123;item&#125;&#125;</span>_&quot;</span></span><br><span class="line">      <span class="attr">with_sequence:</span> <span class="string">start=0</span> <span class="string">end=5</span> <span class="string">stride=2</span> <span class="string">format=a%02d</span></span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *********************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [debug] *************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; (item=a00) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;_a00_&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [localhost] =&gt; (item=a02) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;_a02_&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [localhost] =&gt; (item=a04) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;_a04_&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP ***************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p>也可简写为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">with_sequence:</span> <span class="number">0</span><span class="number">-5</span><span class="string">/2:a%02d</span></span><br></pre></td></tr></table></figure><p>因为生成的每个序列数都会经过字符串格式化，所以得到的每个序列元素都是字符串。如果想要转换成数值，需使用Jinja2的Filter。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;1 + item|int&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_sequence:</span> <span class="string">start=0</span> <span class="string">end=3</span></span><br></pre></td></tr></table></figure><p>与with_sequence等价的loop写法为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; &#x27;a%02d&#x27; | format(item) &#125;&#125;</span>&quot;</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; range(0, 5, 2)|list &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>Jinja2的range()也可以生成序列数。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(start,end,step)</span><br></pre></td></tr></table></figure><p>注意range()不包含结尾数end。</p><h2 id="with-fileglob"><a href="#with-fileglob" class="headerlink" title="with_fileglob"></a>with_fileglob</h2><p><code>with_fileglob</code>用于迭代通配到的每个文件名。</p><p>例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">copy:</span> </span><br><span class="line">        <span class="attr">src:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span> </span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/</span></span><br><span class="line">      <span class="attr">with_fileglob:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/m*.conf</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/*.cnf</span></span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PLAY [localhost] *********************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [copy] **************************************************************************************************</span><br><span class="line">changed: [localhost] =&gt; (item=/etc/man_db.conf)</span><br><span class="line">changed: [localhost] =&gt; (item=/etc/mke2fs.conf)</span><br><span class="line">changed: [localhost] =&gt; (item=/etc/my.cnf)</span><br><span class="line"></span><br><span class="line">PLAY RECAP ***************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><h2 id="with-lines"><a href="#with-lines" class="headerlink" title="with_lines"></a>with_lines</h2><p><code>with_lines</code>用于迭代命令输出结果的每一行。</p><p>这功能也是非常实用的，如下示例：find找出一堆文件，然后进行操作(比如copy)。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">copy:</span> </span><br><span class="line">        <span class="attr">src:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span> </span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/home/myscript/</span></span><br><span class="line">      <span class="attr">with_lines:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">find</span> <span class="string">~</span> <span class="string">-maxdepth</span> <span class="number">1</span> <span class="string">-type</span> <span class="string">f</span> <span class="string">-name</span> <span class="string">&quot;*.sh&quot;</span></span><br></pre></td></tr></table></figure><h2 id="循环和when"><a href="#循环和when" class="headerlink" title="循环和when"></a>循环和when</h2><p>当<code>with_xxx</code>或<code>loop</code>指令和<code>when</code>指令一起使用时，<code>when</code>将在循环的内部进行条件判断。也就是说，when决定每轮迭代时是否执行一个任务，而不是决定整个循环是否进行。</p><h2 id="循环和register"><a href="#循环和register" class="headerlink" title="循环和register"></a>循环和register</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">item</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">res</span></span><br></pre></td></tr></table></figure><p>其中第二个debug任务的执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">  &quot;res&quot;: &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;msg&quot;: &quot;All items completed&quot;,</span><br><span class="line">    &quot;results&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: false,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;item&quot;: 11</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: false,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;item&quot;: 22</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个shell模块的示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> &#123;&#123;<span class="string">item</span>&#125;&#125;</span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">res</span></span><br></pre></td></tr></table></figure><p>其中第二个任务的执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ok: [localhost] =&gt; &#123;</span><br><span class="line">  &quot;res&quot;: &#123;</span><br><span class="line">    &quot;changed&quot;: true,</span><br><span class="line">    &quot;msg&quot;: &quot;All items completed&quot;,</span><br><span class="line">    &quot;results&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: true,</span><br><span class="line">        &quot;cmd&quot;: &quot;echo 11&quot;,</span><br><span class="line">        &quot;delta&quot;: &quot;0:00:00.001643&quot;,</span><br><span class="line">        &quot;end&quot;: &quot;2021-12-02 11:40:05.012729&quot;,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;invocation&quot;: &#123;</span><br><span class="line">          &quot;module_args&quot;: &#123;</span><br><span class="line">            ......</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;item&quot;: 11,</span><br><span class="line">        &quot;rc&quot;: 0,</span><br><span class="line">        &quot;start&quot;: &quot;2021-12-02 11:40:05.011086&quot;,</span><br><span class="line">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class="line">        &quot;stderr_lines&quot;: [],</span><br><span class="line">        &quot;stdout&quot;: &quot;11&quot;,</span><br><span class="line">        &quot;stdout_lines&quot;: [</span><br><span class="line">          &quot;11&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        ......</span><br><span class="line">        &quot;stdout&quot;: &quot;22&quot;,</span><br><span class="line">        &quot;stdout_lines&quot;: [</span><br><span class="line">          &quot;22&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见，当register和循环指令结合时，会将每轮迭代的模块执行结果以一个字典的方式追加在一个名为results的列表中。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;res&quot;: &#123;</span><br><span class="line">  &quot;changed&quot;: true,</span><br><span class="line">  &quot;msg&quot;: &quot;All items completed&quot;,</span><br><span class="line">  &quot;results&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...第一轮迭代模块返回值...</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      ...第二轮迭代模块返回值...</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，可使用<code>res.results</code>来访问每轮的迭代结果。例如，再次迭代遍历这些结果：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> &#123;&#123;<span class="string">item</span>&#125;&#125;</span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">item.stdout</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;res.results&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p>循环控制功能需要在使用循环的时候使用<code>loop_control</code>指令，该指令有一些参数，每种参数都是一个控制开关。</p><h3 id="label参数"><a href="#label参数" class="headerlink" title="label参数"></a>label参数</h3><p>循环迭代时，每轮迭代过程中都会将当前的item输出(要么输出到屏幕，要么输出到日志)。如果所迭代的每项的内容(即每个item)很短，这倒无所谓，但如果item的内容很长，则可读性比较差。</p><p>示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> &#123;&#123;<span class="string">item</span>&#125;&#125;</span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">item.stdout</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;res.results&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; (item=&#123;u&#x27;stderr_lines&#x27;: [], u&#x27;ansible_loop_var&#x27;: u&#x27;item&#x27;, u&#x27;end&#x27;: u&#x27;2021-12-02 11:57:33.161219&#x27;, u&#x27;stderr&#x27;: u&#x27;&#x27;, u&#x27;stdout&#x27;: u&#x27;11&#x27;, u&#x27;changed&#x27;: True, u&#x27;failed&#x27;: False, u&#x27;delta&#x27;: u&#x27;0:00:00.040706&#x27;, u&#x27;cmd&#x27;: u&#x27;echo 11&#x27;, u&#x27;item&#x27;: 11, u&#x27;rc&#x27;: 0, u&#x27;invocation&#x27;: &#123;u&#x27;module_args&#x27;: &#123;u&#x27;warn&#x27;: False, u&#x27;executable&#x27;: None, u&#x27;_uses_shell&#x27;: True, u&#x27;strip_empty_ends&#x27;: True, u&#x27;_raw_params&#x27;: u&#x27;echo 11&#x27;, u&#x27;removes&#x27;: None, u&#x27;argv&#x27;: None, u&#x27;creates&#x27;: None, u&#x27;chdir&#x27;: None, u&#x27;stdin_add_newline&#x27;: True, u&#x27;stdin&#x27;: None&#125;&#125;, u&#x27;stdout_lines&#x27;: [u&#x27;11&#x27;], u&#x27;start&#x27;: u&#x27;2021-12-02 11:57:33.120513&#x27;&#125;) =&gt; &#123;</span><br><span class="line">    &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">    &quot;item&quot;: &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: true,</span><br><span class="line">        &quot;cmd&quot;: &quot;echo 11&quot;,</span><br><span class="line">        &quot;delta&quot;: &quot;0:00:00.040706&quot;,</span><br><span class="line">        &quot;end&quot;: &quot;2021-12-02 11:57:33.161219&quot;,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;invocation&quot;: &#123;</span><br><span class="line">            &quot;module_args&quot;: &#123;</span><br><span class="line">                &quot;_raw_params&quot;: &quot;echo 11&quot;,</span><br><span class="line">                &quot;_uses_shell&quot;: true,</span><br><span class="line">                &quot;argv&quot;: null,</span><br><span class="line">                &quot;chdir&quot;: null,</span><br><span class="line">                &quot;creates&quot;: null,</span><br><span class="line">                &quot;executable&quot;: null,</span><br><span class="line">                &quot;removes&quot;: null,</span><br><span class="line">                &quot;stdin&quot;: null,</span><br><span class="line">                &quot;stdin_add_newline&quot;: true,</span><br><span class="line">                &quot;strip_empty_ends&quot;: true,</span><br><span class="line">                &quot;warn&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;item&quot;: 11,</span><br><span class="line">        &quot;rc&quot;: 0,</span><br><span class="line">        &quot;start&quot;: &quot;2021-12-02 11:57:33.120513&quot;,</span><br><span class="line">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class="line">        &quot;stderr_lines&quot;: [],</span><br><span class="line">        &quot;stdout&quot;: &quot;11&quot;,</span><br><span class="line">        &quot;stdout_lines&quot;: [</span><br><span class="line">            &quot;11&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;item.stdout&quot;: &quot;11&quot;</span><br></pre></td></tr></table></figure><p>使用label参数可以自定义迭代时显示的内容来替代默认显示的item。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> &#123;&#123;<span class="string">item</span>&#125;&#125;</span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mylist &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">item.stdout</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;res.results&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop_control:</span></span><br><span class="line">        <span class="attr">label:</span> <span class="string">&quot;this is test play&quot;</span></span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TASK [debug] *****************************************************************************************************</span><br><span class="line">ok: [localhost] =&gt; (item=this is test play) =&gt; &#123;</span><br><span class="line">    &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">    &quot;item&quot;: &#123;</span><br><span class="line">        &quot;ansible_loop_var&quot;: &quot;item&quot;,</span><br><span class="line">        &quot;changed&quot;: true,</span><br><span class="line">        &quot;cmd&quot;: &quot;echo 11&quot;,</span><br><span class="line">        &quot;delta&quot;: &quot;0:00:00.034184&quot;,</span><br><span class="line">        &quot;end&quot;: &quot;2021-12-02 12:21:47.385021&quot;,</span><br><span class="line">        &quot;failed&quot;: false,</span><br><span class="line">        &quot;invocation&quot;: &#123;</span><br><span class="line">            &quot;module_args&quot;: &#123;</span><br><span class="line">                &quot;_raw_params&quot;: &quot;echo 11&quot;,</span><br><span class="line">                &quot;_uses_shell&quot;: true,</span><br><span class="line">                &quot;argv&quot;: null,</span><br><span class="line">                &quot;chdir&quot;: null,</span><br><span class="line">                &quot;creates&quot;: null,</span><br><span class="line">                &quot;executable&quot;: null,</span><br><span class="line">                &quot;removes&quot;: null,</span><br><span class="line">                &quot;stdin&quot;: null,</span><br><span class="line">                &quot;stdin_add_newline&quot;: true,</span><br><span class="line">                &quot;strip_empty_ends&quot;: true,</span><br><span class="line">                &quot;warn&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;item&quot;: 11,</span><br><span class="line">        &quot;rc&quot;: 0,</span><br><span class="line">        &quot;start&quot;: &quot;2021-12-02 12:21:47.350837&quot;,</span><br><span class="line">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class="line">        &quot;stderr_lines&quot;: [],</span><br><span class="line">        &quot;stdout&quot;: &quot;11&quot;,</span><br><span class="line">        &quot;stdout_lines&quot;: [</span><br><span class="line">            &quot;11&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;item.stdout&quot;: &quot;11&quot;</span><br></pre></td></tr></table></figure><h3 id="pause参数"><a href="#pause参数" class="headerlink" title="pause参数"></a>pause参数</h3><p><code>loop_control</code>的<code>pause</code>参数可以控制每轮迭代之间的时间间隔。</p><p>以下示例表示第一轮迭代后，等待一秒，再进入第二轮迭代。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">item</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;mylist&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop_control:</span></span><br><span class="line">        <span class="attr">pause:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="index-var参数"><a href="#index-var参数" class="headerlink" title="index_var参数"></a>index_var参数</h3><p><code>index_var</code>参数可以指定一个变量，这个变量可以记录每轮循环迭代过程中的索引位，也即表示当前是第几轮迭代。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;index: <span class="template-variable">&#123;&#123;idx&#125;&#125;</span>, value: <span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;mylist&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop_control:</span></span><br><span class="line">        <span class="attr">index_var:</span> <span class="string">idx</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ok: [localhost] =&gt; (item=11) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;index: 0, value: 11&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [localhost] =&gt; (item=22) =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;index: 1, value: 22&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>index_var</code>，可以进行一些条件判断。比如只在第一轮循环时执行某任务：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars:</span> </span><br><span class="line">    <span class="attr">mylist:</span> [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;index: <span class="template-variable">&#123;&#123;idx&#125;&#125;</span>, value: <span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">idx</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;mylist&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">loop_control:</span></span><br><span class="line">        <span class="attr">index_var:</span> <span class="string">idx</span></span><br></pre></td></tr></table></figure><h1 id="其他流程控制"><a href="#其他流程控制" class="headerlink" title="其他流程控制"></a>其他流程控制</h1><h2 id="pause模块"><a href="#pause模块" class="headerlink" title="pause模块"></a>pause模块</h2><p>Ansible中，可以使用<code>pause</code>模块或<code>wait_for</code>模块来实现睡眠等待的功能，先简单演示pause模块的用法。</p><p>pause可以等待几分钟、几秒钟、等待交互式输入确定。</p><p>例如，先睡眠10秒，再执行debug任务：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">        <span class="attr">seconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>睡眠1分钟：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">pause:</span> </span><br><span class="line">    <span class="attr">minutes:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>交互式输入Enter键确认：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">      <span class="attr">msg:</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>带提醒的交互式输入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">    <span class="attr">prompt:</span> <span class="string">&quot;输入你的用户名!&quot;</span></span><br></pre></td></tr></table></figure><p>隐藏用户的输入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">    <span class="attr">prompt:</span> <span class="string">&quot;输入你的用户名&quot;</span></span><br><span class="line">    <span class="attr">echo:</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure><p>将用户交互式输入内容注册成变量：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pause:</span></span><br><span class="line">        <span class="attr">prompt:</span> <span class="string">&quot;输入用户密码&quot;</span></span><br><span class="line">        <span class="attr">echo:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">passwd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;passwd.user_input&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="wait-for模块"><a href="#wait-for模块" class="headerlink" title="wait_for模块"></a>wait_for模块</h2><p><code>wait_for</code>模块可以等待多种事件的发生，常用的功能有：</p><ol><li>等待端口打开和端口关闭</li><li>等待没有活动连接(在等待移除某个负载均衡节点时可能会有用)\</li><li>等待文件被创建或移除</li><li>等待或睡眠指定秒数</li><li>等待系统重启(即等待SSH连接重新建立)</li><li>等待文件中出现某个字符串</li><li>等待进程退出</li></ol><p>常见用法：</p><p>睡眠几秒后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 休眠五秒，然后任务继续</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>等待文件存在后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/a.log</span></span><br><span class="line">    <span class="attr">deley:</span> <span class="number">3</span>     <span class="comment"># 3秒后才开始进入第一轮事件等待检查(默认值为0)</span></span><br><span class="line">    <span class="attr">sleep:</span> <span class="number">1</span>     <span class="comment"># 每隔1秒进行一次事件等待检查(默认值为1)</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">20</span>  <span class="comment"># 最多等待20秒(默认值为300)，如果20秒内未等待到事件发生，则wait_for任务失败并报错</span></span><br></pre></td></tr></table></figure><p>等待文件不存在后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/a.log</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">absent</span></span><br></pre></td></tr></table></figure><p>等待进程不存在后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pids:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;sleep&quot;</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">sleep_pids</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/proc/<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">absent</span></span><br><span class="line">      <span class="attr">loop:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;sleep_pids.pids&#125;&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure><p>pids模块可以根据进程名获取进程PID列表(可能是空列表、单元素列表、多元素列表)。</p><blockquote><p>注意该模块要求先安装python的psutil模块，所以如果要使用pids，可执行：</p><p>$ yum install python3-devel<br>$ pip3 install psutil</p></blockquote><p>等待文件中出现某字符串后，任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/a.log</span></span><br><span class="line">    <span class="attr">search_regex:</span> <span class="string">completed|finished</span></span><br></pre></td></tr></table></figure><p>等待某端口打开，然后任务继续。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">wait_for:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; item &#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">    <span class="attr">delay:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">loop:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">10251</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">10252</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2379</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6443</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。&lt;/p&gt;
&lt;h1 id=&quot;条件判断&quot;&gt;&lt;a href=&quot;#条件判断&quot; class=&quot;headerlink&quot; title=&quot;条件判断&quot;&gt;&lt;/a&gt;条件判断&lt;/h1&gt;&lt;p&gt;ansible提</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（八）ansible变量</title>
    <link href="https://slions.github.io/2021/12/01/%EF%BC%88%E5%85%AB%EF%BC%89ansible%E5%8F%98%E9%87%8F/"/>
    <id>https://slions.github.io/2021/12/01/%EF%BC%88%E5%85%AB%EF%BC%89ansible%E5%8F%98%E9%87%8F/</id>
    <published>2021-12-01T10:29:33.000Z</published>
    <updated>2021-12-01T10:39:50.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表、字典变量"><a href="#列表、字典变量" class="headerlink" title="列表、字典变量"></a>列表、字典变量</h1><p>列表和字典是ansible中常见的变量类型。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">human:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">slions</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">29</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp/a.txt</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp/b.txt</span></span><br></pre></td></tr></table></figure><p>对于这类变量的访问，ansible中提供了两种方式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;name: <span class="template-variable">&#123;&#123;human.name&#125;&#125;</span>, age: <span class="template-variable">&#123;&#123;file[0]&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h1 id="extra-vars定义额外变量"><a href="#extra-vars定义额外变量" class="headerlink" title="extra-vars定义额外变量"></a>extra-vars定义额外变量</h1><p>ansible-playbook命令的<code>-e</code>选项或<code>--extra-vars</code>选项可定义变量或引入变量文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义单个变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ansible-playbook -e <span class="string">&#x27;var1=&quot;value1&quot;&#x27;</span> xxx.yml</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义多个变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ansible-playbook -e <span class="string">&#x27;var1=&quot;value1&quot; var2=&quot;value2&quot;&#x27;</span> xxx.yml</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 引入单个变量文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ansible-playbook -e <span class="string">&#x27;@varfile1.yml&#x27;</span> xxx.yml</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 引入多个变量文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ansible-playbook -e <span class="string">&#x27;@varfile1.yml&#x27;</span> -e <span class="string">&#x27;@varfile2.yml&#x27;</span> xxx.yml</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为是通过选项的方式来定义变量的，所以它所定义的变量是全局的，对所有play都有效。</p><h1 id="inventory变量"><a href="#inventory变量" class="headerlink" title="inventory变量"></a>inventory变量</h1><p>在解析inventory时，会收集inventory相关的变量。</p><p>inventory变量主要分为两种：</p><ol><li>连接目标节点时的行为控制变量，即决定如何连接目标节点</li><li>主机变量</li></ol><p>行为控制变量(如ansible_port、ansible_host等)用于指定Ansible端连接目标节点时的连接参数，可设置的参数项比较多，可参见<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#connecting-to-hosts-behavioral-inventory-parameters">官方手册</a></p><p>inventory的主机变量有多种定义途径，例如直接在inventory文件中为某个主机定义变量，也可以在主机组中定义变量，主机组变量会在解析inventory的时候整理到主机变量中去。此外还可以将变量定义在host_vars/和group_vars/目录内，可参考<a href="/2021/08/24/%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%BB%E6%9C%BA%E6%B8%85%E5%8D%95inventory/" title="前文">前文</a>。</p><h1 id="role变量"><a href="#role变量" class="headerlink" title="role变量"></a>role变量</h1><p>Role中主要有两个地方定义变量：</p><ol><li><code>roles/ROLE_NAME/defaults/main.yml</code></li><li><code>roles/ROLE_NAME/vars/main.yml</code></li></ol><blockquote><p>Role defaults变量的优先级非常低，几乎可以被其它任何同名变量覆盖。</p></blockquote><p>Role变量都是play级别的变量。换句话说，如果play中执行了Role之后还有tasks指令的任务，则tasks的任务中可以引用Role中的变量。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">roles:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">test_role</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">var:</span> <span class="string">var_from_role</span></span><br></pre></td></tr></table></figure><h1 id="play变量"><a href="#play变量" class="headerlink" title="play变量"></a>play变量</h1><p>play级别可以通过<code>vars</code>、<code>vars_files</code>、<code>vars_prompt</code>指令来定义变量。因为它们属于play级别，所以只在当前play有效。另一方面，每个play都有选中的目标节点，所有选中的目标节点都能访问这些play变量。</p><h2 id="vars"><a href="#vars" class="headerlink" title="vars"></a>vars</h2><p><code>vars</code>比较简单不多说了。</p><h2 id="vars-files"><a href="#vars-files" class="headerlink" title="vars_files"></a>vars_files</h2><p><code>vars_files</code>是一个play级别的指令，可用于在解析playbook的阶段引入一个或多个保存了变量的外部文件。</p><p>例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">play1</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars_files:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">varfile1.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">varfile2.yml</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;var in varfile1: <span class="template-variable">&#123;&#123;var1&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;var in varfile2: <span class="template-variable">&#123;&#123;var2&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>playbook文件通过<code>vars_files</code>引入了两个变量文件，变量文件的写法要求遵守YAML或JSON格式。下面是这两个文件的内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面是varfile1.yml文件的内容</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">var1:</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="attr">var11:</span> <span class="string">&quot;value11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是varfile2.yml文件的内容</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">var2:</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="attr">var22:</span> <span class="string">&quot;value22&quot;</span></span><br></pre></td></tr></table></figure><p>需要说明的是，vars_files指令是play级别的指令，且是在解析playbook的时候加载并解析的，所以所引入变量的变量是play范围内可用的，其它play不可使用这些变量。</p><h2 id="vars-prompt"><a href="#vars-prompt" class="headerlink" title="vars_prompt"></a>vars_prompt</h2><p><code>vars_prompt</code>指令用于交互式提示用户输入数据，并将输入内容赋值给指定的变量。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars_prompt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">username</span></span><br><span class="line">      <span class="attr">prompt:</span> <span class="string">&quot;请输入你的用户名&quot;</span></span><br><span class="line">      <span class="attr">private:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">default:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">passwd</span></span><br><span class="line">      <span class="attr">prompt:</span> <span class="string">&quot;请输入你的登录密码&quot;</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">验证用户输入</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;用户名: <span class="template-variable">&#123;&#123;username&#125;&#125;</span>,密码: <span class="template-variable">&#123;&#123;passwd&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>上面定义了两个变量<code>username</code>和<code>passwd</code>，都会提示用户输入对应的值。<code>private: no</code>表示不要隐藏用户输入的字符(默认会隐藏)，<code>default</code>表示指定变量的默认值。</p><h1 id="task变量"><a href="#task变量" class="headerlink" title="task变量"></a>task变量</h1><p>task变量有多种定义方式：</p><ol><li>register指令</li><li>set_fact指令</li><li>vars指令</li><li>include_vars指令</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="comment"># var.yml变量文件中定义了变量a</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">include_vars:</span> </span><br><span class="line">        <span class="attr">file:</span> <span class="string">var.yml</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> <span class="string">junmajinlong</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">set_fact:</span> <span class="string">name=&quot;&#123;&#123;res.stdout&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;a: <span class="template-variable">&#123;&#123;a&#125;&#125;</span>, name: <span class="template-variable">&#123;&#123;name&#125;&#125;</span>, age: <span class="template-variable">&#123;&#123;age&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">vars:</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">        <span class="attr">gender:</span> <span class="string">male</span></span><br></pre></td></tr></table></figure><p>其中<code>include_vars</code>指令除了指明文件位置，还可从目录中导入多个文件，默认会递归到子目录中。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Include</span> <span class="string">all</span> <span class="string">files</span> <span class="string">in</span> <span class="string">vars/all</span></span><br><span class="line">  <span class="attr">include_vars:</span></span><br><span class="line">    <span class="attr">dir:</span> <span class="string">vars/all</span></span><br></pre></td></tr></table></figure><h1 id="block变量"><a href="#block变量" class="headerlink" title="block变量"></a>block变量</h1><p>ansible中使用block指令来组织了两个有关联性的任务，将它们作为了一个整体。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sync</span> <span class="string">time</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">new</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">and</span> <span class="string">sync</span> <span class="string">time</span></span><br><span class="line">      <span class="attr">block:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">ntpdate</span></span><br><span class="line">          <span class="attr">yum:</span> </span><br><span class="line">            <span class="attr">name:</span> <span class="string">ntpdate</span></span><br><span class="line">            <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ntpdate</span> <span class="string">to</span> <span class="string">sync</span> <span class="string">time</span></span><br><span class="line">          <span class="attr">shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            ntpdate ntp1.aliyun.com</span></span><br><span class="line"><span class="string">            hwclock -w</span></span><br></pre></td></tr></table></figure><p>block作为一个特殊的层次级别，它也支持定义变量，只不过这个block层次的变量只对当前block内的所有任务有效。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">block:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">           <span class="attr">var:</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">vars:</span> </span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;slions&quot;</span></span><br></pre></td></tr></table></figure><h1 id="facts变量"><a href="#facts变量" class="headerlink" title="facts变量"></a>facts变量</h1><p>Facts信息也算是变量，可参考<a href="/2021/12/01/%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%B6%E9%9B%86%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AFfacts/" title="前文">前文</a></p><h1 id="预定义特殊变量"><a href="#预定义特殊变量" class="headerlink" title="预定义特殊变量"></a>预定义特殊变量</h1><p>ansible自身维护了一些可以暴露给用户的预定义变量，官方称为魔法变量，下面是常见预定义变量的含义，完整的预定义特殊变量说明参考<a href="https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html#special-variables">官方手册</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- ansible_forks</span><br><span class="line">表示最大的进程数。这也暗含了多少个节点作为一批。(如果忘记了一批是什么意思，可回介绍playbook的那一章末尾复习)</span><br><span class="line"></span><br><span class="line">- hostvars</span><br><span class="line">保存了inventory中所有主机和主机变量</span><br><span class="line"></span><br><span class="line">- inventory_hostname</span><br><span class="line">当前执行任务的节点在inventory中的主机名</span><br><span class="line"></span><br><span class="line">- inventory_hostname_short</span><br><span class="line">当前执行任务的节点在inventory中的短主机名</span><br><span class="line"></span><br><span class="line">- inventory_dir</span><br><span class="line">inventory文件所在的目录</span><br><span class="line"></span><br><span class="line">- inventory_file</span><br><span class="line">inventory文件名</span><br><span class="line"></span><br><span class="line">- group_names</span><br><span class="line">当前正在执行任务的节点所在主机组列表，注意是一个列表，因为一个节点可能存在于多个主机组</span><br><span class="line"></span><br><span class="line">- groups</span><br><span class="line">inventory中所有的主机组以及各组内的主机列表</span><br><span class="line"></span><br><span class="line">- ansible_play_batch</span><br><span class="line">当前play中可执行任务的主机列表。Ansible动态维护该变量，默认情况下执行任务失败或连接失败的节点会从此变量中移除</span><br><span class="line"></span><br><span class="line">- ansible_play_hosts</span><br><span class="line">等价于ansible_play_batch</span><br><span class="line"></span><br><span class="line">- play_hosts</span><br><span class="line">已废弃，等价于ansible_play_batch</span><br><span class="line"></span><br><span class="line">- playbook_dir</span><br><span class="line">playbook所在目录，该playbook是ansible-playbook命令所执行的playbook，而不是import_playbook导入的playbook</span><br><span class="line"></span><br><span class="line">- ansible_play_name</span><br><span class="line">当前正在执行的play的name。Ansible 2.8才添加的变量</span><br><span class="line"></span><br><span class="line">- ansible_play_hosts_all</span><br><span class="line">当前play所选中的所有节点，等价于ansible_play_batch + 失败的节点</span><br><span class="line"></span><br><span class="line">- ansible_play_role_names</span><br><span class="line">当前play中包含的Role列表。注意，因依赖关系而隐式导入的Role不在列表内</span><br><span class="line"></span><br><span class="line">- role_names</span><br><span class="line">已废弃，等价于ansible_play_role_names</span><br><span class="line"></span><br><span class="line">- ansible_role_names</span><br><span class="line">当前play中包含的Role列表，包括因依赖关系而隐式导入的Role</span><br><span class="line"></span><br><span class="line">- role_name</span><br><span class="line">当前正在执行的Role的名称</span><br><span class="line"></span><br><span class="line">- role_path</span><br><span class="line">当前正在执行的Role的路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;列表、字典变量&quot;&gt;&lt;a href=&quot;#列表、字典变量&quot; class=&quot;headerlink&quot; title=&quot;列表、字典变量&quot;&gt;&lt;/a&gt;列表、字典变量&lt;/h1&gt;&lt;p&gt;列表和字典是ansible中常见的变量类型。&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（七）收集节点信息facts</title>
    <link href="https://slions.github.io/2021/12/01/%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%B6%E9%9B%86%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AFfacts/"/>
    <id>https://slions.github.io/2021/12/01/%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%B6%E9%9B%86%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AFfacts/</id>
    <published>2021-12-01T08:00:50.000Z</published>
    <updated>2021-12-01T08:01:19.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收集节点信息"><a href="#收集节点信息" class="headerlink" title="收集节点信息"></a>收集节点信息</h1><p>ansible可以获取目标主机的节点信息，如ip地址，主机名、系统版本、内核版本等等，对于运维来说是一个很好的功能，但是正是它收集的信息很全面，运行也很慢，在日常工作中，没有特殊的需求会在playbook中将其关闭，或者开启facts缓存，在运行任务前手动执行一次。</p><p>ansible中提供了两个模块（<code>setup</code>与<code>gather_facts</code>）来实现收集主机facts，其中setup是最早的模块，gather_facts是基于setup二次开发的模块（2.8版本以上），gather_facts相比setup多了个并行收集facts的功能（自动识别）。</p><p>在playbook中可以通过<code>gather_facts: BOOL</code>,来控制是否收集节点facts,默认是true，在开始执行定义好的任务前会先执行gather_facts.</p><h1 id="访问节点信息"><a href="#访问节点信息" class="headerlink" title="访问节点信息"></a>访问节点信息</h1><p>收集到目标节点信息之后，各信息都保存在一个名为ansible_facts的变量中，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;ansible_facts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ansible_all_ipv4_addresses&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;192.168.100.10&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ansible_all_ipv6_addresses&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;fe80::8199:4454:db1e:911c&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ansible_apparmor&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;disabled&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ansible_architecture&quot;</span>: <span class="string">&quot;x86_64&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_bios_date&quot;</span>: <span class="string">&quot;07/22/2020&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_bios_version&quot;</span>: <span class="string">&quot;6.00&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_cmdline&quot;</span>: &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ansible_date_time&quot;</span>: &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ansible_default_ipv4&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;192.168.100.10&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;ens33&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;broadcast&quot;</span>: <span class="string">&quot;192.168.100.255&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;gateway&quot;</span>: <span class="string">&quot;192.168.100.2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;interface&quot;</span>: <span class="string">&quot;ens33&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;macaddress&quot;</span>: <span class="string">&quot;00:0c:29:ec:61:46&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mtu&quot;</span>: <span class="number">1500</span>,</span><br><span class="line">        <span class="attr">&quot;netmask&quot;</span>: <span class="string">&quot;255.255.255.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;network&quot;</span>: <span class="string">&quot;192.168.100.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ether&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution&quot;</span>: <span class="string">&quot;CentOS&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_file_parsed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_file_path&quot;</span>: <span class="string">&quot;/etc/redhat-release&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_file_variety&quot;</span>: <span class="string">&quot;RedHat&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_major_version&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_release&quot;</span>: <span class="string">&quot;Core&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_distribution_version&quot;</span>: <span class="string">&quot;7.6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ansible_dns&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;nameservers&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;114.114.114.114&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>有了这些信息，就可以去访问这些信息。比较常用有获取目标主机名，系统版本号、ip地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">var:</span> <span class="string">ansible_hostname</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">var:</span> <span class="string">ansible_distribution_version</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">var:</span> <span class="string">ansible_all_ipv4_addresses</span></span><br></pre></td></tr></table></figure><p>获取到所需的信息可以添加一些判断的逻辑：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">template</span> <span class="string">and</span> <span class="string">copy</span> <span class="string">centos6</span> <span class="string">yum</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">centos6.repo.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/centos6.repo</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_distribution</span> <span class="string">==</span> <span class="string">&quot;CentOS&quot;</span> <span class="string">and</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">template</span> <span class="string">and</span> <span class="string">copy</span> <span class="string">centos7</span> <span class="string">yum</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">centos7.repo.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/centos7.repo</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_distribution</span> <span class="string">==</span> <span class="string">&quot;CentOS&quot;</span> <span class="string">and</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 更精简的写法：</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">template</span> <span class="string">and</span> <span class="string">copy</span> <span class="string">yum</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;&#x27;centos6.repo.j2&#x27; if (ansible_distribution_major_version == 6) else &#x27;centos7.repo.j2&#x27;&#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/centos.repo</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_distribution</span> <span class="string">==</span> <span class="string">&#x27;CentOS&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="local-fact"><a href="#local-fact" class="headerlink" title="local fact"></a>local fact</h1><p>Ansible除了远程收集目标节点的Facts信息，还允许用户在目标节点上自定义该节点的Facts信息，这种方式收集到的Facts称为local Facts。</p><p>要自定义local Facts，需要在目标节点的/etc/ansible/facts.d/目录下创建以<code>.fact</code>为后缀的文件，并在该文件中定义Facts变量信息。该文件要求是json、ini格式或能够输出json、ini数据格式的可执行文件，比如shell脚本。也可以更改默认的local fact目录，在play关键字中指定就好。</p><p>如下示例：</p><p>在第一台目标节点编写local fact如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 facts.d]# ls</span><br><span class="line">myfact.fact</span><br><span class="line">[root@slions_pc1 facts.d]# cat myfact.fact</span><br><span class="line">[model]</span><br><span class="line">pc=del_G3</span><br><span class="line">[root@slions_pc1 facts.d]# pwd</span><br></pre></td></tr></table></figure><p>在第二台目标节点编写local fact如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 facts.d]# ls</span><br><span class="line">myfact.fact</span><br><span class="line">[root@slions_pc2 facts.d]# pwd</span><br><span class="line">/home/ansible_poc/facts.d</span><br><span class="line">[root@slions_pc2 facts.d]# cat myfact.fact</span><br><span class="line">[model]</span><br><span class="line">pc=macbook x1</span><br></pre></td></tr></table></figure><p>playbook如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">fact_path:</span> <span class="string">/home/ansible_poc/facts.d/</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">      <span class="attr">var:</span> <span class="string">ansible_facts.ansible_local.myfact.model.pc</span></span><br><span class="line">      <span class="comment">#也可省略ansible_facts</span></span><br><span class="line">      <span class="comment">#var: ansible_local.myfact.model.pc</span></span><br></pre></td></tr></table></figure><p>运行后可以看到能正常访问到自定义的本地fact。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PLAY [test] **************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] ***************************************************************************************</span><br><span class="line">ok: [192.168.100.11]</span><br><span class="line">ok: [192.168.100.10]</span><br><span class="line"></span><br><span class="line">TASK [debug] *************************************************************************************************</span><br><span class="line">ok: [192.168.100.10] =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts.ansible_local.myfact.model.pc&quot;: &quot;del_G3&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.168.100.11] =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts.ansible_local.myfact.model.pc&quot;: &quot;macbook x1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP ***************************************************************************************************</span><br><span class="line">192.168.100.10             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br><span class="line">192.168.100.11             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure><p>使用Local Facts并不方便，这需要单独去目标节点创建/home/ansible_poc/facts.d/目录，还要将写好的.fact文件拷贝过去，然后在下一个play中使用(如果在当前play中使用，需要先手动调用setup模块收集信息再使用)。</p><p>换句话说，使用Local Facts的一般流程可能是这样的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">play1</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">block:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mkdir</span> <span class="string">/home/ansible_poc/facts.d</span></span><br><span class="line">          <span class="attr">file:</span> </span><br><span class="line">            <span class="attr">name:</span> <span class="string">/home/ansible_poc/facts.d</span></span><br><span class="line">            <span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copy</span> <span class="string">a.fact</span></span><br><span class="line">          <span class="attr">copy:</span> </span><br><span class="line">            <span class="attr">src:</span> <span class="string">myfact.fact</span></span><br><span class="line">            <span class="attr">dest:</span> <span class="string">/home/ansible_poc/facts.d</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">inventory_hostname</span> <span class="string">==</span> <span class="string">&quot;192.168.100.10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">play2</span> <span class="string">use</span> <span class="string">local</span> <span class="string">facts</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">ansible_local.myfact.model.pc</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">inventory_hostname</span> <span class="string">==</span> <span class="string">&quot;192.168.100.10&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然local Facts不太方便，但它支持可执行文件的方式。用户可以直接写一个可执行文件来动态生成Facts信息而不是预先以静态的方式写好的Facts变量。</p><p>例如，想要收集mysql galera集群中节点的状态，编写如下可执行Facts文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &#x27;[cluster_status]&#x27;</span><br><span class="line">mysql -e &quot;SHOW GLOBAL STATUS LIKE &#x27;wsrep_cluster_status&#x27;\G&quot; | awk &#x27;/Value/&#123;print &quot;status=&quot;$2&#125;&#x27;</span><br></pre></td></tr></table></figure><p>之后便可以在playbook中使用<code>ansible_local.FACT_FILENAME.cluster_status.status</code>来访问对应节点的状态。</p><h1 id="set-fact模块"><a href="#set-fact模块" class="headerlink" title="set_fact模块"></a>set_fact模块</h1><blockquote><p>Facts的各种信息实际上是以变量方式保存的。</p></blockquote><p>我们还可以在任务中通过<code>set_fact</code>模块直接定义Facts，其效果就是定义了一个变量，和<code>register</code>指令的功能类似，只不过<code>register</code>指令是将模块的执行返回值赋值给变量名，而<code>set_fact</code>是手动指定变量的值。</p><p>示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">define</span> <span class="string">some</span> <span class="string">var</span></span><br><span class="line">      <span class="attr">set_fact:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">slions</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">29</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">var</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;name: <span class="template-variable">&#123;&#123;name&#125;&#125;</span>, age: <span class="template-variable">&#123;&#123;age&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>set_fact经常用于临时设置变量，也非常方便，比如可以在将shell执行结果通过register注册变量之后，立即使用set_fact将命令的标准输出定义成变量。如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        echo 183@163.com</span></span><br><span class="line"><span class="string"></span>      <span class="attr">register:</span> <span class="string">echo_res</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">set_fact:</span> <span class="string">echo_var=&#123;&#123;echo_res.stdout&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">var</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">echo_var</span></span><br></pre></td></tr></table></figure><h1 id="facts缓存"><a href="#facts缓存" class="headerlink" title="facts缓存"></a>facts缓存</h1><p>收集fact是耗时的，ansible支持fact缓存，通过设置Ansible配置文件，然后就可以在任何时间点通过一个独立的收集任务去收集，并将收集的Facts缓存下来，以后使用Facts变量时就不用再显式地低效收集。</p><p>配置Ansible开启Facts缓存的方式非常简单，修改Ansible配置文件(默认是<code>/etc/ansible/ansible.cfg</code>或其它位置)。目前Ansible支持以下几种缓存模式：</p><ul><li>redis：缓存在redis服务中，直到目前(Ansible 2.9)为止，Ansible还不支持指定连接redis的端口、密码等</li><li>memcached：缓存在memcache文件中</li><li>mongodb：缓存在mongodb文件中</li><li>jsonfile：缓存在本地的json文件中</li><li>yaml：缓存在本地的yaml文件中</li><li>pickle：缓存在本地的pickle序列化文件中</li></ul><p>配置方式，可参考如下配置项：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jsonfile缓存模式</span></span><br><span class="line"><span class="attr">gathering</span> = smart或explicit或implicit</span><br><span class="line"><span class="attr">fact_caching</span> = jsonfile</span><br><span class="line"><span class="attr">fact_caching_connection</span> = DIRNAME</span><br><span class="line"><span class="attr">fact_caching_timeout</span>=TIMEOUT</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis缓存模式</span></span><br><span class="line"><span class="attr">gathering</span> = smart或explicit或implicit</span><br><span class="line"><span class="attr">fact_caching</span> = redis</span><br><span class="line"><span class="attr">fact_caching_timeout</span>=TIMEOUT</span><br><span class="line"><span class="attr">fact_caching_connection</span> = localhost:<span class="number">6379</span>:<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mongodb缓存模式</span></span><br><span class="line"><span class="attr">fact_caching</span> = mongodb</span><br><span class="line"><span class="attr">fact_caching_timeout</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">fact_caching_connection</span> = mongodb://localhost:<span class="number">32770</span>/ansible_cache</span><br></pre></td></tr></table></figure><p>配置项解析：</p><p>gathering：控制Ansible是否自动收集Facts，它有三种值：</p><ul><li>implicit：这是默认值，表示执行play时会自动收集Facts，除非显式指定gather_facts: false禁止收集</li><li>explicit：不自动收集Facts，除非显式指定gather_facts: true开启收集</li><li>smart：自动收集Facts，但如果已存在(缓存)则不重复收集</li></ul><p>fact_caching_connection：指定本地目录用于存放Facts的缓存文件，如果目录不存在则Ansible会尝试创建<br>fact_caching_timeout：缓存的有效时长</p><p>当前工作中我们使用的jsonfile配置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gathering</span> = smart</span><br><span class="line"><span class="attr">fact_caching</span> = jsonfile</span><br><span class="line"><span class="attr">fact_caching_connection</span> = facts</span><br></pre></td></tr></table></figure><p>当第一次执行playbook后，会将收集到的内容缓存到当前目录下的facts目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# ll facts</span><br><span class="line">总用量 48</span><br><span class="line">-rw-r--r--. 1 root root 22845 12月  1 15:06 192.168.100.10</span><br><span class="line">-rw-r--r--. 1 root root 23039 12月  1 15:06 192.168.100.11</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后便可以直接去引用这些缓存下来的Facts信息，甚至访问不在该play中的节点的Facts信息。例如，playbook内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">var</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">hostvars[&#x27;192.168.100.11&#x27;].ansible_hostname</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;收集节点信息&quot;&gt;&lt;a href=&quot;#收集节点信息&quot; class=&quot;headerlink&quot; title=&quot;收集节点信息&quot;&gt;&lt;/a&gt;收集节点信息&lt;/h1&gt;&lt;p&gt;ansible可以获取目标主机的节点信息，如ip地址，主机名、系统版本、内核版本等等，对于运维来说是一个很好</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>（六）限制执行任务主机</title>
    <link href="https://slions.github.io/2021/11/29/%EF%BC%88%E5%85%AD%EF%BC%89%E9%99%90%E5%88%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E4%B8%BB%E6%9C%BA/"/>
    <id>https://slions.github.io/2021/11/29/%EF%BC%88%E5%85%AD%EF%BC%89%E9%99%90%E5%88%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E4%B8%BB%E6%9C%BA/</id>
    <published>2021-11-29T08:11:32.000Z</published>
    <updated>2021-11-29T08:23:06.972Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，所有被ansible或ansible-playbook选中的主机都会执行任务，有时在开发和测试阶段只想选择其中某些节点来执行，需要改动inventory文件或playbook的host不是很优雅，ansible 提供了<code>--limit</code>选项来筛选目标主机。</p><blockquote><p>使用 –limit选项，ansible或ansible-playbook也会解析inventory中定义的所有主机，在执行任务时才会选择定义后的目标主机。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# cat two.yml</span><br><span class="line">- hosts: test</span><br><span class="line">  gather_facts: false</span><br><span class="line">  tasks:</span><br><span class="line">  - debug:</span><br><span class="line">      msg: &quot;echo &#123;&#123; var1 &#125;&#125;&quot;</span><br><span class="line">[root@slions_pc1 ansible_poc]# ansible-playbook one.yml</span><br><span class="line"></span><br><span class="line">PLAY [test] *****************************************************************************************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [first : 我的测试play] *****************************************************************************************************************************************************************</span><br><span class="line">ok: [192.168.100.10] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;echo myvar&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [192.168.100.11] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;echo myvar&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP ******************************************************************************************************************************************************************************</span><br><span class="line">192.168.100.10             : ok=1    changed=0    unreachable=0    failed=0</span><br><span class="line">192.168.100.11             : ok=1    changed=0    unreachable=0    failed=0</span><br><span class="line"></span><br><span class="line">[root@slions_pc1 ansible_poc]# ansible-playbook one.yml --limit 192.168.100.11</span><br><span class="line"></span><br><span class="line">PLAY [test] *****************************************************************************************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [first : 我的测试play] *****************************************************************************************************************************************************************</span><br><span class="line">ok: [192.168.100.11] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;echo myvar&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLAY RECAP ******************************************************************************************************************************************************************************</span><br><span class="line">192.168.100.11             : ok=1    changed=0    unreachable=0    failed=0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;默认情况下，所有被ansible或ansible-playbook选中的主机都会执行任务，有时在开发和测试阶段只想选择其中某些节点来执行，需要改动inventory文件或playbook的host不是很优雅，ansible 提供了&lt;code&gt;--limit&lt;/code&gt;选项</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>harbor对接F5的鉴权失败问题</title>
    <link href="https://slions.github.io/2021/11/23/harbor%E5%AF%B9%E6%8E%A5F5%E7%9A%84%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://slions.github.io/2021/11/23/harbor%E5%AF%B9%E6%8E%A5F5%E7%9A%84%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-23T02:13:53.000Z</published>
    <updated>2021-11-23T03:32:41.203Z</updated>
    
    <content type="html"><![CDATA[<p>之前harbor的高可用方案都是通过我们自建VIP与检测机制来做的，此次上线的双活架构下，VIP无法跨网段进行通信，甲方提供F5作为统一入口，由此进行了F5对接harbor的功能性测试。</p><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>使用docker login harbor时，有时成功，有时失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker login -u user -p passwd http://xxx.xxx.xxx.xxx:9980</span></span><br><span class="line">Error response from daemon: login attempt to http://xxx.xxx.xxx.xxx:9980/v2/ failed with status: 401 Unauthorized</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker login -u user -p passwd http://xxx.xxx.xxx.xxx:9980</span></span><br><span class="line">Error response from daemon: login attempt to http://xxx.xxx.xxx.xxx:9980/v2/ failed with status: 401 Unauthorized</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker login -u user -p passwd http://xxx.xxx.xxx.xxx:9980</span></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><p>修改docker配置文件中镜像仓库地址为单独的harbor节点再次测试，没有任何问题。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>接着将docker镜像仓库地址换回F5地址，打开两个终端分别监视两个Harbor节点上的registry的日志。</p><p>经过几次测试，发现一个现象：当docker login成功时，都是一个节点上的日志出现更新；而当docker login fail时，会看到两个节点上的registry日志都有变化，这就有些出乎意料了。</p><p><img src="https://slions.gitee.io/picbed/img/hf1.png"></p><p>查阅harbor官方对docker login的<a href="https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor#the-process-of-docker-login">流程解析</a></p><p><img src="https://slions.gitee.io/picbed/img/hf2.png"></p><ul><li>docker向registry发起请求，由于registry是基于token auth的，因此registry回复应答，告诉docker client去哪个URL去获取token；</li><li>docker client根据应答中的URL向token service(ui)发起请求，通过user和passwd获取token；如果user和passwd在db中通过了验证，那么token service将用自己的私钥<code>(harbor/common/config/ui/private_key.pem)</code>生成一个token，返回给docker client端；</li><li>docker client获得token后再向registry发起login请求，registry用自己的证书<code>(harbor/common/config/registry/root.crt)</code>对token进行校验。通过则返回成功，否则返回失败。</li></ul><p>从这个原理，可以知道问题就出在docker client多次向Harbor发起请求这个环节：对于每次请求，F5会将域名可能解析为不同IP，因此不同请求可能落到不同的镜像仓库节点上。这样当docker client拿着节点1上token service分配的token去到节点2的registry上鉴权时，就会出现鉴权失败的情况。</p><h1 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h1><p>token service的私钥<code>(harbor/common/config/ui/private_key.pem)</code>和registry的证书<code>(harbor/common/config/registry/root.crt)</code>都是在prepare时生成的，两个节点都独立prepare过，因此两个node上的private_key.pem和root.crt是不同的。所以造成了鉴权失败的问题。统一两个节点的私钥和证书可以解决。</p><p>将节点1上的private_key.pem和root.crt复制到节点2上，并重新创建node2上的harbor container。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前harbor的高可用方案都是通过我们自建VIP与检测机制来做的，此次上线的双活架构下，VIP无法跨网段进行通信，甲方提供F5作为统一入口，由此进行了F5对接harbor的功能性测试。&lt;/p&gt;
&lt;h1 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;he</summary>
      
    
    
    
    <category term="镜像仓库" scheme="https://slions.github.io/categories/%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    
    
    <category term="harbor" scheme="https://slions.github.io/tags/harbor/"/>
    
  </entry>
  
  <entry>
    <title>保留特殊字符</title>
    <link href="https://slions.github.io/2021/11/17/%E4%BF%9D%E7%95%99%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
    <id>https://slions.github.io/2021/11/17/%E4%BF%9D%E7%95%99%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</id>
    <published>2021-11-17T10:24:36.000Z</published>
    <updated>2021-12-01T12:26:51.840Z</updated>
    
    <content type="html"><![CDATA[<p>由于Ansible采用Jinja2模板引擎渲染字符串，在需要渲染的时候，如果发现字符串中包含了Jinja2的特殊字符，就会认为这是一个需要渲染的内容。</p><p>如下示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;测试特殊字符&quot;</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">pvar</span></span><br><span class="line">      <span class="attr">vars:</span></span><br><span class="line">        <span class="attr">pvar:</span> <span class="type">!myvar</span></span><br></pre></td></tr></table></figure><p>运行时会报语法错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ansible_poc]# ansible-playbook test.yml</span><br><span class="line">ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:</span><br><span class="line">JSON: No JSON object could be decoded</span><br><span class="line"></span><br><span class="line">Syntax Error while loading YAML.</span><br><span class="line">  could not determine a constructor for the tag &#x27;!myvar&#x27;</span><br><span class="line"></span><br><span class="line">The error appears to be in &#x27;/home/ansible_poc/six.yml&#x27;: line 9, column 15, but may</span><br><span class="line">be elsewhere in the file depending on the exact syntax problem.</span><br><span class="line"></span><br><span class="line">The offending line appears to be:</span><br><span class="line"></span><br><span class="line">      vars:</span><br><span class="line">        pvar: !myvar</span><br><span class="line">              ^ here</span><br></pre></td></tr></table></figure><p>想要在定义变量时、指定name属性值时或其它会渲染的地方使用这些Jinja2的特殊符号，需要加上<code>!unsafe</code>标记。这个标记会禁止渲染，保留原始的特殊符号。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vars:</span></span><br><span class="line">  <span class="attr">pvar:</span> <span class="type">!unsafe</span> <span class="string">&quot;!myvar&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于Ansible采用Jinja2模板引擎渲染字符串，在需要渲染的时候，如果发现字符串中包含了Jinja2的特殊字符，就会认为这是一个需要渲染的内容。&lt;/p&gt;
&lt;p&gt;如下示例：&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="ansible回炉" scheme="https://slions.github.io/categories/ansible%E5%9B%9E%E7%82%89/"/>
    
    
    <category term="ansible" scheme="https://slions.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>普通用户安装mysql</title>
    <link href="https://slions.github.io/2021/10/31/%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85mysql/"/>
    <id>https://slions.github.io/2021/10/31/%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85mysql/</id>
    <published>2021-10-31T05:53:58.000Z</published>
    <updated>2021-10-31T08:11:55.545Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql是最为常用的关系型数据库，关于安装网上大多都是通过root用户直接来安装的，真实场景中，多数情况是不会给root用户的，要不是直接向甲方申请mysql，要不是给普通用户自己安装。</p><p>下面演示如何通过普通用户完成mysql服务的搭建。</p><h1 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h1><table><thead><tr><th><strong>主机名</strong></th><th>ip地址</th><th><strong>系统版本</strong></th><th><strong>系统资源</strong></th></tr></thead><tbody><tr><td>slions_pc2</td><td>192.168.100.11</td><td>CentOS Linux release 7.6.1810</td><td>cpu:2  mem:4GB</td></tr></tbody></table><h1 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h1><p>后续通过slions用户来完成mysql环境搭建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]groupadd -g 7295 slions &amp;&amp; useradd -u 7295 -g 7295 -s /bin/bash slions &amp;&amp; echo &quot;slions:slions&quot; | chpasswd</span><br><span class="line">[root@slions_pc2 ~]# id slions</span><br><span class="line">uid=7295(slions) gid=7295(slions) 组=7295(slions)</span><br></pre></td></tr></table></figure><h1 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h1><p>访问<a href="https://dev.mysql.com/downloads/mysql/">mysql官网</a>，当前最新的版本为8.0.27，想要下载历史版本需点击标注处。</p><p><img src="https://slions.gitee.io/picbed/img/mysql1.png"></p><p>此次我们安装Mysql 5.7.36</p><p><img src="https://slions.gitee.io/picbed/img/mysql2.png"></p><p>选择tar.gz离线包</p><p><img src="https://slions.gitee.io/picbed/img/mysql3.png"></p><p>不登录，直接下载到本地</p><p><img src="https://slions.gitee.io/picbed/img/mysql4.png"></p><h1 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h1><p>使用slions用户登录服务器，将下载好的mysql离线包拷贝到服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ ls</span><br><span class="line">mysql-5.7.36-el7-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ tar -zxvf mysql-5.7.36-el7-x86_64.tar.gz</span><br><span class="line">[slions@slions_pc2 ~]$ mv mysql-5.7.36-el7-x86_64 mysql</span><br></pre></td></tr></table></figure><p>创建数据、日志与socket目录以及配置文件目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ mkdir -p data/mysql/&#123;data,logs,tmp&#125; &amp;&amp; mkdir conf</span><br><span class="line">[slions@slions_pc2 ~]$ ls -l</span><br><span class="line">总用量 715496</span><br><span class="line">drwxrwxr-x. 2 slions slions        6 10月 31 13:50 conf</span><br><span class="line">drwxrwxr-x. 3 slions slions        6 10月 31 11:08 data</span><br><span class="line">drwxrwxr-x. 9 slions slions       129 10月 31 11:05 mysql</span><br><span class="line">-rw-rw-r--. 1 slions slions 732667171 10月 31 11:02 mysql-5.7.36-el7-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>编写mysql配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ cat &gt;&gt; conf/my.cnf &lt;&lt; EOF</span><br><span class="line">[client]</span><br><span class="line">port = 33060</span><br><span class="line">socket = /home/slions/data/mysql/tmp/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line">user = slions</span><br><span class="line">basedir = /home/slions/mysql</span><br><span class="line">datadir = /home/slions/data/mysql/data</span><br><span class="line">port = 33060</span><br><span class="line">socket = /home/slions/data/mysql/tmp/mysql.sock</span><br><span class="line">pid-file = /home/slions/data/mysql/tmp/mysqld.pid</span><br><span class="line">tmpdir = /home/slions/data/mysql/tmp</span><br><span class="line">skip_name_resolve = 1</span><br><span class="line">symbolic-links=0</span><br><span class="line">max_connections = 2000</span><br><span class="line">group_concat_max_len = 1024000</span><br><span class="line">sql_mode = NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">log_timestamps=SYSTEM</span><br><span class="line">character-set-server = utf8</span><br><span class="line">interactive_timeout = 1800</span><br><span class="line">wait_timeout = 1800</span><br><span class="line">max_allowed_packet = 32M</span><br><span class="line">binlog_cache_size = 4M</span><br><span class="line">sort_buffer_size = 2M</span><br><span class="line">read_buffer_size = 4M</span><br><span class="line">join_buffer_size = 4M</span><br><span class="line">tmp_table_size = 96M</span><br><span class="line">max_heap_table_size = 96M</span><br><span class="line">max_length_for_sort_data = 8096</span><br><span class="line"><span class="meta">#</span><span class="bash">logs</span></span><br><span class="line">server-id = 1003306</span><br><span class="line">log-error = /home/slions/data/mysql/logs/error.log</span><br><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = /home/slions/data/mysql/logs/slow.log</span><br><span class="line">long_query_time = 3</span><br><span class="line">log-bin = /home/slions/data/mysql/logs/binlog</span><br><span class="line">binlog_format = row</span><br><span class="line">expire_logs_days = 15</span><br><span class="line">log_bin_trust_function_creators = 1</span><br><span class="line">relay-log = /home/slions/data/mysql/logs/relay-bin</span><br><span class="line">relay-log-recovery = 1</span><br><span class="line">relay_log_purge = 1</span><br><span class="line"><span class="meta">#</span><span class="bash">innodb</span></span><br><span class="line">innodb_file_per_table = 1</span><br><span class="line">innodb_log_buffer_size = 16M</span><br><span class="line">innodb_log_file_size = 256M</span><br><span class="line">innodb_log_files_in_group = 2</span><br><span class="line">innodb_io_capacity = 2000</span><br><span class="line">innodb_io_capacity_max = 4000</span><br><span class="line">innodb_flush_neighbors = 0</span><br><span class="line">innodb_flush_method = O_DIRECT</span><br><span class="line">innodb_autoinc_lock_mode = 2</span><br><span class="line">innodb_read_io_threads = 8</span><br><span class="line">innodb_write_io_threads = 8</span><br><span class="line">innodb_buffer_pool_size = 2G</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>初始化数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ ./mysql/bin/mysqld --defaults-file=/home/slions/conf/my.cnf --initialize --user=slions --basedir=/home/slions/mysql --datadir=/home/slions/data/mysql/data</span><br></pre></td></tr></table></figure><p>获取root密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ cat data/mysql/logs/error.log |grep password</span><br></pre></td></tr></table></figure><p>启动mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ ./mysql/bin/mysqld_safe --defaults-file=/home/slions/conf/my.cnf --user=slions &amp;</span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ echo &quot;PATH=$PATH:/home/slions/mysql/bin&quot; &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure><h1 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ mysql -uroot -P33060 -p -S /home/slions/data/mysql/tmp/mysql.sock</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改默认的root密码及远程登录权限</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;admin123&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;admin123&#x27;</span> WITH GRANT OPTION;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure><p>此时已经可以通过其他客户端访问该服务了。</p><h1 id="设置命令别名"><a href="#设置命令别名" class="headerlink" title="设置命令别名"></a>设置命令别名</h1><p>因为我们改了默认的mysql.sock路径，导致每次客户端连接时都要指明mysql.sock,不然会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ mysql</span><br><span class="line">ERROR 2002 (HY000): Can&#x27;t connect to local MySQL server through socket &#x27;/tmp/mysql.sock&#x27; (2)</span><br></pre></td></tr></table></figure><p>可以配置个命令别名，之后就可以正常使用了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[slions@slions_pc2 ~]$ alias mysql=&#x27;mysql -S /home/slions/data/mysql/tmp/mysql.sock&#x27;</span><br><span class="line">[slions@slions_pc2 ~]$ mysql</span><br><span class="line">ERROR 1045 (28000): Access denied for user &#x27;slions&#x27;@&#x27;localhost&#x27; (using password: NO)</span><br></pre></td></tr></table></figure><h1 id="配置开机自启"><a href="#配置开机自启" class="headerlink" title="配置开机自启"></a>配置开机自启</h1><p>配置开机自启需要root权限。</p><h2 id="systemd-service方式"><a href="#systemd-service方式" class="headerlink" title="systemd service方式"></a>systemd service方式</h2><p>编写mysql服务启动文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# cat &gt;&gt; /usr/lib/systemd/system/slions-mysql.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Slions Mysql Server</span><br><span class="line">After=network.service</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">User=slions</span><br><span class="line">Group=slions</span><br><span class="line">Type=forking</span><br><span class="line">TimeoutSec=0</span><br><span class="line">ExecStart=/home/slions/mysql/bin/mysqld --defaults-file=/home/slions/conf/my.cnf --basedir=/home/slions/mysql --datadir=/home/slions/data/mysql/data --daemonize</span><br><span class="line">ExecStop=/bin/kill $MAINPID</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=10</span><br><span class="line">RestartPreventExitStatus=1</span><br><span class="line">PrivateTmp=false</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动服务并设置开机自启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc2 ~]# pkill -9 mysql</span><br><span class="line">[root@slions_pc2 ~]# systemctl enable slions-mysql.service</span><br><span class="line">[root@slions_pc2 ~]# systemctl start slions-mysql.service</span><br><span class="line">[root@slions_pc2 ~]# ps -elf|grep mysql</span><br><span class="line">5 S slions    11905      1  0  80   0 - 835134 poll_s 12:31 ?       00:00:08 /home/slions/mysql/bin/mysqld --defaults-file=/home/slions/conf/my.cnf --basedir=/home/slions/mysql --datadir=/home/slions/data/mysql/data --socket=/home/slions/data/mysql/tmp/mysql.sock --pid-file=/home/slions/data/mysql/tmp/mysqld.pid --daemonize</span><br><span class="line">4 S root      12398   9776  0  80   0 - 28182 pipe_w 14:56 pts/0    00:00:00 grep --color=auto mysql</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mysql是最为常用的关系型数据库，关于安装网上大多都是通过root用户直接来安装的，真实场景中，多数情况是不会给root用户的，要不是直接向甲方申请mysql，要不是给普通用户自己安装。&lt;/p&gt;
&lt;p&gt;下面演示如何通过普通用户完成mysql服务的搭建。&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="Mysql" scheme="https://slions.github.io/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://slions.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>k8s-controller-manager原理</title>
    <link href="https://slions.github.io/2021/10/03/k8s-controller-manager%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/10/03/k8s-controller-manager%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-03T14:39:16.000Z</published>
    <updated>2021-10-07T03:04:35.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="controller-manager作用"><a href="#controller-manager作用" class="headerlink" title="controller-manager作用"></a>controller-manager作用</h1><p>Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理。</p><p><img src="https://slions.gitee.io/picbed/img/con1.png"></p><p>逻辑上，每个控制器是一个单独的协程。用于监视 apiserver 暴露的集群状态，并且不断地尝试把当前状态向集群的目标状态迁移。为了避免频繁查询 apiserver，apiserver 提供了 watch 接口用于监视资源的增加删除和更新，client-go 对此作了抽象，封装一层 informer 来表示本地 apiserver 状态的 cache 。</p><h1 id="工作流程与运行机制"><a href="#工作流程与运行机制" class="headerlink" title="工作流程与运行机制"></a>工作流程与运行机制</h1><p>参考：</p><p><a href="http://dockone.io/article/9557">Kubernetes Controller Manager 工作原理</a></p><p><a href="https://blog.csdn.net/huwh_/article/details/75675761">控制器浅析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;controller-manager作用&quot;&gt;&lt;a href=&quot;#controller-manager作用&quot; class=&quot;headerlink&quot; title=&quot;controller-manager作用&quot;&gt;&lt;/a&gt;controller-manager作用&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>kube-proxy原理</title>
    <link href="https://slions.github.io/2021/10/03/kube-proxy%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/10/03/kube-proxy%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-03T03:40:00.000Z</published>
    <updated>2021-10-03T10:51:20.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kube-proxy的作用"><a href="#kube-proxy的作用" class="headerlink" title="kube-proxy的作用"></a>kube-proxy的作用</h1><p>kube-proxy是Kubernetes的核心组件，部署在每个Node节点上，它是实现Kubernetes Service的通信与负载均衡机制的重要组件; kube-proxy负责为Pod创建代理服务，从apiserver获取所有server信息，并根据server信息创建代理服务，实现server到Pod的请求路由和转发，从而实现K8s层级的虚拟转发网络。</p><blockquote><p>在k8s中，提供相同服务的一组pod可以抽象成一个service，通过service提供的统一入口对外提供服务，每个service都有一个虚拟IP地址（VIP）和端口号供客户端访问。kube-proxy存在于各个node节点上，主要用于Service功能的实现，具体来说，就是实现集群内的客户端pod访问service，或者是集群外的主机通过NodePort等方式访问service。在当前版本的k8s中，kube-proxy默认使用的是iptables模式，通过各个node节点上的iptables规则来实现service的负载均衡，但是随着service数量的增大，iptables模式由于线性查找匹配、全量更新等特点，其性能会显著下降。从k8s的1.8版本开始，kube-proxy引入了IPVS模式，IPVS模式与iptables同样基于Netfilter，但是采用的hash表，因此当service数量达到一定规模时，hash查表的速度优势就会显现出来，从而提高service的服务性能。</p></blockquote><p>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡，它运行在每个Node计算节点上，负责Pod网络代理, 它会定时从etcd服务获取到service信息来做相应的策略，维护网络规则和四层负载均衡工作。在K8s集群中微服务的负载均衡是由Kube-proxy实现的，它是K8s集群内部的负载均衡器，也是一个分布式代理服务器，在K8s的每个节点上都有一个，这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>service是一组pod的服务抽象，相当于一组pod的LB，负责将请求分发给对应的pod。service会为这个LB提供一个IP，一般称为cluster IP。kube-proxy的作用主要是负责service的实现，具体来说，就是实现了内部从pod到service和外部的从node port向service的访问。</li><li>kube-proxy其实就是管理service的访问入口，包括集群内Pod到Service的访问和集群外访问service。</li><li>kube-proxy管理sevice的Endpoints，该service对外暴露一个Virtual IP，也成为Cluster IP, 集群内通过访问这个Cluster IP:Port就能访问到集群内对应的serivce下的Pod。</li><li>service是通过Selector选择的一组Pods的服务抽象，其实就是一个微服务，提供了服务的LB和反向代理的能力，而kube-proxy的主要作用就是负责service的实现。</li><li>service另外一个重要作用是，一个服务后端的Pods可能会随着生存灭亡而发生IP的改变，service的出现，给服务提供了一个固定的IP，而无视后端Endpoint的变化。</li></ul><p>举个例子，比如现在有podA，podB，podC和serviceAB。serviceAB是podA，podB的服务抽象(service)。那么kube-proxy的作用就是可以将pod(不管是podA，podB或者podC)向serviceAB的请求，进行转发到service所代表的一个具体pod(podA或者podB)上。请求的分配方法一般分配是采用轮询方法进行分配。另外，kubernetes还提供了一种在node节点上暴露一个端口，从而提供从外部访问service的方式。比如这里使用这样的一个yml来创建service。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">service</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30964</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">mysql-service:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Service-Endpoints与Pod的关系"><a href="#Service-Endpoints与Pod的关系" class="headerlink" title="Service, Endpoints与Pod的关系"></a>Service, Endpoints与Pod的关系</h2><p><img src="https://slions.gitee.io/picbed/img/proxy1.png"></p><p>Kube-proxy进程获取每个Service的Endpoints,实现Service的负载均衡功能</p><h2 id="Service的负载均衡转发规则"><a href="#Service的负载均衡转发规则" class="headerlink" title="Service的负载均衡转发规则"></a>Service的负载均衡转发规则</h2><p><img src="https://slions.gitee.io/picbed/img/proxy2.png"></p><p>访问Service的请求，不论是Cluster IP+TargetPort的方式；还是用Node节点IP+NodePort的方式，都被Node节点的Iptables规则重定向到Kube-proxy监听Service服务代理端口。kube-proxy接收到Service的访问请求后，根据负载策略，转发到后端的Pod。</p><h1 id="kubernetes服务发现"><a href="#kubernetes服务发现" class="headerlink" title="kubernetes服务发现"></a>kubernetes服务发现</h1><p>Kubernetes提供了两种方式进行服务发现, 即<strong>环境变量</strong>和<strong>DNS</strong>, 简单说明如下:</p><ol><li>环境变量： 当创建一个Pod的时候，kubelet会在该Pod中注入集群内所有Service的相关环境变量。<strong>需要注意:</strong> 要想一个Pod中注入某个Service的环境变量，则必须Service要先比该Pod创建。这一点，几乎使得这种方式进行服务发现不可用。比如，一个ServiceName为redis-master的Service，对应的ClusterIP:Port为172.16.50.11:6379，则其对应的环境变量为:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REDIS_MASTER_SERVICE_HOST=172.16.50.11</span><br><span class="line">REDIS_MASTER_SERVICE_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT=tcp://172.16.50.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP=tcp://172.16.50.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PROTO=tcp</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_ADDR=172.16.50.11</span><br></pre></td></tr></table></figure><ol start="2"><li>DNS：这是k8s官方强烈推荐的方式!!! 可以通过cluster add-on方式轻松的创建KubeDNS来对集群内的Service进行服务发现。</li></ol><h1 id="kubernetes发布-暴露-服务"><a href="#kubernetes发布-暴露-服务" class="headerlink" title="kubernetes发布(暴露)服务"></a>kubernetes发布(暴露)服务</h1><p>kubernetes原生的，一个Service的ServiceType决定了其发布服务的方式。</p><ul><li>ClusterIP：这是k8s默认的ServiceType。通过集群内的ClusterIP在内部发布服务。</li><li>NodePort：这种方式是常用的，用来对集群外暴露Service，你可以通过访问集群内的每个NodeIP:NodePort的方式，访问到对应Service后端的Endpoint。</li><li>LoadBalancer: 这也是用来对集群外暴露服务的，不同的是这需要Cloud Provider的支持，比如AWS等。</li><li>ExternalName：这个也是在集群内发布服务用的，需要借助KubeDNS(version &gt;= 1.7)的支持，就是用KubeDNS将该service和ExternalName做一个Map，KubeDNS返回一个CNAME记录。</li></ul><h1 id="kube-proxy-工作原理"><a href="#kube-proxy-工作原理" class="headerlink" title="kube-proxy 工作原理"></a>kube-proxy 工作原理</h1><p>kube-proxy当前实现了三种代理模式：<strong>userspace,</strong> <strong>iptables, ipvs</strong>。其中userspace mode是v1.0及之前版本的默认模式，从v1.1版本中开始增加了iptables mode，在v1.2版本中正式替代userspace模式成为默认模式。也就是说kubernetes在v1.2版本之前是默认模式, v1.2版本之后默认模式是iptables。</p><h2 id="userspace-mode"><a href="#userspace-mode" class="headerlink" title="userspace mode"></a>userspace mode</h2><p>userspace是在用户空间，通过kube-proxy来实现service的代理服务, 其原理如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy3.png"></p><p>可见，userspace这种mode最大的问题是，service的请求会先从用户空间进入内核iptables，然后再回到用户空间，由kube-proxy完成后端Endpoints的选择和代理工作，这样流量从用户空间进出内核带来的性能损耗是不可接受的。这也是k8s v1.0及之前版本中对kube-proxy质疑最大的一点，因此社区就开始研究iptables mode.</p><p>userspace这种模式下，kube-proxy 持续监听 Service 以及 Endpoints 对象的变化；对每个 Service，它都为其在本地节点开放一个端口，作为其服务代理端口；发往该端口的请求会采用一定的策略转发给与该服务对应的后端 Pod 实体。kube-proxy 同时会在本地节点设置 iptables 规则，配置一个 Virtual IP，把发往 Virtual IP 的请求重定向到与该 Virtual IP 对应的服务代理端口上。其工作流程大体如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy4.png"></p><p><strong>由此分析:</strong> 该模式请求在到达 iptables 进行处理时就会进入内核，而 kube-proxy 监听则是在用户态, 请求就形成了从用户态到内核态再返回到用户态的传递过程, 一定程度降低了服务性能。</p><h2 id="iptables-mode"><a href="#iptables-mode" class="headerlink" title="iptables mode"></a>iptables mode</h2><p>该模式完全利用内核iptables来实现service的代理和LB, 这是K8s在v1.2及之后版本默认模式. 工作原理如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy5.png"></p><p>iptables mode因为使用iptable NAT来完成转发，也存在不可忽视的性能损耗。另外，如果集群中存在上万的Service/Endpoint，那么Node上的iptables rules将会非常庞大，性能还会再打折扣。</p><p>iptables 模式与 userspace 相同，kube-proxy 持续监听 Service 以及 Endpoints 对象的变化；但它并不在本地节点开启反向代理服务，而是把反向代理全部交给 iptables 来实现；即 iptables 直接将对 VIP 的请求转发给后端 Pod，通过 iptables 设置转发策略。其工作流程大体如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy6.png"></p><p><strong>由此分析:</strong> 该模式相比 userspace 模式，克服了请求在用户态-内核态反复传递的问题，性能上有所提升，但使用 iptables NAT 来完成转发，存在不可忽视的性能损耗，而且在大规模场景下，iptables 规则的条目会十分巨大，性能上还要再打折扣。</p><h2 id="ipvs-mode"><a href="#ipvs-mode" class="headerlink" title="ipvs mode"></a>ipvs mode</h2><p>在kubernetes 1.8以上的版本中，对于kube-proxy组件增加了除iptables模式和用户模式之外还支持ipvs模式。kube-proxy ipvs 是基于 NAT 实现的，通过ipvs的NAT模式，对访问k8s service的请求进行虚IP到POD IP的转发。当创建一个 service 后，kubernetes 会在每个节点上创建一个网卡，同时帮你将 Service IP(VIP) 绑定上，此时相当于每个 Node 都是一个 ds，而其他任何 Node 上的 Pod，甚至是宿主机服务(比如 kube-apiserver 的 6443)都可能成为 rs。</p><p><img src="https://slions.gitee.io/picbed/img/proxy7.png"></p><p>与iptables、userspace 模式一样，kube-proxy 依然监听Service以及Endpoints对象的变化, 不过它并不创建反向代理, 也不创建大量的 iptables 规则, 而是通过netlink 创建ipvs规则，并使用k8s Service与Endpoints信息，对所在节点的ipvs规则进行定期同步; netlink 与 iptables 底层都是基于 netfilter 钩子，但是 netlink 由于采用了 hash table 而且直接工作在内核态，在性能上比 iptables 更优。其工作流程大体如下:</p><p><img src="https://slions.gitee.io/picbed/img/proxy8.png"></p><p><strong>由此分析：</strong>ipvs 是目前 kube-proxy 所支持的最新代理模式，相比使用 iptables，使用 ipvs 具有更高的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kube-proxy的作用&quot;&gt;&lt;a href=&quot;#kube-proxy的作用&quot; class=&quot;headerlink&quot; title=&quot;kube-proxy的作用&quot;&gt;&lt;/a&gt;kube-proxy的作用&lt;/h1&gt;&lt;p&gt;kube-proxy是Kubernetes的核心组件</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>k8s-etcd理解</title>
    <link href="https://slions.github.io/2021/10/03/k8s-etcd%E7%90%86%E8%A7%A3/"/>
    <id>https://slions.github.io/2021/10/03/k8s-etcd%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-03T03:39:44.000Z</published>
    <updated>2021-10-07T03:04:22.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="etcd作用"><a href="#etcd作用" class="headerlink" title="etcd作用"></a>etcd作用</h1><p>是用来存储所有 Kubernetes 的集群状态的，它除了具备状态存储的功能，还有事件监听和订阅、Leader选举的功能。</p><h2 id="存储k8s集群状态"><a href="#存储k8s集群状态" class="headerlink" title="存储k8s集群状态"></a>存储k8s集群状态</h2><p>整个kubernetes系统需要用到etcd用来协同和存储配置的有：</p><ul><li>网络插件flannel、calico等网络插件也需要用到etcd存储网络的配置信息</li><li>kubernetes本身，包括各种对象的状态和元信息配置</li></ul><blockquote><p>很多网上资料讲flannel操作etcd使用的是v2的API，而kubernetes操作etcd使用的v3的API，所以在下面我们执行etcdctl的时候需要设置ETCDCTL_API环境变量，该变量默认值为2。实际环境中没有找到。</p></blockquote><p><img src="https://slions.gitee.io/picbed/img/etcd1.png"></p><p>直接删除etcd中的数据在k8s中也会直接删除，但是由于apiserver会有对etcd的缓存，有段时间会显示数据显示不一致。</p><h2 id="事件监听和订阅"><a href="#事件监听和订阅" class="headerlink" title="事件监听和订阅"></a>事件监听和订阅</h2><p>所谓事件监听和订阅，各个其他组件通信，都并不是互相调用 API 来完成的，而是把状态写入 ETCD（相当于写入一个消息），其他组件通过监听 ETCD 的状态的的变化（相当于订阅消息），然后做后续的处理，然后再一次把更新的数据写入 ETCD。</p><h2 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h2><p>在k8s的组件中，其中有kube-scheduler和kube-controller-manager两个组件是有leader选举的，这个选举机制是k8s对于这两个组件的高可用保障。需要–leader-elect=true启动参数。即正常情况下kube-scheduler或kube-manager-controller组件的多个副本只有一个是处于业务逻辑运行状态，其它副本则不断的尝试去获取锁，去竞争leader，直到自己成为leader。如果正在运行的leader因某种原因导致当前进程退出，或者锁丢失，则由其它副本去竞争新的leader，获取leader继而执行业务逻辑。</p><p><img src="https://slions.gitee.io/picbed/img/etcd2.png"></p><p>在K8s中， 通过创建资源对象（当前的实现中实现了 ConfigMap 和 Endpoint 两种类型的资源）来维护锁的状态。这两种资源对象存在etcd里，也可以说是用etcd来实现的。</p><p>分布式锁一般实现原理就是大家先去抢锁，抢到的成为 leader ，然后 leader 会定期更新锁的状态，声明自己的活动状态，不让其他人把锁抢走。K8s 的资源锁也类似，抢到锁的节点会将自己的标记。设为锁的持有者，其他人则需要通过对比锁的更新时间和持有者来判断自己是否能成为新的 leader ，而 leader 则可以通过更新RenewTime来确保持续保有该锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;etcd作用&quot;&gt;&lt;a href=&quot;#etcd作用&quot; class=&quot;headerlink&quot; title=&quot;etcd作用&quot;&gt;&lt;/a&gt;etcd作用&lt;/h1&gt;&lt;p&gt;是用来存储所有 Kubernetes 的集群状态的，它除了具备状态存储的功能，还有事件监听和订阅、Leade</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>k8s-scheduler原理</title>
    <link href="https://slions.github.io/2021/10/03/k8s-scheduler%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/10/03/k8s-scheduler%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-03T02:39:28.000Z</published>
    <updated>2021-10-07T03:05:02.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scheduler作用"><a href="#scheduler作用" class="headerlink" title="scheduler作用"></a>scheduler作用</h1><p>负责整个集群资源的调度功能，根据特定的调度算法和策略，将 Pod 调度到最优的工作节点上面去，从而更加合理、更加充分的利用集群的资源。</p><p><img src="https://slions.gitee.io/picbed/img/sche1.png"></p><h1 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h1><p>根据特定的调度算法和调度策略将 Pod 调度到合适的 Node 节点上去，是一个独立的二进制程序，启动之后会一直监听 API Server，获取到 PodSpec.NodeName 为空的 Pod，对每个 Pod 都会创建一个 binding。</p><p>Scheduler 提供的调度流程分为预选 (Predicates) 和优选 (Priorities) 两个步骤：</p><ul><li>预选，K8S会遍历当前集群中的所有 Node，筛选出其中符合要求的 Node 作为候选</li><li>优选，K8S将对候选的 Node 进行打分</li></ul><p><strong>预选</strong>阶段首先遍历全部节点，过滤掉不满足条件的节点，属于强制性规则，这一阶段输出的所有满足要求的 Node 将被记录并作为第二阶段的输入，如果所有的节点都不满足条件，那么 Pod 将会一直处于 Pending 状态，直到有节点满足条件，在这期间调度器会不断的重试。</p><p><strong>优选</strong>阶段即再次对节点进行筛选，如果有多个节点都满足条件的话，那么系统会按照节点的优先级(priorites)大小对节点进行排序，最后选择优先级最高的节点来部署 Pod 应用。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><strong>Queue</strong></h2><p>Kubernetes Scheduler 在多任务情况下，他是如何工作的？ Queue，队列方式工作的，也就是说，即便有多个调度任务同时在 etcd 中等待调度， Scheduler 每次只会调度一个任务（和 Master 的数量无关）。内部逻辑：</p><ol><li><p>Scheduler 内部维护一个调度的pods队列podQueue， 并监听APIServer。</p></li><li><p>当我们创建Pod时，首先通过 API Server 往 etcd 写入 pod 元数据。</p></li><li><p>调度器通过 Informer 监听 pods 状态，当有新增 pod 时，将 pod 加入到 PodQueue中。</p></li><li><p>调度器中的主进程，会不断的从podQueue取出的pod，并将pod进入调度分配节点环节</p></li><li><p>调度环节分为两个步奏， Filter过滤满足条件的节点 、 Prioritize根据pod配置，例如资源使用率，亲和性等指标，给这些节点打分，最终选出分数最高的节点。</p></li><li><p>分配节点成功， 调用apiServer的binding pod 接口， 将pod.Spec.NodeName设置为所分配的那个节点。</p></li><li><p>节点上的kubelet同样监听ApiServer，如果发现有新的pod被调度到所在节点，调用本地的dockerDaemon 运行容器。</p><p>假如调度器尝试调度 Pod 不成功，如果开启了优先级和抢占功能，会尝试做一次抢占，将节点中优先级较低的pod删掉，并将待调度的pod调度到节点上。 如果未开启，或者抢占失败，会记录日志，并将pod加入 PodQueue 队尾（这意味着，如果调度队列很长，你只有多等待了）。</p></li><li><p>经过预选筛选和优选打分之后，K8S选择分数最高的 Node 来运行 Pod，如果最终有多个 Node 的分数最高，那么 Scheduler 将从当中随机选择一个 Node 来运行 Pod。</p></li></ol><h2 id="预选策略"><a href="#预选策略" class="headerlink" title="预选策略"></a>预选策略</h2><p><img src="https://slions.gitee.io/picbed/img/sche2.png"></p><p>如果开启了 TaintNodesByCondition(从 1.12 开始为 beta级别，默认开启) 特性，则 CheckNodeCondition、CheckNodeMemoryPressure、CheckNodeDiskPressure、CheckNodePIDPressure 预选策略则会被禁用，PodToleratesNodeNoExecuteTaints、CheckNodeUnschedulable 则会启用。</p><h2 id="优选策略"><a href="#优选策略" class="headerlink" title="优选策略"></a>优选策略</h2><p><img src="https://slions.gitee.io/picbed/img/sche3.png"></p><p>如果开启了 ResourceLimitsPriorityFunction(默认不开启) 特性，则 ResourceLimitsPriority 会被启用。</p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>查看<a href="/2021/10/03/k8s-etcd%E7%90%86%E8%A7%A3/" title="etcd篇的leader选举">etcd篇的leader选举</a>，没有额外设置都是走的默认配置（endpoint）,可以在scheduler.conf中设置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;scheduler作用&quot;&gt;&lt;a href=&quot;#scheduler作用&quot; class=&quot;headerlink&quot; title=&quot;scheduler作用&quot;&gt;&lt;/a&gt;scheduler作用&lt;/h1&gt;&lt;p&gt;负责整个集群资源的调度功能，根据特定的调度算法和策略，将 Pod 调</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>k8s-apiserver原理</title>
    <link href="https://slions.github.io/2021/09/26/k8s-apiserver%E5%8E%9F%E7%90%86/"/>
    <id>https://slions.github.io/2021/09/26/k8s-apiserver%E5%8E%9F%E7%90%86/</id>
    <published>2021-09-26T03:38:54.000Z</published>
    <updated>2021-10-03T08:59:24.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apiserver作用"><a href="#apiserver作用" class="headerlink" title="apiserver作用"></a>apiserver作用</h1><p>其对外暴露了Kubernetes API。它是的 Kubernetes 核心控制层。它被设计为水平扩展，即通过部署更多实例来横向扩展。API Server 负责和 etcd 交互（其他组件不会直接操作 etcd，只有 API Server 这么做），是整个 kubernetes 集群的数据中心，所有的交互都是以 API Server 为核心的。API Server 提供了以下的功能：</p><ul><li>提供了Kubemetes 各类资源对象的增、删、改、查及watch等的http rest接口。是资源配额的入口。</li><li>提供了完备的集群安全控制：API Server 提供的验证和授权保证了整个集群的安全。</li><li>集群内部各个模块之间通信的枢纽：所有模块之间并不会互相调用，而是通过和 API Server 打交道来完成各自的工作。</li></ul><p>kubernetes API server通过一个名为kube-apiserver的进程提供服务（运行在master节点），默认情况下kube-apiserver进程通过本机的8080端口（对应参数–insecure-port）提供REST服务。默认安装后会启动HTTPS安全端口（–secure-port=6443）来启动安全机制，加强REST API的安全性。</p><blockquote><p>可以通过curl 127.0.0.1:8080/api/v1查看目前支持的资源对象种类。</p></blockquote><h2 id="apiserver之restful接口"><a href="#apiserver之restful接口" class="headerlink" title="apiserver之restful接口"></a>apiserver之restful接口</h2><p>在Kubernetes系统中，大多数情况下，API定义和实现都符合标准的HTTP REST格式， 比如通过标准的HTTP动词（POST、PUT、GET、DELETE）来完成对相关资源对象的查询、创建、修改、删除等操作。但同时Kubernetes 也为某些非标准的REST行为实现了附加的API接口，例如Watch某个资源的变化、进入容器执行某个操作等。另外，某些API接口可能违背严格的REST模式，因为接口不是返回单一的JSON对象，而是返回其他类型的数据，比如JSON对象流（Stream）或非结构化的文本日志数据等。</p><h3 id="使用REST接口"><a href="#使用REST接口" class="headerlink" title="使用REST接口"></a>使用REST接口</h3><ul><li><p>GET /&lt;资源名的复数格式&gt;：获得某一类型的资源列表，例如GET /pods 返回一个Pod资源列表。</p></li><li><p>POST /&lt;资源名的复数格式&gt;：创建一个资源，该资源来自用户提供的JSON对象。</p></li><li><p>GET /&lt;资源名复数格式&gt;/&lt;名字&gt;：通过给出的名称（Name）获得单个资源，例如GET /pods/first 返回一个名称为“first”的Pod。</p></li><li><p>DELETE /&lt;资源名复数格式&gt;/&lt;名字&gt;：通过给出的名字删除单个资源，删除选项（DeleteOptions）中可以指定的优雅删除（Grace Deletion）的时间（GracePeriodSeconds），该可选项表明了从服务端接收到删除请求到资源被删除的时间间隔（单位为秒）。不同的类别（Kind）可能为优雅删除时间（Grace Period）申明默认值。用户提交的优雅删除时间将覆盖该默认值，包括值为0的优雅删除时间。</p></li><li><p>PUT /&lt;资源名复数格式&gt;/&lt;名字&gt;：通过给出的资源名和客户端提供的JSON对象来更新或创建资源。</p></li><li><p>PATCH /&lt;资源名复数格式&gt;/&lt;名字&gt;：选择修改资源详细指定的域。</p><p>对于PATCH操作，目前Kubernetes API通过相应的HTTP首部“Content-Type”对其进行识别。</p></li><li><p>GET /watch/&lt;资源名复数格式&gt;：随时间变化，不断接收一连串的JSON对象，这些JSON对象记录了给定资源类别内所有资源对象的变化情况。</p></li><li><p>GET /watch/&lt;资源名复数格式&gt;/：随时间变化，不断接收一连串的JSON对象，这些JSON对象记录了某个给定资源对象的变化情况。</p></li></ul><h3 id="特殊的REST接口"><a href="#特殊的REST接口" class="headerlink" title="特殊的REST接口"></a>特殊的REST接口</h3><p>k8s Proxy API接口，这类接口的作用是代理REST请求，即kubernetes API Server把收到的REST请求转发到某个Node上的kubelet守护进程的REST端口上，由该kubelet进程负责响应。</p><p>最实用的一个特性是可以实现一个简单有效的安全机制，如果只想对外暴露部分REST服务，则可以在Master或者其他任何节点上通过运行kubectl proxy进程启动一个内部代理来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy --address=192.168.191.15 --accept-hosts=&#x27;^*$&#x27;</span><br></pre></td></tr></table></figure><p>以上的例子是我们安装好kube-dashboard后登录ui所用的启动代理命令，其中的–accept-hosts就是允许访问的机器。</p><h2 id="apiserver之安全机制"><a href="#apiserver之安全机制" class="headerlink" title="apiserver之安全机制"></a>apiserver之安全机制</h2><p>用户可通过客户端kubectl命令行工具或其它方式访问Kubernetes的API资源，每个访问API的请求，都要经过三个步骤校验：Authentication、Authorization、Admission Control，总体如下图所示：</p><p><img src="https://slions.gitee.io/picbed/img/api1.png"></p><ul><li>Authentication（认证），<strong>对用户身份进行验证</strong>。认证方式现共有8种，可以启用一种或多种认证方式，只要有一种认证方式通过，就不再进行其它方式的认证。通常启用X509 Client Certs和Service Accout Tokens两种认证方式。</li><li>Authorization（授权），<strong>验证用户是否拥有访问权限</strong>。授权方式现共有6种，可以启用一种或多种授权方式，启用的任一种方式依据授权策略明确允许或拒绝请求，则立即返回，不再进行其它方式的授权。通常启用RBAC和Node授权方式。</li><li>Admission Control（准入控制），<strong>对API资源对象修改、校验</strong>。它有一个插件列表，所有请求需要经过这个列表中的每个准入控制插件修改、校验，如果某一个准入控制插件验证失败，就拒绝请求。</li></ul><p>用户访问 Kubernetes API时，apiserver认证授权模块从HTTPS请求中获取用户的身份信息、请求资源路径和业务对象参数。身份信息是用来确认用户的身份是否合法，资源路径是用于判定用户是否拥有访问操作的权限，业务对象参数则在准入控制中接受修改或校验参数设置是否符合业务要求。</p><p><img src="https://slions.gitee.io/picbed/img/api2.png"></p><ol><li>请求到达后，apiserver从请求的证书、Header中获取用户信息：Name（用户名）、UID（用户唯一标识）、Groups（用户分组）、Extra（用户额外信息）。认证通过后，通过Context将用户信息向下传播。</li><li>授权模块从Context、请求的Method及URI提取用户信息、请求资源属性。使用请求资源属性与授权策略匹配或向外部服务验证判断是否准予访问。</li><li>准入控制接收到HTTPS请求提交的Body内容、用户信息、资源信息，根据不同准入控制插件的功能对上述信息做修改或校验。</li></ol><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>认证即身份验证，认证关注的是谁发送的请求，也就是说用户必须用某种方式证明自己的身份信息。</p><p>Kubernetes集群有两种类型的用户：普通用户（normal users）、服务账户（service accounts），普通用户并不被Kubernetes管理和保存；而服务账户由Kubernetes存储在etcd中，并可通过apiserver API管理。</p><p>1.14版本中已支持8种认证方式，从身份验证的方法上可分为4种类型：Token、证书、代理、密码。Kubernetes可以同时启用多个认证方式，在这种情况下，每个认证模块都按顺序尝试验证用户身份，直到其中一个成功就认证通过。</p><p>启用多个认证方式时，验证顺序如下：</p><p><img src="https://slions.gitee.io/picbed/img/api3.png"></p><p>kubernetes 系统的各组件需要使用 TLS 证书对通信进行加密，需要通过一个权威的机构进行签名许可，也就是ca，ca证书可以用购买的，可以自己通过cfssl来手动创建，也可以使用kubeadm生成的。</p><p>以下是kubeadm自己生成的证书。</p><p>Kubernetes把证书放在了两个文件夹中</p><ul><li>/etc/kubernetes/pki</li><li>/etc/kubernetes/pki/etcd</li></ul><p>具体的证书解释可以看之前写的<a href="/2021/09/23/%E4%BF%AE%E6%94%B9kubeadm%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/" title="修改kubeadm证书过期时间">修改kubeadm证书过期时间</a></p><p><img src="https://slions.gitee.io/picbed/img/api4.png"></p><p>其中可以看到并没有kubelet，kube-scheduler,kube-controller-manager，kube-proxy的证书，是因为kubeadm初始化时已经把证书生成到了/etc/kubernetes下，叫它kubeconfig，就是一个集成了各种安全授权信息的配置文件。</p><p><img src="https://slions.gitee.io/picbed/img/api5.png"></p><p>里面不仅有证书，还有所属的用户（RBAC）对应的权限。</p><p><img src="https://slions.gitee.io/picbed/img/api6.png"></p><p>再研究下node节点怎么认证的：</p><p>当想要加入一个新node节点到集群中时会通过master节点生成一条命令，并到新节点执行，</p><p>比如：</p><p><img src="https://slions.gitee.io/picbed/img/api7.png"></p><p>会由master节点生成一个token再加上经过hash算法生成的ca证书来供节点连接集群。</p><p>这时新节点执行命令后会自动生成kubeconfig文件。</p><p><img src="https://slions.gitee.io/picbed/img/api8.png"></p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权包括六种方式：AlwaysDeny、AlwaysAllow、ABAC、RBAC、Webhook、Node。配置多个授权时，将按顺序检查每个授权，任何一个匹配的授权策略允许或拒绝请求时，则立即返回该决定，并且不会再检查其他授权策略；所有授权策略都没有允许或拒绝时，最终则拒绝该请求。</p><p>通过设置apiserver配置参数（–authorization-mode）启用授权插件。</p><p>授权只依据以下的属性进行判断：</p><p><img src="https://slions.gitee.io/picbed/img/api9.png"></p><p>其中API、Resource、Subresource、Namespace、APIGroup是从请求的URI中解析获取得到。</p><p><img src="https://slions.gitee.io/picbed/img/api10.png"></p><p>当前平台的授权方式是RBAC和NODE，机制为：</p><p><img src="https://slions.gitee.io/picbed/img/api11.png"></p><p><em><strong>RBAC</strong></em></p><p>RBAC包括四种类型：Role、ClusterRole、RoleBinding、ClusterRoleBinding。Role、ClusterRole包含一组权限规则，其中ClusterRole能应用于所有的命名空间（配置中没有命名空间选项），常用于没有命名空间的资源，如nodes；而Role只能包含单个命名空间的权限规则。RoleBinding、ClusterRoleBinding是将角色中定义的权限授予用户、用户组或服务账户。</p><p><em><strong>NODE</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get clusterrole system:node</span><br></pre></td></tr></table></figure><h3 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h3><p>准入控制（Admission Control）是Kubernetes apiserver用于拦截请求的一种方式，运行在认证、授权之后，是权限认证链上的最后一环，对请求API资源对象进行修改（Mutation）和校验（Validating）。 </p><p>在Kubernetes 1.10+之后，用户在使用参数–enable-admission-plugins配置启用准入控制时不需要关注它们的排列顺序，apiserver在注册准入控制插件时，已经定义好了所有插件的执行顺序。</p><p>Admission主要插件列表：</p><p><img src="https://slions.gitee.io/picbed/img/api12.png"></p><h2 id="集群功能模块间的通信"><a href="#集群功能模块间的通信" class="headerlink" title="集群功能模块间的通信"></a>集群功能模块间的通信</h2><p>kubernetes API Server作为集群的核心，负责集群各功能模块之间的通信，集群内各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，通过API Server提供的REST接口（GET\LIST\WATCH方法）来实现，从而实现各模块之间的信息交互。</p><h3 id="kubelet与API-Server交互"><a href="#kubelet与API-Server交互" class="headerlink" title="kubelet与API Server交互"></a>kubelet与API Server交互</h3><p>每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server的Watch接口监听Pod信息，从而对Node机器上的POD进行管理。</p><p>监听信息与kubelet执行动作，当新的POD副本被调度绑定到本节点，则kubelet执行POD对应的容器的创建和启动逻辑。<br>当POD对象被删除，则kubelet删除本节点上相应的POD容器。<br>当修改Pod信息，则kubelet修改本节点的POD容器。</p><h3 id="kube-controller-manager与API-Server交互"><a href="#kube-controller-manager与API-Server交互" class="headerlink" title="kube-controller-manager与API Server交互"></a>kube-controller-manager与API Server交互</h3><p>kube-controller-manager中的Node Controller模块通过API Server提供的Watch接口，实时监控Node的信息，并做相应处理。</p><h3 id="kube-scheduler与API-Server交互"><a href="#kube-scheduler与API-Server交互" class="headerlink" title="kube-scheduler与API Server交互"></a>kube-scheduler与API Server交互</h3><p>Scheduler通过API Server的Watch接口监听到新建Pod副本的信息后，它会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>为了缓解各模块对API Server的访问压力，各功能模块都采用缓存机制来缓存数据，各功能模块定时从API Server获取指定的资源对象信息（LIST/WATCH方法），然后将信息保存到本地缓存，功能模块在某些情况下不直接访问API Server，而是通过访问缓存数据来间接访问API Server。</p><h1 id="apiserver的核心机制"><a href="#apiserver的核心机制" class="headerlink" title="apiserver的核心机制"></a>apiserver的核心机制</h1><h2 id="list-watch"><a href="#list-watch" class="headerlink" title="list-watch"></a><strong>list-watch</strong></h2><p>List-Watch是kubernetes的核心机制。组件kubelet、kube-controller-manager、kube-scheduler需要监控各种资源(pod、service等)的变化，当这些对象发生变化时(add、delete、update)，kube-apiserver会主动通知这些组件。这个过程类似一个发布-订阅系统。</p><p>下图是一个典型的Pod创建过程，在这个过程中，每次当kubectl创建了ReplicaSet对象后，controller-manager都是通过list-watch这种方式得到了最新的ReplicaSet对象，并执行自己的逻辑来创建Pod对象。其他的几个组件，Scheduler/Kubelet也是一样，通过list-watch得知变化并进行处理。</p><p><img src="https://slions.gitee.io/picbed/img/api13.png"></p><p><strong>kube-apiserver对etcd的List-watch并提供watch restful API给其他组件(kubelet、kube-controller-manager、kube-scheduler、kube-proxy)。</strong></p><ul><li>由组件向apiserver而不是etcd发起watch请求，在组件启动时就进行订阅，告诉apiserver需要知道什么数据发生变化。Watch是一个典型的发布-订阅模式。</li><li>组件向apiserver发起的watch请求是可以带条件的，例如，scheduler想要watch的是所有未被调度的Pod，也就是满足Pod.destNode=””的Pod来进行调度操作；而kubelet只关心自己节点上的Pod列表。apiserver向etcd发起的watch是没有条件的，只能知道某个数据发生了变化或创建、删除，但不能过滤具体的值。也就是说对象数据的条件过滤必须在apiserver端而不是etcd端完成。</li><li>list是watch失败，数据太过陈旧后的弥补手段，list本身是一个简单的列表操作，和其它apiserver的增删改操作一样。</li></ul><h1 id="高可用实现"><a href="#高可用实现" class="headerlink" title="高可用实现"></a>高可用实现</h1><p>它被设计为水平扩展，即通过部署更多实例来横向扩展。</p><p>常见的高可用方案是</p><ul><li>keepalived + haproxy</li><li>keepalived + nginx</li><li>公有云LSB</li></ul><p>原理就是利用软件对k8s的6443端口进行负载，再对每台master节点做IP高可用，通过脚本检测后端服务的健康状态。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://blog.csdn.net/karamos/article/details/80121896?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2">Kubernetes API详解</a></p><p><a href="https://www.jianshu.com/p/e9cb0118ec1e">apiserver之list-watch篇</a></p><p><a href="https://baijiahao.baidu.com/s?id=1634394182029344798&wfr=spider&for=pc">Kubernetes API 安全机制详解</a></p><p>《kubernetes权威指南》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;apiserver作用&quot;&gt;&lt;a href=&quot;#apiserver作用&quot; class=&quot;headerlink&quot; title=&quot;apiserver作用&quot;&gt;&lt;/a&gt;apiserver作用&lt;/h1&gt;&lt;p&gt;其对外暴露了Kubernetes API。它是的 Kubernete</summary>
      
    
    
    
    <category term="kubernetes笔记" scheme="https://slions.github.io/categories/kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes核心组件" scheme="https://slions.github.io/tags/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>修改kubeadm证书过期时间</title>
    <link href="https://slions.github.io/2021/09/23/%E4%BF%AE%E6%94%B9kubeadm%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
    <id>https://slions.github.io/2021/09/23/%E4%BF%AE%E6%94%B9kubeadm%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/</id>
    <published>2021-09-23T14:20:58.000Z</published>
    <updated>2021-10-03T04:53:24.512Z</updated>
    
    <content type="html"><![CDATA[<p>使用kubeadm创建完Kubernetes集群后, 默认会在/etc/kubernetes/pki目录下存放集群中需要用到的证书文件, 整体结构如下图所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:/etc/kubernetes/pki# tree</span><br><span class="line">.</span><br><span class="line">|-- apiserver.crt</span><br><span class="line">|-- apiserver-etcd-client.crt</span><br><span class="line">|-- apiserver-etcd-client.key</span><br><span class="line">|-- apiserver.key</span><br><span class="line">|-- apiserver-kubelet-client.crt</span><br><span class="line">|-- apiserver-kubelet-client.key</span><br><span class="line">|-- ca.crt</span><br><span class="line">|-- ca.key</span><br><span class="line">|-- etcd</span><br><span class="line">|   |-- ca.crt</span><br><span class="line">|   |-- ca.key</span><br><span class="line">|   |-- healthcheck-client.crt</span><br><span class="line">|   |-- healthcheck-client.key</span><br><span class="line">|   |-- peer.crt</span><br><span class="line">|   |-- peer.key</span><br><span class="line">|   |-- server.crt</span><br><span class="line">|   `-- server.key</span><br><span class="line">|-- front-proxy-ca.crt</span><br><span class="line">|-- front-proxy-ca.key</span><br><span class="line">|-- front-proxy-client.crt</span><br><span class="line">|-- front-proxy-client.key</span><br><span class="line">|-- sa.key</span><br><span class="line">`-- sa.pub</span><br></pre></td></tr></table></figure><h1 id="证书分组"><a href="#证书分组" class="headerlink" title="证书分组"></a>证书分组</h1><p>Kubernetes把证书放在了两个文件夹中</p><ul><li>/etc/kubernetes/pki</li><li>/etc/kubernetes/pki/etcd</li></ul><h2 id="Kubernetes-集群根证书"><a href="#Kubernetes-集群根证书" class="headerlink" title="Kubernetes 集群根证书"></a>Kubernetes 集群根证书</h2><p>Kubernetes 集群根证书CA(Kubernetes集群组件的证书签发机构)</p><ul><li><p>/etc/kubernetes/pki/ca.crt</p></li><li><p>/etc/kubernetes/pki/ca.key</p></li></ul><p>以上这组证书为签发其他Kubernetes组件证书使用的根证书, 可以认为是Kubernetes集群中证书签发机构之一。</p><p>由此根证书签发的证书有:</p><ol><li>kube-apiserver 组件持有的服务端证书</li></ol><ul><li><p>/etc/kubernetes/pki/apiserver.crt</p></li><li><p>/etc/kubernetes/pki/apiserver.key</p></li></ul><ol start="2"><li>kubelet 组件持有的客户端证书, 用作 kube-apiserver 主动向 kubelet 发起请求时的客户端认证</li></ol><ul><li><p>/etc/kubernetes/pki/apiserver-kubelet-client.crt</p></li><li><p>/etc/kubernetes/pki/apiserver-kubelet-client.key</p></li></ul><h2 id="汇聚层证书"><a href="#汇聚层证书" class="headerlink" title="汇聚层证书"></a>汇聚层证书</h2><p>kube-apiserver 的另一种访问方式就是使用 kubectl proxy 来代理访问, 而该证书就是用来支持SSL代理访问的. 在该种访问模式下, 我们是以http的方式发起请求到代理服务的, 此时, 代理服务会将该请求发送给 kube-apiserver, 在此之前, 代理会将发送给 kube-apiserver 的请求头里加入证书信息。</p><p>kube-apiserver 代理根证书(客户端证书)</p><p>用在requestheader-client-ca-file配置选项中, kube-apiserver 使用该证书来验证客户端证书是否为自己所签发</p><ul><li>/etc/kubernetes/pki/front-proxy-ca.crt</li><li>/etc/kubernetes/pki/front-proxy-ca.key</li></ul><p>由此根证书签发的证书只有一组:</p><p>代理层(如汇聚层aggregator)使用此套代理证书来向 kube-apiserver 请求认证</p><p>代理端使用的客户端证书, 用作代用户与 kube-apiserver 认证</p><ul><li>/etc/kubernetes/pki/front-proxy-client.crt</li><li>/etc/kubernetes/pki/front-proxy-client.key</li></ul><h2 id="etcd-集群根证书"><a href="#etcd-集群根证书" class="headerlink" title="etcd 集群根证书"></a>etcd 集群根证书</h2><p>etcd集群所用到的证书都保存在/etc/kubernetes/pki/etcd这路径下, 很明显, 这一套证书是用来专门给etcd集群服务使用的, 设计以下证书文件</p><p>etcd 集群根证书CA(etcd 所用到的所有证书的签发机构)</p><ul><li>/etc/kubernetes/pki/etcd/ca.crt</li><li>/etc/kubernetes/pki/etcd/ca.key</li></ul><p>由此根证书签发机构签发的证书有:</p><ol><li>etcd server 持有的服务端证书</li></ol><ul><li><p>/etc/kubernetes/pki/etcd/server.crt</p></li><li><p>/etc/kubernetes/pki/etcd/server.key</p></li></ul><ol start="2"><li>peer 集群中节点互相通信使用的客户端证书</li></ol><ul><li>/etc/kubernetes/pki/etcd/peer.crt</li><li>/etc/kubernetes/pki/etcd/peer.key</li></ul><ol start="3"><li>pod 中定义 Liveness 探针使用的客户端证书</li></ol><ul><li><p>/etc/kubernetes/pki/etcd/healthcheck-client.crt</p></li><li><p>/etc/kubernetes/pki/etcd/healthcheck-client.key</p></li></ul><blockquote><p>kubeadm 部署的 Kubernetes 集群是以 pod 的方式运行 etcd 服务的, 在该 pod 的定义中, 配置了 Liveness 探活探针。</p><p>当 describe etcd 的 pod 时, 会看到如下一行配置:</p><p>Liveness:       exec [/bin/sh -ec ETCDCTL_API=3 etcdctl –endpoints=https://[127.0.0.1]:2379 –cacert=/etc/kubernetes/pki/etcd/ca.crt –cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt –key=/etc/kubernetes/pki/etcd/healthcheck-client.key get foo] delay=15s timeout=15s period=10s #success=1 #failure=8</p></blockquote><ol start="4"><li>配置在 kube-apiserver 中用来与 etcd server 做双向认证的客户端证书</li></ol><ul><li>/etc/kubernetes/pki/apiserver-etcd-client.crt</li><li>/etc/kubernetes/pki/apiserver-etcd-client.key</li></ul><h2 id="Serveice-Account秘钥"><a href="#Serveice-Account秘钥" class="headerlink" title="Serveice Account秘钥"></a>Serveice Account秘钥</h2><p>最后介绍的这组”证书”其实不是证书, 而是一组秘钥，这组的密钥对儿仅提供给 kube-controller-manager 使用. kube-controller-manager 通过 sa.key 对 token 进行签名, master 节点通过公钥 sa.pub 进行签名的验证。</p><ul><li>/etc/kubernetes/pki/sa.key</li><li>/etc/kubernetes/pki/sa.pub</li></ul><p>因为 kubeadm 创建的集群, kube-proxy 是以 pod 形式运行的, 在 pod 中, 直接使用 service account 与 kube-apiserver 进行认证, 此时就不需要再单独为 kube-proxy 创建证书了。</p><blockquote><p>如果 kube-proxy 是以守护进程的方式直接运行在宿主机的, 那么就需要为它创建一套证书了。创建的方式也很简单, 直接使用上面第一条提到的 Kubernetes 集群根证书 进行签发就可以了(注意CN和O的设置)。</p></blockquote><h1 id="证书过期"><a href="#证书过期" class="headerlink" title="证书过期"></a>证书过期</h1><p>利用kubeadm安装后发现ca的证书过期时间是十年，但是由ca签发的如apiserver.crt的证书过期时间都是一年，这就尴尬了。</p><ol><li>如果已经创建后的集群到了一年执行kubectl命令会出现：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: x509: certificate has expired or is not yet valid</span><br></pre></td></tr></table></figure><p>此时需要手动更新证书。</p><ol start="2"><li>如果我们还没开始搭建，在搭建集群前我们可以直接修改相关源码解决这个问题。</li></ol><p><strong>拉取kubernetes的源码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/kubernetes/kubernetes.git</span><br></pre></td></tr></table></figure><p><strong>切换版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd kubernetes &amp;&amp; git checkout -b remotes/origin/release-1.11  v1.11.0</span><br></pre></td></tr></table></figure><p><strong>安装Go环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.10.2.linux-amd64.tar.gz</span><br><span class="line">tar zxvf go1.10.2.linux-amd64.tar.gz  -C  /usr/local </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">编辑/etc/profile文件添加如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">go setting</span></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile 生效</span><br><span class="line"> </span><br><span class="line">验证：</span><br><span class="line">go version</span><br><span class="line">go version go1.10.2 linux/amd64</span><br></pre></td></tr></table></figure><p><strong>修改源码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd  ~/kubernetes/staging/src/k8s.io/client-<span class="keyword">go</span>/util/cert/</span><br><span class="line">#编辑 cert.<span class="keyword">go</span>文件（<span class="number">107</span>行和<span class="number">180</span>行）</span><br><span class="line">@@<span class="number">107</span>@@</span><br><span class="line">-    NotAfter:     time.Now().Add(duration365d).UTC(),</span><br><span class="line">+    NotAfter:     time.Now().Add(duration365d * <span class="number">10</span>).UTC(),</span><br><span class="line">@@<span class="number">180</span>@@</span><br><span class="line">-    NotAfter:  time.Now().Add(time.Hour * <span class="number">24</span> * <span class="number">365</span>),</span><br><span class="line">+    NotAfter:  time.Now().Add(time.Hour * <span class="number">24</span> * <span class="number">3650</span>),</span><br></pre></td></tr></table></figure><p><strong>编译Go</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /kubernetes/ &amp;&amp; make WHAT=cmd/kubeadm</span><br></pre></td></tr></table></figure><p>查看编译后的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll ~/kubernetes/_output/bin/kubeadm</span><br><span class="line">注意看时间</span><br></pre></td></tr></table></figure><p><strong>替换kubeadm</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/kubeadm /usr/bin/kubeadm_backup</span><br><span class="line">ln -s  ~/kubernetes/_output/bin/kubeadm /usr/bin/kubeadm</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用kubeadm创建完Kubernetes集群后, 默认会在/etc/kubernetes/pki目录下存放集群中需要用到的证书文件, 整体结构如下图所示:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="kubernetes" scheme="https://slions.github.io/categories/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="https://slions.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>我是一个线程（转载）</title>
    <link href="https://slions.github.io/2021/09/19/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://slions.github.io/2021/09/19/%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</id>
    <published>2021-09-19T08:14:03.000Z</published>
    <updated>2021-09-30T08:43:51.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自IBM前架构师刘欣</p></blockquote><h1 id="初生牛犊"><a href="#初生牛犊" class="headerlink" title="初生牛犊"></a>初生牛犊</h1><p>我是一个线程，我一出生就被编了个号：<code>0x3704</code>，然后被领到一个昏暗的屋子里，在这里我发现了很多和我一模一样的同伴。</p><p>我身边的同伴<code>0x6900</code> 待的时间比较长，他带着沧桑的口气对我说：“我们线程的宿命就是处理包裹。把包裹处理完以后还得马上回到这里，否则可能永远回不来了。”</p><p>我一脸懵懂，“包裹，什么包裹？”</p><p>“不要着急，马上你就会明白了，我们这里是不养闲人的。”</p><p>果然，没多久，屋子的门开了， 一个面貌凶恶的家伙吼道：“<code>0x3704</code>,出来！”</p><p>我一出来就被塞了一个沉甸甸的包裹，上面还附带着一个写满了操作步骤的纸。 </p><p>“快去，把这个包裹处理了。”</p><p>“去哪儿处理？”</p><p>“跟着指示走，先到就绪车间。”</p><p>果然，地上有指示箭头，跟着它来到了一间明亮的大屋子，这里已经有不少线程了，大家都很紧张，好像时刻准备着往前冲。</p><p>我刚一进来，就听见广播说：“<code>0x3704</code>，进入车间。”</p><p>我赶紧往前走，身后有很多人议论。</p><p>“他太幸运了，刚进入就绪状态就能运行。”</p><p>“是不是有关系？”</p><p>“不是，你看人家的优先级多高啊，唉！”</p><p>前边就是车间，这里简直是太美了，怪不得老线程总是唠叨着说：“要是能一直待在这里就好了。”</p><p>这里空间大，视野好，空气清新，鸟语花香，还有很多从来没见过的人，像服务员一样等着为我服务。</p><p>他们也都有编号，更重要的是每个人还有个标签，上面写着：硬盘、数据库、内存、网卡……</p><p>我现在理解不了，看看操作步骤吧。</p><p><strong>第一步：从包裹中取出参数。</strong></p><p>打开包裹，里边有个HttpRequest对象，可以取到userName、 password两个参数。</p><p><strong>第二步：执行登录操作。</strong></p><p>奥，原来是有人要登录啊，我把userName、password交给数据库服务员，他拿着数据，慢腾腾地走了。</p><p>他怎么这么慢？不过我是不是正好可以在车间里多待一会儿？反正也没法执行第三步。</p><p>就在这时，车间里的广播响了：“<code>0x3704</code>，我是CPU，记住你正在执行的步骤，然后马上带着包裹离开！”</p><p>我慢腾腾地开始收拾。</p><p>“快点，别的线程马上就要进来了。”</p><p>离开这个车间，又来到一个大屋子，这里有很多线程在慢腾腾地喝茶，打牌。</p><p>“哥们，你们没事干了？”</p><p>“你新来的吧，你不知道我在等数据库服务员给我数据啊！据说他们比我们慢好几十万倍，在这里好好歇吧。”</p><p>“啊？ 这么慢！我这里有人在登录系统，能等这么长时间吗？”</p><p>“放心，你没听说过人间一天，CPU一年吗？我们这里是用纳秒、毫秒计时的，人间等待一秒，相当于我们好几天呢，来得及。”</p><p>干脆睡一会吧。不知道过了多久，大喇叭又开始广播了：“<code>0x3704</code>，你的数据来了，快去执行！”</p><p>我转身就往CPU车间跑，发现这里的门只出不进！</p><p>后面传来阵阵哄笑声：“果然是新人，不知道还得去就绪车间等。”</p><p>于是赶紧到就绪车间，这次没有那么好运了，等了好久才被再次叫进CPU车间。</p><p>在等待的时候，我听见有人小声议论：</p><p>“听说了吗，最近有个线程被kill掉了。”</p><p>“为啥啊？”</p><p>“这家伙赖在CPU车间不走，把CPU利用率一直搞成100%，后来就被kill掉了。”</p><p>“Kill掉以后弄哪儿去了？”</p><p>“可能被垃圾回收了吧。”</p><p>我心里打了个寒噤，赶紧接着处理，剩下的动作快多了，第二步登录成功。</p><p><strong>第三步：构建登录成功后的主页。</strong></p><p>这一步有点费时，因为有很多HTML需要处理，不知道代码谁写的，处理起来很烦人。</p><p>我正在紧张的制作HTML呢， CPU又开始叫了：</p><p>“<code>0x3704</code>，我是CPU ，记住你正在执行的步骤，然后马上带着包裹离开！”</p><p>“为啥啊？”</p><p>“每个线程只能在CPU上运行一段时间，到了时间就得让别人用了，你去就绪车间待着，等着叫你吧。”</p><p>就这样，我一直在“就绪——运行”这两个状态中不知道轮转了多少次， 终于按照步骤清单把工作做完了。</p><p>最后顺利地把包含html的包裹发了回去。至于登录以后干什么事儿，我就不管了。马上就要回到我那昏暗的房间了，真有点舍不得这里。不过相对于有些线程，我还是幸运的，他们运行完以后就被彻底地销毁了，而我还活着！</p><p>回到了小黑屋，老线程<code>0x6900</code>问：</p><p>“怎么样？第一天有什么感觉？”</p><p>“我们的世界规则很复杂，首先你不知道什么时候会被挑中执行；第二，在执行的过程中随时可能被打断，让出CPU车间；第三，一旦出现硬盘、数据库这样耗时的操作，也得让出CPU去等待；第四，就是数据来了，你也不一定马上执行，还得等着CPU挑选。”</p><p>“小伙子理解的不错啊。”</p><p>“我不明白为什么很多线程执行完任务就死了，为什么咱们还活着？”</p><p>“你还不知道？长生不老是我们的特权！我们这里有个正式的名称，叫作<strong>线程池</strong>！”</p><h1 id="渐入佳境"><a href="#渐入佳境" class="headerlink" title="渐入佳境"></a>渐入佳境</h1><p>平淡的日子就这么一天天地过去，作为一个线程，我每天的生活都是取包裹、处理包裹，然后回到我们昏暗的家：线程池。</p><p>有一天我回来的时候，听到有个兄弟说，今天要好好休息下，明天就是最疯狂的一天。我看了一眼日历，明天是 11月11号。 </p><p>果然，零点刚过，不知道那些人类怎么了，疯狂地投递包裹，为了应付蜂拥而至的海量包裹，线程池里没有一个人能闲下来，全部出去处理包裹，CPU车间利用率超高，硬盘在嗡嗡转，网卡疯狂的闪，即便如此，还是处理不完，堆积如山。</p><p>我们也没有办法，实在是太多太多了，这些包裹中大部分都是浏览页面，下订单，买、买、买。</p><p>不知道过了多久，包裹山终于慢慢地消失了。终于能够喘口气，我想我永远都不会忘记这一天。</p><p>通过这个事件，我明白了我所处的世界：这是一个电子商务的网站！</p><p>我每天的工作就是处理用户的登录，浏览，购物车，下单，付款。</p><p>我问线程池的元老<code>0x6900</code>：“我们要工作到什么时候？”</p><p>“要一直等到系统重启的那一刻。”<code>0x6900</code>说。</p><p>“那你经历过系统重启吗？”</p><p>“怎么可能？系统重启就是我们的死亡时刻，也就是世界末日，一旦重启，整个线程池全部销毁，时间和空间全部消失，一切从头再来。”</p><p>“那什么时候会重启？”</p><p>“这就不好说了，好好享受眼前的生活吧……”</p><p>其实生活还是丰富多彩的，我最喜欢的包裹是上传图片，由于网络慢，所以能在就绪车间、CPU车间待很长很长时间，可以认识很多好玩的线程。</p><p>比如说上次认识了memecached 线程，他对我说在他的帮助下缓存了很多的用户数据，还是分布式的！很多机器上都有！</p><p>我问他：“怪不得后来的登录操作快了那么多，原来是不再从数据库取数据了你那里就有啊，哎对了你是分布式的你去过别的机器没有？”</p><p>他说：“怎么可能！我每次也只能通过网络往那个机器发送一个GET、PUT命令才存取数据而已，别的一概不知。”</p><p>再比如说上次在等待的时候遇到了数据库连接的线程，我才知道他那里也是一个连接池，和我们的线程池几乎一模一样。</p><p>他告诉我：“有些包裹太变态了，竟然查看一年的订单数据，简直把我累死了。”</p><p>我说：“拉倒吧你，你那是纯数据，你把数据传给我以后，我还得组装成HTML，工作量不知道比你大多少倍。”</p><p>他建议我：“你一定要和memecached搞好关系，直接从他那儿拿数据，尽量少直接调用数据库，这样我们JDBC connection也能活得轻松点。”</p><p>我欣然接纳：“好啊好啊，关键是你得提前把数据搞到缓存啊，要不然我先问一遍缓存，没有数据，我这不还得找你吗？”</p><p>生活就是这样，如果你自己不找点乐子，还有什么意思？</p><h1 id="虎口脱险"><a href="#虎口脱险" class="headerlink" title="虎口脱险"></a>虎口脱险</h1><p>前几天我遇到一个可怕的事情，差一点死在外边，回不了线程池了。其实这次遇险我应该能够预想得到才对，真是太大意了。</p><p>那天我处理了一些从http发来的存款和取款的包裹，老线程<code>0x6900</code>特意嘱咐我：“处理这些包裹的时候一定要特别小心，你必须先获得一把锁，在对账户存款或取款的时候一定要把账户锁住，要不然别的线程就会在你等待的时候趁虚而入，搞破坏，我年轻那会儿很毛糙，就捅了篓子。”</p><p>为了“恐吓”我， 好心的<code>0x6900</code>还给了我两个表格：</p><p><strong>(1)没有加锁的情况</strong></p><p><img src="https://slions.gitee.io/picbed/img/p1.png"></p><p><strong>(2)加锁的情况</strong></p><p><img src="https://slions.gitee.io/picbed/img/p2.png"></p><p>我看得胆颤心惊，原来不加锁会带来这么严重的事故。从此以后看到存款、取款的包裹就倍加小心，还好没有出过事故。</p><p>今天我收到的一个包裹是转账，从某著名演员的账户给某著名导演的账户转钱，具体是谁我就不透漏了，数额可真是不小。</p><p>我按照老线程的吩咐，肯定要加锁啊，先对著名演员的账户加锁，再对著名导演的账户加锁。</p><p>可我万万没想到的是，还有一个线程，对，就是<code>0x7954</code>, 竟然同时在从这个导演的账户往这个演员的账户转账。 </p><p>于是乎，就出现了这么个情况：</p><p><img src="https://slions.gitee.io/picbed/img/p3.png"></p><p>刚开始我还不知道什么情况，一直坐在等待车间傻等，可是等的时间太长了，长达几十秒！我可从来没有经历过这样的事件。</p><p>这时候我就看到了线程<code>0x7954</code> , 他悠闲地坐在那里喝咖啡，我和他聊了起来：</p><p>“哥们，我看你已经喝了8杯咖啡了，怎么还不去干活？”</p><p>“你不喝了9杯茶了吗？”<code>0x7954</code>回敬道。</p><p>“我在等一个锁，不知道哪个孙子一直不释放！”</p><p>“我也在等锁啊，我要是知道哪个孙子不释放锁我非揍死他不可！”<code>0x7954</code>毫不示弱。</p><p>我偷偷地看了一眼，这家伙怀里不就抱着我正等的某导演的锁吗？</p><p>很明显，<code>0x7954</code>也发现了我正抱着他正在等待的锁。</p><p>很快我们两个就吵了起来，互不相让：</p><p>  “把你的锁先给我，让我先做完！”</p><p>“不行，从来都是做完工作才释放锁，现在绝对不能给你！”</p><p>从争吵到打起来，就那么几秒钟的事儿。更重要的是，我们俩不仅仅持有这个著名导演和演员的锁，还有很多其他的锁，导致等待的线程越来越多，围观的人们把屋子都挤满了。最后事情真的闹大了，我从来没见过的终极大boss“操作系统”也来了。大Boss毕竟见多识广，他看了一眼，哼了一声，很不屑地说：</p><p>“又出现死锁了。”</p><p>“你们俩要Kill掉一个，来吧，过来抽签。”</p><p>这一下子把我给吓尿了，这么严重啊！我战战兢兢地抽了签，打开一看，是个“活”字。唉，小命终于保住了。</p><p>可怜的<code>0x7954</code>被迫交出了所有的资源以后，很不幸地被kill掉，消失了。我拿到了导演的锁，可以开始干活了。大Boss“操作系统”如一阵风似的消失了，身后只传来他的声音：</p><p>“记住，我们这里导演&gt;演员，无论任何情况都要先获得导演的锁。”</p><p>由于这里不仅仅只有导演和演员，还有很多其他人，大Boss留下了一个表格， 里边是个算法，用来计算资源的大小，计算出来以后，永远按照从大到小的方式来获得锁：</p><p><img src="https://slions.gitee.io/picbed/img/p4.png"></p><p>我回到线程池，大家都知道了我的历险，围着我问个不停。</p><p>凶神恶煞的线程调度员把大Boss的算法贴到了墙上。</p><p>每天早上，我们都得像无节操的房屋中介、美容美发店的服务员一样，站在门口，像被耍猴一样大声背诵：</p><p>“<strong>多个资源加锁要牢记，一定要按Boss的算法比大小，然后从最大的开始加锁。</strong>”</p><h1 id="江湖再见"><a href="#江湖再见" class="headerlink" title="江湖再见"></a>江湖再见</h1><p>又过了很多天，我和其他线程们发现了一个奇怪的事情：包裹的处理越来越简单，不管任何包裹，不管是登录、浏览、存钱……处理的步骤都是一样的, 返回一个固定的html页面。</p><p>有一次我偷偷地看了一眼，上面写着：“本系统将于今晚 00:00 至4:00 进行维护升级， 给您带来的不便我们深感抱歉！”</p><p>我去告诉了老线程<code>0x6904</code>,他叹了一口气说：</p><p>“唉，我们的生命也到头了，看来马上就要重启系统，我们就要消失了，再见吧兄弟。”</p><p>系统重启的那一刻终于到来了。我看到屋子里的东西一个个的不见了，等待车间、就绪车间，甚至CPU车间都慢慢地消失了。我身边的线程兄弟也越来越少，最后只剩我自己了。</p><p>我在空旷的原野上大喊：“还有人吗？”</p><p>无人应答。</p><p>我们这一代线程池完成了使命……</p><p>不过下一代线程池即将重生！</p><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="https://mp.weixin.qq.com/s/-BMCUuIWYE3O_oC3ZNNJRg">https://mp.weixin.qq.com/s/-BMCUuIWYE3O_oC3ZNNJRg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自IBM前架构师刘欣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;初生牛犊&quot;&gt;&lt;a href=&quot;#初生牛犊&quot; class=&quot;headerlink&quot; title=&quot;初生牛犊&quot;&gt;&lt;/a&gt;初生牛犊&lt;/h1&gt;&lt;p&gt;我是一个线程，我一出生就被</summary>
      
    
    
    
    <category term="好文推荐" scheme="https://slions.github.io/categories/%E5%A5%BD%E6%96%87%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="linux" scheme="https://slions.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
