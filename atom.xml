<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://slions.github.io/atom.xml" rel="self"/>
  
  <link href="https://slions.github.io/"/>
  <updated>2021-07-11T14:19:20.159Z</updated>
  <id>https://slions.github.io/</id>
  
  <author>
    <name>Jingyu Shi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Centos镜像那么小能用么？</title>
    <link href="https://slions.github.io/2021/07/11/Centos%E9%95%9C%E5%83%8F%E9%82%A3%E4%B9%88%E5%B0%8F%E8%83%BD%E7%94%A8%E4%B9%88%EF%BC%9F/"/>
    <id>https://slions.github.io/2021/07/11/Centos%E9%95%9C%E5%83%8F%E9%82%A3%E4%B9%88%E5%B0%8F%E8%83%BD%E7%94%A8%E4%B9%88%EF%BC%9F/</id>
    <published>2021-07-11T13:20:06.000Z</published>
    <updated>2021-07-11T14:19:20.159Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家在使用docker的过程中有没有过这种困惑，就是下载了个centos镜像，可以看到只有200多M,这和我们之前使用传统方式启一个centos系统动不动4、5个G简直有天壤之别，这么小能运行么，稳定么？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              4cdc5dd7eaad        4 days ago          133MB</span><br><span class="line">tomcat              latest              36ef696ea43d        8 days ago          667MB</span><br><span class="line">ubuntu              latest              9873176a8ff5        3 weeks ago         72.7MB</span><br><span class="line">busybox             latest              69593048aa3a        4 weeks ago         1.24MB</span><br><span class="line">centos              7                   8652b9f0cb4c        7 months ago        204MB</span><br><span class="line">[root@slions_pc1 ~]# docker run -it --name slions centos:7</span><br><span class="line">[root@1633937d7a61 /]# ls /</span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之前我也不是很了解这块，最近又系统的看了下docker的机制，接下来就来说说Centos镜像为啥这么小。</p><p>Linux操作系统由2部分构成的，bootfs（kernel空间）和rootfs(用户空间)。</p><p>Linux启动时会加载bootfs文件系统，之后bootfs就会被卸载掉，rootfs用户空间包括了/dev,/proc,/bin…..</p><p>换句话说，bootfs就是在主机中加载下内核和物理机共用的，并不属于容器的一个部分，对于base镜像来说底层直接使用主机的kernel就够了，自己只需要提供一个rootfs就行了。对于一个精简版的OS来说，rootfs可以非常小，只需包括最基本的命令，工具还有程序的库就可以完成了。</p><p>我们可以再看下centos:7由那几层构成的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# docker history --no-trunc centos:7</span><br><span class="line">IMAGE                                                                     CREATED             CREATED BY                                                                                                                                                                                                                                                                                                                                                                                                  SIZE                COMMENT</span><br><span class="line">sha256:8652b9f0cb4c0599575e5a003f5906876e10c1ceb2ab9fe1786712dac14a50cf   7 months ago        /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]                                                                                                                                                                                                                                                                                                                                                                        0B</span><br><span class="line">&lt;missing&gt;                                                                 7 months ago        /bin/sh -c #(nop)  LABEL org.label-schema.schema-version=1.0 org.label-schema.name=CentOS Base Image org.label-schema.vendor=CentOS org.label-schema.license=GPLv2 org.label-schema.build-date=20201113 org.opencontainers.image.title=CentOS Base Image org.opencontainers.image.vendor=CentOS org.opencontainers.image.licenses=GPL-2.0-only org.opencontainers.image.created=2020-11-13 00:00:00+00:00   0B</span><br><span class="line">&lt;missing&gt;                                                                 7 months ago        /bin/sh -c #(nop) ADD file:b3ebbe8bd304723d43b7b44a6d990cd657b63d93d6a2a9293983a30bfc1dfa53 in /                                                                                                                                                                                                                                                                                                            204MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实不同的Linux发行版本主要的区别就在rootfs上，与内核的区别不大，所以docker可以同时支持多种Linux镜像，来模拟出多种操作系统的环境。</p><p>需要注意的是docker容器的内核版本会与当前主机的内核版本一致，并且不能修改，如果存在软件对内核版本有依赖就不推荐使用docker部署。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道大家在使用docker的过程中有没有过这种困惑，就是下载了个centos镜像，可以看到只有200多M,这和我们之前使用传统方式启一个centos系统动不动4、5个G简直有天壤之别，这么小能运行么，稳定么？&lt;/p&gt;
&lt;figure class=&quot;highlight sh</summary>
      
    
    
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>浅谈docker框架</title>
    <link href="https://slions.github.io/2021/07/11/%E6%B5%85%E8%B0%88docker%E6%A1%86%E6%9E%B6/"/>
    <id>https://slions.github.io/2021/07/11/%E6%B5%85%E8%B0%88docker%E6%A1%86%E6%9E%B6/</id>
    <published>2021-07-11T06:37:14.000Z</published>
    <updated>2021-07-11T15:38:27.034Z</updated>
    
    <content type="html"><![CDATA[<p>如果你之前使用过docker应该发现其并不难，把所谓的三大核心“镜像”，“容器”，“仓库”掌握了就能满足日常工作中的大多数应用内容。但如果想要更深入些了解docker,就需要熟悉下docker的框架结构，正巧前段时间同组大佬通过docker源码来分享了一波学习心得，也使得我对docker的理解更深了些，下面来一起分析下docker的框架结构。</p><h1 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h1><p>在我的本地环境执行docker version，会发现里面有client端与server端，证明docker是一个C/S模式的架构。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@kubemaster ~]# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           19.03.4</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.12.10</span><br><span class="line"> Git commit:        9013bf583a</span><br><span class="line"> Built:             Fri Oct 18 15:52:22 2019</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          19.03.4</span><br><span class="line">  API version:      1.40 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.12.10</span><br><span class="line">  Git commit:       9013bf583a</span><br><span class="line">  Built:            Fri Oct 18 15:50:54 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.3.7</span><br><span class="line">  GitCommit:        8fba4e9a7d01810a393d5d25a3621dc101981175</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc10</span><br><span class="line">  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.18.0</span><br><span class="line">  GitCommit:        fec3683</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般来说我们可以把client端与server端分开，默认情况它们通过API进行连接。修改<code>/usr/lib/systemd/system/docker.service</code>,在<code>ExecStart</code>处添加<code> -H 0.0.0.0:31375</code>,让docker服务端来监听主机下的31375端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# cat /usr/lib/systemd/system/docker.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">BindsTo=containerd.service</span><br><span class="line">After=network-online.target firewalld.service containerd.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=docker.socket</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"><span class="meta">#</span><span class="bash"> the default is not to use systemd <span class="keyword">for</span> cgroups because the delegate issues still</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> exists and systemd currently does not support the cgroup feature <span class="built_in">set</span> required</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> containers run by docker</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H 0.0.0.0:31375</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that StartLimit* options were moved from <span class="string">&quot;Service&quot;</span> to <span class="string">&quot;Unit&quot;</span> <span class="keyword">in</span> systemd 229.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Both the old, and new location are accepted by systemd 229 and up, so using the old location</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to make them work <span class="keyword">for</span> either version of systemd.</span></span><br><span class="line">StartLimitBurst=3</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that StartLimitInterval was renamed to StartLimitIntervalSec <span class="keyword">in</span> systemd 230.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Both the old, and new name are accepted by systemd 230 and up, so using the old name to make</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this option work <span class="keyword">for</span> either version of systemd.</span></span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> the kernel. We recommend using cgroups to <span class="keyword">do</span> container-local accounting.</span></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Comment TasksMax <span class="keyword">if</span> your systemd version does not supports it.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Only systemd 226 and above support this option.</span></span><br><span class="line">TasksMax=infinity</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> delegate yes so that systemd does not reset the cgroups of docker containers</span></span><br><span class="line">Delegate=yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">kill</span> only the docker process, not all processes <span class="keyword">in</span> the cgroup</span></span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>修改好后我们重启服务，此时docker成功监听在31375端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# systemctl daemon-reload</span><br><span class="line">[root@slions_pc1 ~]# systemctl restart docker</span><br><span class="line">[root@slions_pc1 ~]# ss -lntp|grep docker</span><br><span class="line">LISTEN     0      128         :::31375                   :::*                   users:((&quot;dockerd&quot;,pid=10808,fd=3))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时客户端通过指明连接的docker server地址，即可查看对应服务端的镜像情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# docker -H 192.168.100.10:31375 images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat              latest              36ef696ea43d        8 days ago          667MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们知道了docker是c/s模式架构后，下面来细致化的讲解下架构模块。</p><h1 id="docker架构图"><a href="#docker架构图" class="headerlink" title="docker架构图"></a>docker架构图</h1><p><img src="/doc_picture/docker_jg1.png" alt="img"></p><p>大致的流程可概况为：</p><ol><li>用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</li><li>Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；</li><li>Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</li><li>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；</li><li>当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；</li><li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。</li><li>libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</li></ol><h1 id="模块组件分析"><a href="#模块组件分析" class="headerlink" title="模块组件分析"></a>模块组件分析</h1><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>client是docker架构中与daemon建立通讯联系的客户端。用户可以通过docker可执行文件向docker daemon发送请求管理容器。</p><p>Docker Client可以通过以下三种方式和Docker Daemon建立通信：tcp://host:port，unix://path_to_socket和fd://socketfd。</p><p>Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。</p><h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>docker daemon是docker的常驻进程，主要作用是接收并分发client请求和管理所有容器。</p><p>docker daemon有三驾马车一个是<code>server</code>,一个是 <code>engine</code>,一个是 <code>job</code>。</p><p><img src="/doc_picture/docker_jg2.png" alt="img"></p><ul><li><strong>docker server：</strong><ol><li>Docker Server相当于C/S架构的服务端。功能为接受并调度分发Docker Client发送的请求。接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。</li><li>Docker的启动过程中,会创建了一个mux.Router，提供请求的路由功能。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。</li><li>在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。</li></ol></li></ul><p><img src="/doc_picture/docker_jg3.png" alt="img"></p><ul><li><p><strong>Engine</strong></p><ol><li>Engine是Docke的运行引擎，同时也是Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。</li><li>在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。</li></ol></li><li><p><strong>job</strong></p><p>​    一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。</p></li></ul><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>Docker Registry就是镜像注册中心，用户如果不进行配置的话默认的地址是dokcerhub地址，这个大家应该都知道。</p><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><p><img src="/doc_picture/docker_jg4.png" alt="img"></p><ul><li><p><strong>Repository</strong></p><ol><li>已下载镜像的保管者（包括下载镜像和dockerfile构建的镜像）。</li><li>镜像的存储类型有aufs，devicemapper,Btrfs，overlay2等。docker info中的<code>Storage Driver</code></li><li>同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</li></ol></li><li><p><strong>GraphDB</strong></p><p>​    已下载容器镜像之间对应关系的记录者。</p></li></ul><h2 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h2><p>Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。即<u>Graph负责镜像的存储，Driver负责容器的执行。</u></p><ul><li><strong>graphdriver</strong><ol><li>graphdriver主要用于完成容器镜像的管理，包括存储与获取。值得注意的地方是，不同文件系统的存储驱动器也不相同，比如redhat系的操作系统使用的是overlay2，通过xfs文件系统来管理；如果是Ubuntu则使用的是aufs;如果是suse则是btrfs。建议不要修改默认的docker storage driver，跟随系统默认。</li><li>存储：docker pull下载的镜像由graphdriver存储到本地的指定目录（Graph中）。</li><li>获取：docker run（create）用镜像来创建容器的时候由graphdriver到本地Graph中获取镜像。</li></ol></li></ul><p><img src="/doc_picture/docker_jg5.png" alt="img"></p><ul><li><p><strong>networkdriver</strong></p><p>networkdriver的用途是完成Docker容器网络环境的配置，其中包括</p><ol><li>Docker启动时为Docker环境创建网桥；</li><li>Docker容器创建时为其创建专属虚拟网卡设备；</li><li>Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。</li></ol></li></ul><p><img src="/doc_picture/docker_jg6.png" alt="img"></p><ul><li><strong>execdriver</strong><ol><li>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。</li><li>现在execdriver默认使用native驱动，不依赖于LXC。</li></ol></li></ul><p><img src="/doc_picture/docker_jg7.png" alt="img"></p><h2 id="libcontainer"><a href="#libcontainer" class="headerlink" title="libcontainer"></a>libcontainer</h2><p>libcontainer是golang编写的第三方库，主要封装了一些linux内核与容器相关的API；因为屏蔽了所有内核操作，保证了容器与底层的松耦合性</p><p>Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。</p><p><img src="/doc_picture/docker_jg8.png" alt="img"></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>《Docker源码分析》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你之前使用过docker应该发现其并不难，把所谓的三大核心“镜像”，“容器”，“仓库”掌握了就能满足日常工作中的大多数应用内容。但如果想要更深入些了解docker,就需要熟悉下docker的框架结构，正巧前段时间同组大佬通过docker源码来分享了一波学习心得，也使得我</summary>
      
    
    
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Cgroup</title>
    <link href="https://slions.github.io/2021/07/10/%E8%81%8A%E8%81%8ACgroup/"/>
    <id>https://slions.github.io/2021/07/10/%E8%81%8A%E8%81%8ACgroup/</id>
    <published>2021-07-10T10:32:32.000Z</published>
    <updated>2021-07-11T06:35:02.823Z</updated>
    
    <content type="html"><![CDATA[<p>此前已经聊了容器隔离技术<code>namespace</code>,这次我们接着来看看如何来限制容器的资源。</p><h1 id="什么是Cgroup"><a href="#什么是Cgroup" class="headerlink" title="什么是Cgroup"></a>什么是Cgroup</h1><p>容器的资源限制是通过Cgroup实现的，Cgroups 的全称是 Control Group，属于linux内核提供的一个特性，它最主要的作用就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</p><p>此外，Cgroups 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。</p><p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，默认linux系统在启动时已经挂载到了 /sys/fs/cgroup 路径下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent=/usr/lib/systemd/systemd-cgroups                                              -agent,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,blkio)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="查看Cgroup"><a href="#查看Cgroup" class="headerlink" title="查看Cgroup"></a>查看Cgroup</h1><p>可以看到，在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些都是我这台机器当前可以被 Cgroups 进行限制的资源种类。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ls /sys/fs/cgroup/</span><br><span class="line">blkio  cpu  cpuacct  cpu,cpuacct  cpuset  devices  freezer  hugetlb  memory  net_cls  net_cls,net_prio  net_prio  perf_event  pids  systemd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。</p><h1 id="Cgroup子系统"><a href="#Cgroup子系统" class="headerlink" title="Cgroup子系统"></a>Cgroup子系统</h1><p>对实际资源的分配和管理是由各个Cgroup子系统来完成的。</p><h2 id="cpuset子系统"><a href="#cpuset子系统" class="headerlink" title="cpuset子系统"></a>cpuset子系统</h2><p>cpuset可以为一组进程分配指定的CPU和内存节点。</p><p>主要的接口有：</p><ul><li>cpuset.cpus: 允许进程使用的CPU列表</li><li>cpuset.mems: 允许进程使用的内存节点列表</li></ul><h2 id="cpu子系统"><a href="#cpu子系统" class="headerlink" title="cpu子系统"></a>cpu子系统</h2><p>cpu子系统用于限制进程的CPU占用率。</p><p>主要的接口有：</p><ul><li>cpu.shares：CPU比重分配</li><li>cpu.cfs_period_us和cpu.cfs_quota_us：CPU带宽限制(微秒)</li><li>cpu.rt_period_us和cpu.rt.runtime_us：实时进程的CPU带宽限制</li></ul><h2 id="cpuacct子系统"><a href="#cpuacct子系统" class="headerlink" title="cpuacct子系统"></a>cpuacct子系统</h2><p>cpuacct子系统用来统计各Cgroup的CPU使用情况。</p><ul><li>cpuacct.stat: 报告这个Cgroup分别在用户态和内核态消耗的CPU时间（USER_HZ）</li><li>cpuacct.usage: 报告这个Cgroup消耗的总CPU时间</li><li>cpuacct.usage_percpu: 报告这个Cgroup在各CPU上消耗的CPU时间</li></ul><h2 id="memory子系统"><a href="#memory子系统" class="headerlink" title="memory子系统"></a>memory子系统</h2><p>memory子系统用来限制Cgroup所使用的内存上限。</p><ul><li>memory.limit_in_bytes：内存上限</li><li>memory.memsw.limit_in_bytes：内存+swap上限</li><li>memory.oom_control：设置为0则当内存使用量超过上限时系统不会杀死进程，而是阻塞进程直到有内存被释放</li><li>memory.stat： 汇报内存使用情况</li></ul><h2 id="blkio子系统"><a href="#blkio子系统" class="headerlink" title="blkio子系统"></a>blkio子系统</h2><p>blkio子系统用来限制Cgroup的block I/O带宽。</p><ul><li><p>blkio.weight: 设置权重</p></li><li><p>blkio.weight_device：对具体的设备设置权重</p></li><li><p>blkio.throttle.write_bps_device：对具体的设备设置每秒写磁盘的带宽上限</p></li><li><p>blkio.throttle.read_bps_device: 对具体的设备设置每秒读磁盘的带宽上限</p></li></ul><h2 id="device子系统"><a href="#device子系统" class="headerlink" title="device子系统"></a>device子系统</h2><p>用来控制Cgroup的进程对那些设备有访问权限。</p><ul><li><p>devices.list：只读文件，显示目前允许被访问的设备列表</p></li><li><p>devices.deny：只写文件，允许相应的设备访问权限</p></li><li><p>devices.allow：只写文件，禁止相应的设备访问权限</p></li></ul><h1 id="如何限制资源"><a href="#如何限制资源" class="headerlink" title="如何限制资源"></a>如何限制资源</h1><p>介绍了那么多Cgroup的概念，我们下面就拿限制cpu使用率为例，来讲讲如何限制这些资源。</p><p>首先本地下载用来设置Cgroup的工具包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# yum install  libcgroup-tools.x86_64 -y</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来通过cgcreate命令来创建一个自己的控制组slions。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 cpu]# cgcreate -g cpu:slions</span><br><span class="line">[root@slions_pc1 cpu]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 cgroup.clone_children</span><br><span class="line">--w--w--w-.  1 root root 0 7月   9 14:54 cgroup.event_control</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 cgroup.procs</span><br><span class="line">-r--r--r--.  1 root root 0 7月   9 14:54 cgroup.sane_behavior</span><br><span class="line">-r--r--r--.  1 root root 0 7月   9 14:54 cpuacct.stat</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 cpuacct.usage</span><br><span class="line">-r--r--r--.  1 root root 0 7月   9 14:54 cpuacct.usage_percpu</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 cpu.cfs_period_us</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 cpu.cfs_quota_us</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 cpu.rt_period_us</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 cpu.rt_runtime_us</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 cpu.shares</span><br><span class="line">-r--r--r--.  1 root root 0 7月   9 14:54 cpu.stat</span><br><span class="line">drwxr-xr-x.  3 root root 0 7月  10 12:34 docker</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 notify_on_release</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 release_agent</span><br><span class="line">drwxr-xr-x.  2 root root 0 7月  10 21:50 slions</span><br><span class="line">drwxr-xr-x. 69 root root 0 7月  10 12:04 system.slice</span><br><span class="line">-rw-r--r--.  1 root root 0 7月   9 14:54 tasks</span><br><span class="line">drwxr-xr-x.  2 root root 0 7月  10 11:52 user.slice</span><br><span class="line">[root@slions_pc1 cpu]# ll slions/</span><br><span class="line">总用量 0</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 cgroup.clone_children</span><br><span class="line">--w--w----. 1 root root 0 7月  10 21:50 cgroup.event_control</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 cgroup.procs</span><br><span class="line">-r--r--r--. 1 root root 0 7月  10 21:50 cpuacct.stat</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 cpuacct.usage</span><br><span class="line">-r--r--r--. 1 root root 0 7月  10 21:50 cpuacct.usage_percpu</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 cpu.cfs_period_us</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 cpu.cfs_quota_us</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 cpu.rt_period_us</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 cpu.rt_runtime_us</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 cpu.shares</span><br><span class="line">-r--r--r--. 1 root root 0 7月  10 21:50 cpu.stat</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 notify_on_release</span><br><span class="line">-rw-rw-r--. 1 root root 0 7月  10 21:50 tasks</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>会发现/sys/fs/cgroup/cpu目录下已经多了一个slions的目录，并且自动创建了一些文件，其中task文件就是记录进程pid的地方，换句话说，只要是在此task中的进程都会被此控制组所限制。</p><p>接着写一个死循环后台跑着，获得进程号为44577，执行top看到cpu使用率为100%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 cpu]# while :;do :;done &amp;</span><br><span class="line">[1] 44577</span><br><span class="line">[root@slions_pc1 ~]# top -p 44577</span><br><span class="line">top - 22:00:31 up 10:35,  3 users,  load average: 0.78, 0.27, 0.13</span><br><span class="line">Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s): 50.1 us,  0.0 sy,  0.0 ni, 49.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  3861520 total,  1600076 free,   391708 used,  1869736 buff/cache</span><br><span class="line">KiB Swap:  1044476 total,  1044476 free,        0 used.  3067128 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 44577 root      20   0  116296   1284    132 R   100  0.0   1:33.98 bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们把此进程号写入slions/tasks中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 cpu]# echo 44577 &gt; slions/tasks</span><br><span class="line">[root@slions_pc1 cpu]# cat slions/tasks</span><br><span class="line">44577</span><br><span class="line">[root@slions_pc1 cpu]# top -p 44577</span><br><span class="line">top - 22:05:02 up 10:39,  3 users,  load average: 0.99, 0.69, 0.35</span><br><span class="line">Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s): 50.2 us,  0.2 sy,  0.0 ni, 49.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  3861520 total,  1598680 free,   393096 used,  1869744 buff/cache</span><br><span class="line">KiB Swap:  1044476 total,  1044476 free,        0 used.  3065736 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 44577 root      20   0  116296   1284    132 R  99.7  0.0   6:04.97 bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>没有变化，这是因为默认没有任何限制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 cpu]# cat slions/cpu.cfs_quota_us</span><br><span class="line">-1</span><br><span class="line">[root@slions_pc1 cpu]# cat slions/cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们可以通过修改这些文件的内容来设置限制。</p><p>向 slions组里的 cfs_quota_us 文件写入 30 ms（30000 us），它意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 30 ms 的 CPU 时间，也就是说这个进程只能使用到 30% 的 CPU 带宽。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 cpu]# echo 30000 &gt; slions/cpu.cfs_quota_us</span><br><span class="line">[root@slions_pc1 cpu]# top -p 44577</span><br><span class="line">top - 22:18:53 up 10:53,  3 users,  load average: 0.34, 0.79, 0.67</span><br><span class="line">Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s): 15.0 us,  0.0 sy,  0.0 ni, 85.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  3861520 total,  1599448 free,   392324 used,  1869748 buff/cache</span><br><span class="line">KiB Swap:  1044476 total,  1044476 free,        0 used.  3066508 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 44577 root      20   0  116296   1284    132 R  30.0  0.0  18:50.61 bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以再起一个死循环进程，并且放入slions控制组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 cpu]# while :;do :;done &amp;</span><br><span class="line">[2] 44658</span><br><span class="line">[root@slions_pc1 cpu]# echo 44658 &gt;&gt; slions/tasks</span><br><span class="line">[root@slions_pc1 cpu]# cat slions/tasks</span><br><span class="line">44577</span><br><span class="line">44658</span><br><span class="line">[root@slions_pc1 cpu]#top</span><br><span class="line">top - 22:22:49 up 10:57,  3 users,  load average: 0.08, 0.43, 0.55</span><br><span class="line">Tasks: 129 total,   3 running, 126 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s): 15.3 us,  0.2 sy,  0.0 ni, 84.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  3861520 total,  1598784 free,   393092 used,  1869644 buff/cache</span><br><span class="line">KiB Swap:  1044476 total,  1044476 free,        0 used.  3065852 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 44577 root      20   0  116296   1284    132 R  15.3  0.0  19:45.59 bash</span><br><span class="line"> 44658 root      20   0  116296   1464    312 R  15.3  0.0   0:42.83 bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，这两个进程各占了15%，加起来正好是我们的cfs_quota_us 限制。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此前已经聊了容器隔离技术&lt;code&gt;namespace&lt;/code&gt;,这次我们接着来看看如何来限制容器的资源。&lt;/p&gt;
&lt;h1 id=&quot;什么是Cgroup&quot;&gt;&lt;a href=&quot;#什么是Cgroup&quot; class=&quot;headerlink&quot; title=&quot;什么是Cgroup&quot;&gt;</summary>
      
    
    
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>大话docker</title>
    <link href="https://slions.github.io/2021/07/09/%E5%A4%A7%E8%AF%9Ddocker/"/>
    <id>https://slions.github.io/2021/07/09/%E5%A4%A7%E8%AF%9Ddocker/</id>
    <published>2021-07-09T09:10:41.000Z</published>
    <updated>2021-07-10T11:30:46.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="唠唠背景"><a href="#唠唠背景" class="headerlink" title="唠唠背景"></a>唠唠背景</h1><p>自我工作以来就一直听到周围人在谈docker和容器，记得真正第一次接触docker是17年在上海，我当时被外派到某大型外资硬件提供商做云计算工程师， 主要做的工作就是负责维护原有的openstack云平台和ceph集群，以及日常服务器的一些上下架和维护工作。因为我之前的项目中openstack都是以传统服务来部署的，日常运维什么的基本没啥问题，而这次面对的环境是容器化后的openstack(kolla实现)，也算是逼自己要好好看看docker这块儿的东西了，当时九州云属于kolla项目的主要贡献者，也和我们有很多合作关系，所以期间有很多不太理解的地方也是请教了相关的几位大佬。</p><p>18年离开了上海，入职了北京某家金融领域解决方案提供商，主要做的也一直是容器化相关的事，从docker到k8s，从慢慢摸索到推出适合本公司产品的定制化容器云平台，期间我会有很多时候需要向甲方以及公司同事介绍我们在做的事儿，以及用到的技术、行业的现状等等，借着最近时间充裕，打算写一篇关于介绍docker的文章，如果有幸被您看到，也请提出宝贵的意见，十分感谢。</p><blockquote><p>以下内容多属于普及性文字，不会涉及太多技术点，如果有时间会抽专门的章节来具体阐述。</p></blockquote><h1 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h1><blockquote><p>纵观整个IT界历史长河，一个新兴技术能够火爆与当时的市场痛点是息息相关的，就比如当初如日中天的AWS和Openstack提供了云计算的模式，使得万物云化，资源按需使用，大大的提高了服务器的资源利用率，降低了人力物力的成本。慢慢的人们发现，当申请好一批虚拟机后，通过手工或者自动化脚本部署自己的应用时会出现各种奇奇怪怪的问题，因为本地环境与云端虚拟机环境不一致，所以导致了大量的排错过程。后面PaaS理念的一经提出（应用托管），赢得了广大开发者的关注，而docker项目的发布为应用打包问题提供了一份近乎完美的解决方案。</p></blockquote><h2 id="容器与操作系统"><a href="#容器与操作系统" class="headerlink" title="容器与操作系统"></a>容器与操作系统</h2><p>我们经常把容器叫做docker,但其实容器还有coreOS的rkt。在介绍容器前，大家可以先想想操作系统是如何管理进程的，我们登录到一个操作系统内执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps -elf</span> </span><br></pre></td></tr></table></figure><p>可以看到各种进程，这些进程包括了系统自带的和用户部署的，并且进程间可以互相看到，也可以互相通信，这些进程共享着同一份的文件系统，意味着他们可以操作同一份文件，最后他们还使用着同样的系统资源。</p><p>上述这些特点会产生一系列的问题：</p><ul><li>具有高级权限的进程可以攻击其他进程</li><li>具有高级权限的进程可以对其他进程所需的文件增删改查</li><li>应用之间会存在资源争抢问题</li></ul><p>容器本质上是把系统中为同一个业务目标服务的相关进程合成一组，放在一个叫做<strong>namespace</strong>的空间中，同一个namespace中的进程能够互相通信，但看不见其他namespace中的进程。每个namespace可以拥有自己独立的主机名、进程ID系统、IPC、网络、文件系统、用户等等资源。使得容器这个父进程只对自己的子进程有感知，而对于宿主机其他进程互不感知。</p><p>linux提供了<strong>chroot</strong>的系统调用方式可以把一个子目录变为根目录，容器会在chroot的帮助下获得一个独立的文件系统，这样进程对文件系统的增删改查都不会影响到其他进程的使用。</p><p>此外，为了限制namespace对物理资源的使用，对进程能使用的CPU、内存、io等资源需要做一定的限制。这就是<strong>Cgroup</strong>技术。</p><p><strong>总结：</strong></p><p><strong>基于传统应用部署方式的痛点，docker通过linux的namespaces实现了资源视图的隔离，通过chroot来提供独立的文件系统，通过cgroup控制资源使用率。</strong></p><h2 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h2><p>提容器不得不提虚拟机，他们都是为应用提供封装和隔离的。</p><ul><li>虚拟化层：虚拟机有Hypervisor层和GuestOS，Docker省去了Hypervisor，其虚拟化技术是基于内核的Cgroup和Namespace技术，Docker通过libcontainer与内核交互，所以在很多方面，它的性能与物理机非常接近。</li><li>启动速度：docker启动快速属于秒级别。虚拟机通常需要几分钟去启动。</li><li>隔离性：docker属于进程之间的隔离，那么多个容器还是使用着同一个操作系统内核，所以docker的隔离性更弱，虚拟机可实现系统级别隔离。</li><li>迭代：虚拟机可以通过导出模板实现环境交付的一致性，但镜像分发无法体系化；Docker在Dockerfile中记录了容器构建过程，可在集群中实现快速分发和快速部署，快速回滚。</li><li>系统支持量：同样配置的服务器支持的容器数是虚拟机的十倍以上。</li></ul><p><img src="/doc_picture/docker-1.png" alt="image-20210709184759385"></p><h1 id="docker的优势"><a href="#docker的优势" class="headerlink" title="docker的优势"></a>docker的优势</h1><ul><li>更快速的交付和部署；开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来 部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员 更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约 开发、测试、部署的时间。</li><li>更高效的虚拟化；不需要额外的hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。</li><li>更轻松的迁移和扩展；Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、云平台、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。 </li><li>更简单的管理；使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和 更新，从而实现自动化并且高效的管理。 </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;唠唠背景&quot;&gt;&lt;a href=&quot;#唠唠背景&quot; class=&quot;headerlink&quot; title=&quot;唠唠背景&quot;&gt;&lt;/a&gt;唠唠背景&lt;/h1&gt;&lt;p&gt;自我工作以来就一直听到周围人在谈docker和容器，记得真正第一次接触docker是17年在上海，我当时被外派到某大型外资硬</summary>
      
    
    
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>安装docker</title>
    <link href="https://slions.github.io/2021/07/09/%E5%AE%89%E8%A3%85docker/"/>
    <id>https://slions.github.io/2021/07/09/%E5%AE%89%E8%A3%85docker/</id>
    <published>2021-07-09T06:52:04.000Z</published>
    <updated>2021-07-10T10:50:40.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有网环境"><a href="#有网环境" class="headerlink" title="有网环境"></a>有网环境</h1><p>可联网的情况下，可以选择直接通过yum来安装指定版本的docker。</p><h2 id="验证环境"><a href="#验证环境" class="headerlink" title="验证环境"></a>验证环境</h2><p>当前我的环境可以联网，并且没有安装任何与docker有关的软件包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (220.181.38.150) 56(84) bytes of data.</span><br><span class="line">64 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=1 ttl=128 time=6.33 ms</span><br><span class="line">64 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=2 ttl=128 time=6.26 ms</span><br><span class="line">64 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=3 ttl=128 time=5.65 ms</span><br><span class="line">64 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=4 ttl=128 time=6.24 ms</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3007ms</span><br><span class="line">rtt min/avg/max/mdev = 5.656/6.125/6.333/0.272 ms</span><br><span class="line">[root@slions_pc1 ~]# yum list installed|grep docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装相关工具和配置"><a href="#安装相关工具和配置" class="headerlink" title="安装相关工具和配置"></a>安装相关工具和配置</h2><p>安装管理repository及扩展包的工具并添加阿里docker源 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# yum install yum-utils -y &amp;&amp; yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# yum makecache</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.163.com</span><br><span class="line"> * extras: mirrors.huaweicloud.com</span><br><span class="line"> * updates: mirrors.huaweicloud.com</span><br><span class="line">base                                                                                                                                                              | 3.6 kB  00:00:00</span><br><span class="line">docker-ce-stable                                                                                                                                                  | 3.5 kB  00:00:00</span><br><span class="line">extras                                                                                                                                                            | 2.9 kB  00:00:00</span><br><span class="line">updates                                                                                                                                                           | 2.9 kB  00:00:00</span><br><span class="line">(1/10): docker-ce-stable/7/x86_64/updateinfo                                                                                                                      |   55 B  00:00:00</span><br><span class="line">(2/10): docker-ce-stable/7/x86_64/filelists_db                                                                                                                    |  26 kB  00:00:00</span><br><span class="line">(3/10): docker-ce-stable/7/x86_64/primary_db                                                                                                                      |  62 kB  00:00:00</span><br><span class="line">(4/10): base/7/x86_64/filelists_db                                                                                                                                | 7.2 MB  00:00:00</span><br><span class="line">(5/10): docker-ce-stable/7/x86_64/other_db                                                                                                                        | 119 kB  00:00:00</span><br><span class="line">(6/10): extras/7/x86_64/other_db                                                                                                                                  | 143 kB  00:00:00</span><br><span class="line">(7/10): updates/7/x86_64/filelists_db                                                                                                                             | 5.1 MB  00:00:00</span><br><span class="line">(8/10): extras/7/x86_64/filelists_db                                                                                                                              | 235 kB  00:00:00</span><br><span class="line">(9/10): updates/7/x86_64/other_db                                                                                                                                 | 681 kB  00:00:00</span><br><span class="line">(10/10): base/7/x86_64/other_db                                                                                                                                   | 2.6 MB  00:00:02</span><br><span class="line">元数据缓存已建立</span><br></pre></td></tr></table></figure><p>查看当前可供下载的docker版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# yum list docker-ce --showduplicates | sort -r</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">可安装的软件包</span><br><span class="line"> * updates: mirrors.huaweicloud.com</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * extras: mirrors.huaweicloud.com</span><br><span class="line">docker-ce.x86_64            3:20.10.7-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.6-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.5-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.4-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.3-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.2-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.9-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.8-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.7-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.6-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.5-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.4-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.3-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.2-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.15-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.14-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.13-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.12-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.11-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.10-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.9-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.8-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.7-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.6-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.5-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.4-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.3-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.2-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.3.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.2.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.0.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.03.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.03.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.12.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.12.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.09.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.09.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h2><p>选择指定版本进行安装即可，填入版本号到下面的命令（如：docker-ce-18.09.3-3.el7）</p><blockquote><p>#yum install docker-ce- &lt;$VERSION_STRING&gt;  docker-ce-cli- &lt;$VERSION_STRING&gt;  containerd.io</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# yum install docker-ce-18.09.3-3.el7 docker-ce-cli-18.09.3-3.el7 containerd.io -y</span><br></pre></td></tr></table></figure><h1 id="无网环境"><a href="#无网环境" class="headerlink" title="无网环境"></a>无网环境</h1><p>无网的环境下，最简单的方式是我们提前将指定版本的docker包下载到本地，后续传到机器上解压，将可执行命令移动到软件运行目录即可</p><p>docker二进制包地址： <a href="https://download.docker.com/linux/static/stable/x86_64/">https://download.docker.com/linux/static/stable/x86_64/</a></p><h2 id="下载二进制包"><a href="#下载二进制包" class="headerlink" title="下载二进制包"></a>下载二进制包</h2><p>比如我们想安装18.09.3版本的docker,则提前下载到本地</p><p><img src="/doc_picture/docker-tar1.png" alt="image-20210709154417198"></p><h2 id="上传和配置"><a href="#上传和配置" class="headerlink" title="上传和配置"></a>上传和配置</h2><p>将软件包上传于所需机器的任意目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# pwd</span><br><span class="line">/root</span><br><span class="line">[root@slions_pc1 ~]# ls</span><br><span class="line">anaconda-ks.cfg  docker-18.09.3.tgz</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解压此压缩包，并将可执行文件都拷贝到程序执行目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# tar zxvf docker-18.09.3.tgz</span><br><span class="line">docker/</span><br><span class="line">docker/ctr</span><br><span class="line">docker/containerd-shim</span><br><span class="line">docker/containerd</span><br><span class="line">docker/docker-proxy</span><br><span class="line">docker/docker</span><br><span class="line">docker/dockerd</span><br><span class="line">docker/runc</span><br><span class="line">docker/docker-init</span><br><span class="line">[root@slions_pc1 ~]# ls</span><br><span class="line">anaconda-ks.cfg  docker  docker-18.09.3.tgz</span><br><span class="line">[root@slions_pc1 ~]# cp docker/* /usr/bin/</span><br></pre></td></tr></table></figure><p>添加docker服务启动文件即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有网环境&quot;&gt;&lt;a href=&quot;#有网环境&quot; class=&quot;headerlink&quot; title=&quot;有网环境&quot;&gt;&lt;/a&gt;有网环境&lt;/h1&gt;&lt;p&gt;可联网的情况下，可以选择直接通过yum来安装指定版本的docker。&lt;/p&gt;
&lt;h2 id=&quot;验证环境&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>聊聊namespace</title>
    <link href="https://slions.github.io/2021/07/09/%E8%81%8A%E8%81%8Anamespace/"/>
    <id>https://slions.github.io/2021/07/09/%E8%81%8A%E8%81%8Anamespace/</id>
    <published>2021-07-09T06:49:12.000Z</published>
    <updated>2021-07-10T11:03:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们谈及docker，都知道docker容器本质上是宿主机的进程，Docker通过namespace实现了资源隔离，通过cgroups实现了资源限制，接下来先聊聊namespaces是怎么一回事。</p><h1 id="namespace是什么"><a href="#namespace是什么" class="headerlink" title="namespace是什么"></a>namespace是什么</h1><blockquote><p>Namespace是将内核的全局资源做封装，使得每个namespace都有一份独立的资源，因此不同的进程在各自的namespace中对同一种资源的使用不会互相干扰。</p><p> ——摘自《Docker进阶与实战》</p></blockquote><p>举个例子，执行sethostname这个系统调用时，可以改变系统的主机名，这个主机名就是一个内核的全局资源，内核通过UTS Namespace，可以将不同的进程分隔在不同的UTS namespace中，在某个Namespace修改主机名时，另一个Namespace中的主机名还是保持不变。</p><p> 说白了docker就是通过namespace使得进程在资源视图上实现隔离，目前linux共实现了6种namespace</p><p><img src="/doc_picture/docker-2.png" alt="image-20210710005510508"></p><p>接下来进行些实验来更好的理解namespace是如何进行隔离的。</p><h1 id="namespace实验"><a href="#namespace实验" class="headerlink" title="namespace实验"></a>namespace实验</h1><p>打开一台linux服务器，我们知道进程相关的信息都会在/proc目录下，如下图，/proc下的每个数字就代表了linux系统中的一个进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ls /proc/</span><br><span class="line">1      10149  10683  11     18  26    3002  36    4317  4331  5     8035  8806  8833  9631       cmdline      fb           keys        misc          schedstat      sysvipc</span><br><span class="line">10     10150  10700  11097  19  27    3006  37    4321  4400  51    8042  8813  8836  9639       consoles     filesystems  key-users   modules       scsi           timer_list</span><br><span class="line">10019  10152  10704  11122  2   2722  3060  38    4322  4413  53    8052  8814  8864  98         cpuinfo      fs           kmsg        mounts        self           timer_stats</span><br><span class="line">10023  10164  10706  11124  20  28    3074  4271  4325  4415  66    8059  8815  8876  9926       crypto       interrupts   kpagecount  mpt           slabinfo       tty</span><br><span class="line">10025  10581  10741  12     21  29    3087  4273  4326  4423  7     8069  8816  8925  acpi       devices      iomem        kpageflags  mtrr          softirqs       uptime</span><br><span class="line">10060  10582  10865  13     22  2909  3095  4283  4327  46    8     8795  8817  9     asound     diskstats    ioports      loadavg     net           stat           version</span><br><span class="line">10093  10586  10912  14     23  2911  3099  4286  4328  47    8017  8796  8820  9407  buddyinfo  dma          irq          locks       pagetypeinfo  swaps          vmallocinfo</span><br><span class="line">10100  10588  10924  15     24  2947  3104  4307  4329  48    8024  8797  8821  9408  bus        driver       kallsyms     mdstat      partitions    sys            vmstat</span><br><span class="line">10148  10628  10940  16     25  3     35    4313  4330  49    8029  8801  8830  9411  cgroups    execdomains  kcore        meminfo     sched_debug   sysrq-trigger  zoneinfo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个数字目录下的ns目录就代表这个进程的namespace。</p><p><img src="/doc_picture/docker-4.png" alt="image-20210710121836489"></p><p>我们随便选取2个进程，查看其ns目录中的文件可以发现里面就对应着上边讲的linux 的6种namespace，每一项 namespace 都附带一个编号，这是唯一标识 namespace 的，如果两个进程指向的 namespace 编号相同，则表示它们同在该 namespace 下。可以看到进程为1和10的各种namespace编号都一样，所以它们同属一个namespace下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ll /proc/1/ns/</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 uts -&gt; uts:[4026531838]</span><br><span class="line">[root@slions_pc1 ~]# ll /proc/10/ns/</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 uts -&gt; uts:[4026531838]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我启动一个docker进行测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# docker run -d tomcat</span><br><span class="line">Unable to find image &#x27;tomcat:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/tomcat</span><br><span class="line">0bc3020d05f1: Pull complete</span><br><span class="line">a110e5871660: Pull complete</span><br><span class="line">83d3c0fa203a: Pull complete</span><br><span class="line">a8fd09c11b02: Pull complete</span><br><span class="line">96ebf1506065: Pull complete</span><br><span class="line">b8bf70f9cc4d: Pull complete</span><br><span class="line">3f6da67b9e68: Pull complete</span><br><span class="line">257407776119: Pull complete</span><br><span class="line">7bd0a187fb92: Pull complete</span><br><span class="line">307fc4df04c9: Pull complete</span><br><span class="line">Digest: sha256:a5abf192aceed45620dbb2e09f8abdec2b96108b86365a988c85e753c28cd36b</span><br><span class="line">Status: Downloaded newer image for tomcat:latest</span><br><span class="line">78192daee11695b6f2d973e4998c4f7a84b855b84f3a88ebe1ed5653d499d934</span><br><span class="line">[root@slions_pc1 ~]# ps -elf|grep [t]omcat</span><br><span class="line">4 S root      42799  42780  1  80   0 - 894104 futex_ 12:34 ?       00:00:05 /usr/local/openjdk-11/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -classpath /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure><p>查看此docker进程的namespace信息 , 对比之前宿主机进程不难看出，它们已经进行了隔离。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 ~]# ll /proc/42799/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:44 ipc -&gt; ipc:[4026532503]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:44 mnt -&gt; mnt:[4026532501]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:34 net -&gt; net:[4026532506]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:44 pid -&gt; pid:[4026532504]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:44 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:44 uts -&gt; uts:[4026532502]</span><br><span class="line">[root@slions_pc1 ~]# ll /proc/1/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 7月  10 12:01 uts -&gt; uts:[4026531838]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述实验只是验证了一个docker启动后namespace的隔离性，显然对于namespace的理解还远远不够，我们接下来再看看自己如何创建一个namespace。</p><h1 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h1><blockquote><p>对namespace的操作主要是通过clone()，setns()，unshare()来实现的。</p><p>其中clone用来创建新的进程和namespace，unshare用来为已有的进程创建namespace，而setns会将已有的进程放置到已有的namespace</p></blockquote><p>通过调用 clone()，并传入需要隔离资源对应的参数flags(包括CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWIPC、CLONE_NEWUTS、CLONE_NEWUSER、CLONE_NEWNET)，创建出的新进程就处在全新的namespace中了（隔离什么我们自己控制）。</p><p>我们先来看下clone()的用法，在机器上执行<code>man clone</code>找到例子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">EXAMPLE</span><br><span class="line">       The following program demonstrates the use of clone() to create a child process that executes in a separate UTS namespace.  The child changes the hostname in its UTS namespace.</span><br><span class="line">       Both  parent  and  child then display the system hostname, making it possible to see that the hostname differs in the UTS namespaces of the parent and child.  For an example of</span><br><span class="line">       the use of this program, see setns(2).</span><br><span class="line"></span><br><span class="line">   Program source</span><br><span class="line">       #define _GNU_SOURCE</span><br><span class="line">       #include &lt;sys/wait.h&gt;</span><br><span class="line">       #include &lt;sys/utsname.h&gt;</span><br><span class="line">       #include &lt;sched.h&gt;</span><br><span class="line">       #include &lt;string.h&gt;</span><br><span class="line">       #include &lt;stdio.h&gt;</span><br><span class="line">       #include &lt;stdlib.h&gt;</span><br><span class="line">       #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">       #define errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="line">                               &#125; while (0)</span><br><span class="line"></span><br><span class="line">       static int              /* Start function for cloned child */</span><br><span class="line">       childFunc(void *arg)</span><br><span class="line">       &#123;</span><br><span class="line">           struct utsname uts;</span><br><span class="line"></span><br><span class="line">           /* Change hostname in UTS namespace of child */</span><br><span class="line"></span><br><span class="line">           if (sethostname(arg, strlen(arg)) == -1)</span><br><span class="line">               errExit(&quot;sethostname&quot;);</span><br><span class="line"></span><br><span class="line">           /* Retrieve and display hostname */</span><br><span class="line"></span><br><span class="line">           if (uname(&amp;uts) == -1)</span><br><span class="line">               errExit(&quot;uname&quot;);</span><br><span class="line">           printf(&quot;uts.nodename in child:  %s\n&quot;, uts.nodename);</span><br><span class="line"></span><br><span class="line">           /* Keep the namespace open for a while, by sleeping.</span><br><span class="line">              This allows some experimentation--for example, another</span><br><span class="line">              process might join the namespace. */</span><br><span class="line"></span><br><span class="line">           sleep(200);</span><br><span class="line"></span><br><span class="line">           return 0;           /* Child terminates now */</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       #define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */</span><br><span class="line"></span><br><span class="line">       int</span><br><span class="line">       main(int argc, char *argv[])</span><br><span class="line">       &#123;</span><br><span class="line">           char *stack;                    /* Start of stack buffer */</span><br><span class="line">           char *stackTop;                 /* End of stack buffer */</span><br><span class="line">           pid_t pid;</span><br><span class="line">           struct utsname uts;</span><br><span class="line"></span><br><span class="line">           if (argc &lt; 2) &#123;</span><br><span class="line">               fprintf(stderr, &quot;Usage: %s &lt;child-hostname&gt;\n&quot;, argv[0]);</span><br><span class="line">               exit(EXIT_SUCCESS);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           /* Allocate stack for child */</span><br><span class="line"></span><br><span class="line">           stack = malloc(STACK_SIZE);</span><br><span class="line">           if (stack == NULL)</span><br><span class="line">               errExit(&quot;malloc&quot;);</span><br><span class="line">           stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */</span><br><span class="line"></span><br><span class="line">           /* Create child that has its own UTS namespace;</span><br><span class="line">              child commences execution in childFunc() */</span><br><span class="line"></span><br><span class="line">           pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);</span><br><span class="line">           if (pid == -1)</span><br><span class="line">               errExit(&quot;clone&quot;);</span><br><span class="line">           printf(&quot;clone() returned %ld\n&quot;, (long) pid);</span><br><span class="line"></span><br><span class="line">           /* Parent falls through to here */</span><br><span class="line"></span><br><span class="line">           sleep(1);           /* Give child time to change its hostname */</span><br><span class="line"></span><br><span class="line">           /* Display hostname in parent&#x27;s UTS namespace. This will be</span><br><span class="line">              different from hostname in child&#x27;s UTS namespace. */</span><br><span class="line"></span><br><span class="line">           if (uname(&amp;uts) == -1)</span><br><span class="line">               errExit(&quot;uname&quot;);</span><br><span class="line">           printf(&quot;uts.nodename in parent: %s\n&quot;, uts.nodename);</span><br><span class="line"></span><br><span class="line">           if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */</span><br><span class="line">               errExit(&quot;waitpid&quot;);</span><br><span class="line">           printf(&quot;child has terminated\n&quot;);</span><br><span class="line"></span><br><span class="line">           exit(EXIT_SUCCESS);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>我们来参照例子写一个程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># cat ns.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">     <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">     <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;在子进程中!\n&quot;</span>);</span><br><span class="line">     execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;程序开始:\n&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">     waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;已退出\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行测试下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 test_namespace]# gcc -Wall ns.c -o ns.o</span><br><span class="line">[root@slions_pc1 test_namespace]# ls</span><br><span class="line">ns.c  ns.o</span><br><span class="line">[root@slions_pc1 test_namespace]# ./ns.o</span><br><span class="line">程序开始:</span><br><span class="line">在子进程中!</span><br><span class="line">[root@slions_pc1 test_namespace]# exit</span><br><span class="line">exit</span><br><span class="line">已退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UTS隔离测试"><a href="#UTS隔离测试" class="headerlink" title="UTS隔离测试"></a>UTS隔离测试</h2><p>修改代码，加入UTS隔离。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># cat ns.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">     <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">     <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;在子进程中!\n&quot;</span>);</span><br><span class="line">     sethostname(<span class="string">&quot;uts&quot;</span>,<span class="number">12</span>);</span><br><span class="line">     execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;程序开始:\n&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">     waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;已退出\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># gcc -Wall ns.c -o uts.o</span></span><br><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># ls</span></span><br><span class="line">ns.c  ns.o  uts.o</span><br><span class="line">[root@slions_pc1 test_namespace]# ./uts.o</span><br><span class="line">程序开始:</span><br><span class="line">在子进程中!</span><br><span class="line">[root@uts test_namespace]<span class="meta"># hostname</span></span><br><span class="line">uts</span><br><span class="line">[root@uts test_namespace]<span class="meta"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">已退出</span><br><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># hostname</span></span><br><span class="line">slions_pc1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，加了CLONE_NEWUTS flags使得新进程的主机名发生了改变，并且不会影响其他进程的主机名。</p><h2 id="PID隔离测试"><a href="#PID隔离测试" class="headerlink" title="PID隔离测试"></a>PID隔离测试</h2><p>下面再介绍下PID namespaces的实现，修改相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># cat ns.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">     <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">     <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;在子进程中!\n&quot;</span>);</span><br><span class="line">     sethostname(<span class="string">&quot;pid&quot;</span>,<span class="number">12</span>);</span><br><span class="line">     execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;程序开始:\n&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">     waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;已退出\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># gcc -Wall ns.c -o pid.o</span></span><br><span class="line">[root@slions_pc1 test_namespace]# ^C</span><br><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># echo $$</span></span><br><span class="line"><span class="number">10588</span></span><br><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># gcc -Wall ns.c -o pid.o</span></span><br><span class="line">[root@slions_pc1 test_namespace]# ./pid.o</span><br><span class="line">程序开始:</span><br><span class="line">在子进程中!</span><br><span class="line">[root@pid test_namespace]<span class="meta"># echo $$</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[root@pid test_namespace]<span class="meta"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">已退出</span><br><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># echo $$</span></span><br><span class="line"><span class="number">10588</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，此时新进程的pid成为了1，且与宿主机进程互相隔离。</p><p>PID namespace 隔离非常实用，它对进程的PID重新标号，即两个不同的namespace下的进程可以有相同的PID。每个PID namespace 都有自己的计算程序。内核为所有的PID namespace 维护了一个树状的结构，最顶层是系统初始化时创建的，被称为root namespace ，而它创建的新的PID namespace 被称为child namespace 树的子节点 而原来的PID namespace就是新建的namespace的父节点。通过这种方式，不同的PID namespace会形成一个层级结构，所属父节点可以看子节点中的进程，可以通过信号等手段对子节点中的进程产生影响，反之子节点无法看到父节点的 PID namespace 中任何内容。</p><p>Unix 系统中，PID为1 的为init ，它被称为所有进程的父进程，维护一张进程表，不断检查进程状态，一旦发现某子进程因为父进程错误称为孤儿进程init就会负责收养这个子进程并最终回收资源，结束进程，<strong>所以在要实现的容器中，启动第一个进程也要有实现类似init的功能，维护后续启动进程的运行状态</strong>。</p><p>细心的人可能会发现一个问题，执行完pid隔离后在新进程中执行ps aux命令会出现一堆进程，这些是宿主机的所有进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 test_namespace]# ./pid.o</span><br><span class="line">程序开始:</span><br><span class="line">在子进程中!</span><br><span class="line">[root@pid test_namespace]# ps aux</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.1 193780  6828 ?        Ss   11:25   0:02 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">root          2  0.0  0.0      0     0 ?        S    11:25   0:00 [kthreadd]</span><br><span class="line">root          3  0.0  0.0      0     0 ?        S    11:25   0:02 [ksoftirqd/0]</span><br><span class="line">root          5  0.0  0.0      0     0 ?        S&lt;   11:25   0:00 [kworker/0:0H]</span><br><span class="line">root          7  0.0  0.0      0     0 ?        S    11:25   0:00 [migration/0]</span><br><span class="line">root          8  0.0  0.0      0     0 ?        S    11:25   0:00 [rcu_bh]</span><br><span class="line">root          9  0.0  0.0      0     0 ?        R    11:25   0:00 [rcu_sched]</span><br><span class="line">root         10  0.0  0.0      0     0 ?        S&lt;   11:25   0:00 [lru-add-drain]</span><br><span class="line">root         11  0.0  0.0      0     0 ?        S    11:25   0:00 [watchdog/0]</span><br><span class="line">root         12  0.0  0.0      0     0 ?        S    11:25   0:00 [watchdog/1]</span><br><span class="line">root         13  0.0  0.0      0     0 ?        S    11:25   0:00 [migration/1]</span><br><span class="line">root         14  0.0  0.0      0     0 ?        S    11:25   0:03 [ksoftirqd/1]</span><br><span class="line">root         16  0.0  0.0      0     0 ?        S&lt;   11:25   0:00 [kworker/1:0H]</span><br><span class="line">...</span><br><span class="line">[root@pid test_namespace]# ls /proc</span><br><span class="line">1      10628  11122  20    28    3074  42686  4313  4330   43504  49    8029  8801  8833  9631       cmdline      fb           keys        misc          schedstat      sysvipc</span><br><span class="line">10     10700  11153  21    29    3087  4271   4317  4331   43505  5     8035  8806  8836  9639       consoles     filesystems  key-users   modules       scsi           timer_list</span><br><span class="line">10148  10704  12     22    2909  3095  4273   4321  43334  43532  51    8042  8813  8864  98         cpuinfo      fs           kmsg        mounts        self           timer_stats</span><br><span class="line">10149  10706  13     23    2911  3099  42780  4322  43446  4400   53    8052  8814  8876  9926       crypto       interrupts   kpagecount  mpt           slabinfo       tty</span><br><span class="line">10150  10741  14     24    2947  3104  42799  4325  43466  4413   66    8059  8815  8925  acpi       devices      iomem        kpageflags  mtrr          softirqs       uptime</span><br><span class="line">10152  10865  16     25    3     35    4283   4326  43467  4415   7     8069  8816  9     asound     diskstats    ioports      loadavg     net           stat           version</span><br><span class="line">10582  10924  18     26    3002  36    4286   4327  43468  4423   8     8795  8817  9407  buddyinfo  dma          irq          locks       pagetypeinfo  swaps          vmallocinfo</span><br><span class="line">10586  10940  19     27    3006  37    42922  4328  43484  46     8017  8796  8820  9408  bus        driver       kallsyms     mdstat      partitions    sys            vmstat</span><br><span class="line">10588  11     2      2722  3060  38    4307   4329  43503  48     8024  8797  8821  9411  cgroups    execdomains  kcore        meminfo     sched_debug   sysrq-trigger  zoneinfo</span><br><span class="line">[root@pid test_namespace]# kill -9 10940</span><br><span class="line">bash: kill: (10940) - 没有那个进程</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是因为ps命令是从procfs读取数据的，而此时procfs并没有得到隔离，虽然能看到这些进程，但是它们其实是在另一个PID Namespace中，因此无法向这些进程发送信号。</p><p>那么我们想让宿主机和新进程的/proc互相隔离如何做呢，使用mount隔离是不是就好了呢？</p><h2 id="MOUNT隔离测试"><a href="#MOUNT隔离测试" class="headerlink" title="MOUNT隔离测试"></a>MOUNT隔离测试</h2><p>mount namespace 通过隔离文件系统挂载点对隔离文件系统提供支持，隔离后，不同mount namespace 中的文件结构发生变化也互不影响。可以通过/proc/[pid]/mounts 查看到所在namespace中文件设备统计信息，包括挂载文件的名、文件系统类型、挂载位置等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># cat ns.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">     <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">     <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;在子进程中!\n&quot;</span>);</span><br><span class="line">     sethostname(<span class="string">&quot;pid&quot;</span>,<span class="number">12</span>);</span><br><span class="line">     execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;程序开始:\n&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">     waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;已退出\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">[root@slions_pc1 test_namespace]<span class="meta"># gcc -Wall ns.c -o mnt.o</span></span><br><span class="line">[root@slions_pc1 test_namespace]# ./mnt.o</span><br><span class="line">程序开始:</span><br><span class="line">在子进程中!</span><br><span class="line">[root@pid test_namespace]<span class="meta"># echo $$</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[root@pid test_namespace]<span class="meta"># ps -elf |head -15</span></span><br><span class="line">F S UID         PID   PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD</span><br><span class="line"><span class="number">4</span> S root          <span class="number">1</span>      <span class="number">0</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> - <span class="number">48445</span> ep_pol <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span> /usr/lib/systemd/systemd --switched-root --system --deserialize <span class="number">22</span></span><br><span class="line"><span class="number">1</span> S root          <span class="number">2</span>      <span class="number">0</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -     <span class="number">0</span> kthrea <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [kthreadd]</span><br><span class="line"><span class="number">1</span> S root          <span class="number">3</span>      <span class="number">2</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -     <span class="number">0</span> smpboo <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span> [ksoftirqd/<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span> S root          <span class="number">5</span>      <span class="number">2</span>  <span class="number">0</span>  <span class="number">60</span> <span class="number">-20</span> -     <span class="number">0</span> worker <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [kworker/<span class="number">0</span>:<span class="number">0</span>H]</span><br><span class="line"><span class="number">1</span> S root          <span class="number">7</span>      <span class="number">2</span>  <span class="number">0</span> <span class="number">-40</span>   - -     <span class="number">0</span> smpboo <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [migration/<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span> S root          <span class="number">8</span>      <span class="number">2</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -     <span class="number">0</span> rcu_gp <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_bh]</span><br><span class="line"><span class="number">1</span> S root          <span class="number">9</span>      <span class="number">2</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -     <span class="number">0</span> rcu_gp <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_sched]</span><br><span class="line"><span class="number">1</span> S root         <span class="number">10</span>      <span class="number">2</span>  <span class="number">0</span>  <span class="number">60</span> <span class="number">-20</span> -     <span class="number">0</span> rescue <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [lru-add-drain]</span><br><span class="line"><span class="number">5</span> S root         <span class="number">11</span>      <span class="number">2</span>  <span class="number">0</span> <span class="number">-40</span>   - -     <span class="number">0</span> smpboo <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [watchdog/<span class="number">0</span>]</span><br><span class="line"><span class="number">5</span> S root         <span class="number">12</span>      <span class="number">2</span>  <span class="number">0</span> <span class="number">-40</span>   - -     <span class="number">0</span> smpboo <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [watchdog/<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span> S root         <span class="number">13</span>      <span class="number">2</span>  <span class="number">0</span> <span class="number">-40</span>   - -     <span class="number">0</span> smpboo <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [migration/<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span> S root         <span class="number">14</span>      <span class="number">2</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -     <span class="number">0</span> smpboo <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">03</span> [ksoftirqd/<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span> S root         <span class="number">16</span>      <span class="number">2</span>  <span class="number">0</span>  <span class="number">60</span> <span class="number">-20</span> -     <span class="number">0</span> worker <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [kworker/<span class="number">1</span>:<span class="number">0</span>H]</span><br><span class="line"><span class="number">5</span> S root         <span class="number">18</span>      <span class="number">2</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -     <span class="number">0</span> devtmp <span class="number">11</span>:<span class="number">25</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [kdevtmpfs]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加上CLONE_NEWNS后发现还是可以看到宿主机的/proc信息，前面说了，进程在创建mount namespace时， 会把当前的文件系统结构复制给新的namespace 。新的namespace中所有mount 操作都只影响自身的文件系统，对外界不产生任何影响。这种做法非常严格的实现了隔离，但对某些情况可能并不适用。</p><p>熟悉mount命令的可以知道，mount支持了多种挂载模式</p><table><thead><tr><th>名称</th><th></th></tr></thead><tbody><tr><td>共享挂载</td><td>传播事件的挂载对象</td></tr><tr><td>从属挂载</td><td>接受传播事件的挂载对象</td></tr><tr><td>共享/从属挂载</td><td>即具备传播事件也具备接受传播事件的挂载对象</td></tr><tr><td>私有挂载</td><td>既不传播也不接受事件的挂载对象</td></tr><tr><td>不可绑定挂载</td><td>另一种特殊挂载对象，他们与私有挂载相似，但不允许执行绑定挂载</td></tr></tbody></table><p> <img src="/doc_picture/docker-3.png" alt="img"></p><p>最上一层的mount namespace 下的 /bin 目录 与 child namespace 通过master slave 方式进行挂载传播，当mount namespace中的/bin 目录发生变化时，发生的挂载事件能够自动传播到 child namespace中；/lib 目录使用完全共享挂载，各 namespace 之间发生变化时都会影响；proc 目录使用私有挂载传播方式，各namespace之间互相隔离；最后/root目录一般管理员所有，不能让其他namespace挂载绑定。</p><p>了解了上述，我们可以通过在这个PID namespace里挂载procfs来解决。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@slions_pc1 test_namespace]# ./mnt.o</span><br><span class="line">程序开始:</span><br><span class="line">在子进程中!</span><br><span class="line">[root@pid test_namespace]# ls /proc</span><br><span class="line">1      10628  11122  20    28    3074  42686  4313  4330   43805  49    8029  8801  8833  9631       cmdline      fb           keys        misc          schedstat      sysvipc</span><br><span class="line">10     10700  11153  21    29    3087  4271   4317  4331   43806  5     8035  8806  8836  9639       consoles     filesystems  key-users   modules       scsi           timer_list</span><br><span class="line">10148  10704  12     22    2909  3095  4273   4321  43468  43833  51    8042  8813  8864  98         cpuinfo      fs           kmsg        mounts        self           timer_stats</span><br><span class="line">10149  10706  13     23    2911  3099  42780  4322  43704  4400   53    8052  8814  8876  9926       crypto       interrupts   kpagecount  mpt           slabinfo       tty</span><br><span class="line">10150  10741  14     24    2947  3104  42799  4325  43713  4413   66    8059  8815  8925  acpi       devices      iomem        kpageflags  mtrr          softirqs       uptime</span><br><span class="line">10152  10865  16     25    3     35    4283   4326  43739  4415   7     8069  8816  9     asound     diskstats    ioports      loadavg     net           stat           version</span><br><span class="line">10582  10924  18     26    3002  36    4286   4327  43741  4423   8     8795  8817  9407  buddyinfo  dma          irq          locks       pagetypeinfo  swaps          vmallocinfo</span><br><span class="line">10586  10940  19     27    3006  37    42922  4328  43761  46     8017  8796  8820  9408  bus        driver       kallsyms     mdstat      partitions    sys            vmstat</span><br><span class="line">10588  11     2      2722  3060  38    4307   4329  43782  48     8024  8797  8821  9411  cgroups    execdomains  kcore        meminfo     sched_debug   sysrq-trigger  zoneinfo</span><br><span class="line">[root@pid test_namespace]# mount --make-private -t proc proc /proc/</span><br><span class="line">[root@pid test_namespace]# ls /proc</span><br><span class="line">1       buddyinfo  consoles  diskstats    fb           iomem     kcore      kpagecount  mdstat   mounts  pagetypeinfo  scsi      stat           sysvipc      uptime       zoneinfo</span><br><span class="line">30      bus        cpuinfo   dma          filesystems  ioports   keys       kpageflags  meminfo  mpt     partitions    self      swaps          timer_list   version</span><br><span class="line">acpi    cgroups    crypto    driver       fs           irq       key-users  loadavg     misc     mtrr    sched_debug   slabinfo  sys            timer_stats  vmallocinfo</span><br><span class="line">asound  cmdline    devices   execdomains  interrupts   kallsyms  kmsg       locks       modules  net     schedstat     softirqs  sysrq-trigger  tty          vmstat</span><br><span class="line">[root@pid test_namespace]# exit</span><br><span class="line">exit</span><br><span class="line">已退出</span><br><span class="line">[root@slions_pc1 test_namespace]# ls /proc</span><br><span class="line">ls: 无法读取符号链接/proc/self: 没有那个文件或目录</span><br><span class="line">acpi       cgroups   crypto     driver       fs          irq       key-users   loadavg  misc     mtrr          sched_debug  slabinfo  sys            timer_stats  vmallocinfo</span><br><span class="line">asound     cmdline   devices    execdomains  interrupts  kallsyms  kmsg        locks    modules  net           schedstat    softirqs  sysrq-trigger  tty          vmstat</span><br><span class="line">buddyinfo  consoles  diskstats  fb           iomem       kcore     kpagecount  mdstat   mounts   pagetypeinfo  scsi         stat      sysvipc        uptime       zoneinfo</span><br><span class="line">bus        cpuinfo   dma        filesystems  ioports     keys      kpageflags  meminfo  mpt      partitions    self         swaps     timer_list     version</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时可以看到子进程内的/proc下只有自己namespace下的进程信息了，但是由于文件系统挂载点没有隔离，宿主机看到的procfs也会是这个新的procfs，所以我们应该先在宿主机执行<code>mount --make-private -t proc proc /proc/</code></p><h2 id="IPC、USER、NET隔离"><a href="#IPC、USER、NET隔离" class="headerlink" title="IPC、USER、NET隔离"></a>IPC、USER、NET隔离</h2><p>具体的测试步骤同上，不展开说了，感兴趣的可以自行测试下。</p><p><strong>IPC:</strong></p><p>进程间通信(Inter-Process Communication，IPC)涉及的IPC资源包括常见的信号量、消息队列和共享内存。申请IPC资源就申请了一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，不同IPC namespace下的进程则互相不可见。</p><p><strong>USER:</strong></p><p>User namespace 主要是隔离用户的用户组ID。也就是说，一个进程的User ID 和Group ID 在User namespace 内外可以是不同的。比较常用的是，在宿主机上以一个非root用户运行创建一个User namespace，然后在User namespace里面却映射成root 用户。这样意味着，这个进程在User namespace里面有root权限，但是在User namespace外面却没有root的权限。</p><p><strong>NET:</strong></p><p>Network namespace 是用来隔离网络设备，IP地址端口等网络栈的namespace。Network namespace 可以让每个容器拥有自己独立的网络设备（虚拟的），而且容器内的应用可以绑定到自己的端口，每个 namesapce 内的端口都不会互相冲突。在宿主机上搭建网桥后，就能很方便的实现容器之间的通信，而且每个容器内的应用都可以使用相同的端口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们谈及docker，都知道docker容器本质上是宿主机的进程，Docker通过namespace实现了资源隔离，通过cgroups实现了资源限制，接下来先聊聊namespaces是怎么一回事。&lt;/p&gt;
&lt;h1 id=&quot;namespace是什么&quot;&gt;&lt;a href=&quot;#na</summary>
      
    
    
    
    
    <category term="docker" scheme="https://slions.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://slions.github.io/2021/07/08/hello-world/"/>
    <id>https://slions.github.io/2021/07/08/hello-world/</id>
    <published>2021-07-08T06:30:33.217Z</published>
    <updated>2021-07-08T14:28:02.653Z</updated>
    
    <content type="html"><![CDATA[<p>好早之前就有弄个自己博客的想法，但由于种种原因没能实现（其实就是懒），最近几年也一直更新维护着公司产品的文档中心与问题库，今天看到了几位大牛的博客感触颇深，终于在今天花了一下午时间把博客和主题啥的敲定了。</p><p>今后的日子里就是积累和产出的过程，自己也会把前几年记录的一些技术文档整理下不定时更新，也会发一些日常观察生活的图片文字。</p><p>希望做个高产的博主了，先说到这儿吧，晚安。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好早之前就有弄个自己博客的想法，但由于种种原因没能实现（其实就是懒），最近几年也一直更新维护着公司产品的文档中心与问题库，今天看到了几位大牛的博客感触颇深，终于在今天花了一下午时间把博客和主题啥的敲定了。&lt;/p&gt;
&lt;p&gt;今后的日子里就是积累和产出的过程，自己也会把前几年记录</summary>
      
    
    
    
    
  </entry>
  
</feed>
